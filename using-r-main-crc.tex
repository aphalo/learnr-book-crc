\documentclass[krantz2]{krantz}\usepackage{knitr}

%\usepackage{color}
\usepackage[cmyk]{xcolor}

%\usepackage[scale=0.15,text={\copyright\ 2023 P. J. Aphalo, draft of \today}]{draftwatermark}

\usepackage{hologo}

\usepackage{csquotes}

\usepackage{graphicx}
\DeclareGraphicsExtensions{.jpg,.pdf,.png}

\usepackage{animate}

\usepackage[style=authoryear-comp,giveninits,sortcites,maxcitenames=2,%
    mincitenames=1,maxbibnames=10,minbibnames=10,backref,uniquename=mininit,%
    uniquelist=minyear,sortgiveninits=true,backend=biber]{biblatex}

\newcommand{\href}[2]{\emph{#2} (\url{#1})}

\usepackage{framed}

\usepackage[british]{babel}

\usepackage{abbrev}
\usepackage{usingr}

\usepackage{imakeidx}

% for drawing flowcharts
\usepackage{tikz}
\usetikzlibrary{shapes.geometric,shapes.symbols,shapes.multipart,positioning,fit,arrows,matrix,backgrounds}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black]
%tight boxes
\tikzstyle{tprocess} = [rectangle, minimum width=2cm, minimum height=0.66cm, text centered, draw=black]
\tikzstyle{enclosure} = [rectangle, minimum width=3.4cm, minimum height=3cm, text centered, draw=black]
\tikzstyle{decision} = [diamond, aspect=2, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{arrow} = [thick,->,>=latex]

\tikzset{
 a/.style
  = {node distance=4em, text width=0.1em, minimum height=4em},
 b/.style
  = {rectangle, draw, fill=gray!10, node distance=4em, text width=6em,
     text centered, rounded corners, minimum height=4em, thick},
 bo/.style
  = {rectangle, draw, fill=orange!10, node distance=4em, text width=6em,
     text centered, rounded corners, minimum height=4em, thick},
 c/.style
  = {circle, draw, dashed, fill=orange!10, inner sep = 0pt, node distance=4em, text width=6em,
     text centered, thick},
 cc/.style
  = {circle, draw, dashed, fill=orange!10, inner sep = 0pt, node distance=4em, text width=3em,
     text centered, thick},
 l/.style
  = {draw, -latex, ultra thick},
 aa/.style
  = {node distance=4em, text width=0em, minimum height=0.5ex},
 ll/.style
  = {draw, {open triangle 45} -, thick},
}

%\usepackage{polyglossia}
%\setdefaultlanguage{english}

% floats
\setcounter{topnumber}{3}
\setcounter{bottomnumber}{3}
\setcounter{totalnumber}{4}
\renewcommand{\topfraction}{0.90}
\renewcommand{\bottomfraction}{0.90}
\renewcommand{\textfraction}{0.10}
\renewcommand{\floatpagefraction}{0.70}
\renewcommand{\dbltopfraction}{0.90}
\renewcommand{\dblfloatpagefraction}{0.70}

% Include subsections as deepest nested in TOC
\setcounter{tocdepth}{2}
% Subsections as deepest numbered
\setcounter{secnumdepth}{2}

% ensure page numbers are aligned in TOC
\makeatletter
\renewcommand{\@pnumwidth}{2.05em}
\makeatother

\addbibresource{rbooks.bib}
\addbibresource{references.bib}

\makeindex[title=General Index]
\makeindex[name=rindex,title=Alphabetic Index of \Rlang Names]
\makeindex[name=rcatsidx,title=Index of \Rlang Names by Category]
\makeindex[name=faqindex,title=Frequently Asked Questions,columns=1]
\makeindex[name=cloudindex] % used for wordcloud
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
\hyphenation{pro-cess-ing paren-the-ses spe-cif-ic au-thors in-ter-act-ed lim-it}

\title{\Huge{\fontseries{ub}\sffamily Learn R\\{\Large As a Language}}}

\author{Pedro J. Aphalo}

\date{Helsinki, \today}

% knitr setup















\frontmatter

\maketitle

\cleardoublepage

\setcounter{page}{5} %previous pages will be reserved for frontmatter to be added in later.
\tableofcontents
\listoffigures
\listoftables





%\include{frontmatter/foreword}


\chapter*{Preface}

\begin{VF}
Suppose that you want to teach the `cat' concept to a very young child. Do you explain that a cat is a relatively small, primarily carnivorous mammal with retractible claws, a distinctive sonic output, etc.? I'll bet not. You probably show the kid a lot of different cats, saying `kitty' each time, until it gets the idea. To put it more generally, generalisations are best made by abstraction from experience.

\VA{R. P. Boas}{\emph{Can we make mathematics intelligible?}, 1981}\nocite{Boas1981}
\end{VF}

\noindent
Why did I choose ``\emph{Learn R: As a Language}'' as the title? This book is based on exploration and practice that aims at teaching how to express various operations on data using the \Rlang language. It focuses on the language, rather than on specific types of data analysis, exposes the reader to current usage, and does not spare the quirks of the language. When we use our native language in everyday life, we do not think about grammar rules or sentence structure, except for the trickier or unfamiliar situations. My aim is for this book to help readers learn to use \Rlang in this same way, i.e., to become fluent in \Rlang. The book is structured around the elements of natural languages like English with chapter titles that highlight the parallels between them and the \Rlang language.

\emph{Learn R: As a Language} is different from other books about \Rlang in that it emphasises the learning of the language itself, rather than how to use it to address specific data analysis tasks. My aim has been to enable readers to use \Rlang to implement original solutions to the data analysis and data visualisation tasks they encounter. The use of quantitative methods and data analysis has become more frequent in fields with limited long-term tradition in their use, like humanities, or, the complexity of the methods used has dramatically increased, like in Biology. Such trends can be expected to continue in the future.

Currently, many students of biological and environmental sciences learn to use \Rlang in courses about statistics or data analysis. However, this is frequently not in enough depth to effectively use \Rlang in scripts for automating data analyses or to ensure their reproducibility. There are also many researchers in various fields who are already familiar with statistical principles and willing to switch from other software to \Rlang. \emph{Learn R: As a Language} is written with these readers in mind to serve both as a textbook and as a reference.

A language is a system of communication. Basic concepts and operations are based on abstractions that are shared across programming languages and relevant to programs of all sizes and complexities; these abstractions are explained in the book together with their implementation in the \Rlang language. Other abstractions and programming concepts, outside the scope of this book, are relevant to large and complex pieces of software meant to be widely distributed. In other words, \emph{Learn R: As a Language} aims at teaching and supporting \emph{programming in the small}: the use of \Rlang to automate the drudgery of data manipulation, including the different steps spanning from data input and exploration to the production of publication-ready illustrations and reproducible data-based reports.

Using a language actively is the most efficient way of learning it. By using it, I mean actually reading, writing, and running scripts or programs. \emph{Learn R: As a Language} supports learning the \Rlang language in a way comparable to how children learn to speak: they work out what the rules are, simply by listening to people speak and trying to utter what they want to tell their parents. Of course, small children also receive guidance through feedback, but they are not taught a prescriptive set of rules like when learning a second language at school. Instead of listening, readers will read and run code, and instead of speaking, readers will write and try to run \Rlang-language code on a computer. I do provide explanations and guidance, as understanding how \Rlang works greatly helps with its use. However, the approach I encourage in this book is for readers to play with the numerous examples and to create variations upon them, to find out by themselves the patterns behind the \Rlang language. Instead of parents being the sounding board for the first utterances of readers new to \Rlang, the computer will play this role. Although working through the examples in \emph{Learn R: As a Language} in a group of peers or in class is beneficial, the book is designed to be useful also in the absence of such support.

\paragraph*{Changes in the second edition.} I edited the text from the first edition to correct all errors and outdated examples or explanations known to me. This revised second edition reflects changes in \Rlang and the contributed packages used in the book. Very little of the code from the first edition had stopped working but deprecations meant that a few examples triggered messages or warnings, and will eventually fail. Recent ($>$\,4.0.0) versions of \Rlang have significant enhancements including the new pipe operator described and used in this second edition. Packages have also evolved acquiring new features like a new approach to flipping plots in \pkgname{ggplot2}.

I have aimed at making the book more accessible to readers with no previous experience in computer programming. Feedback from readers and reviewers highlighted a few gaps in the content and some difficult-to-follow explanations. I revised the text, in some cases changing the sequence of presentation. I added diagrams to illustrate the structure of different types of objects and flowcharts to describe how program constructs work. I added tables listing groups of related functions. New sections cover character string operations, and details of data wrangling in \Rlang. Some of the most frequently asked questions about \Rlang are answered in the text and separately indexed. All exercises or ``playgrounds'' are numbered to facilitate their use as class work and the sharing of model answers. As the first edition has been frequently found useful as a reference, I expanded the already thorough indexing and added more cross-references connecting related sections across the whole book.

An additional change is in my view about packages \pkgnameNI{dplyr} and \pkgnameNI{tidyr}, part of the \pkgname{tidyverse}. I have come to think that the rate of development of these two packages can make them difficult for users for whom data analysis is just one aspect of their occupation. As these packages are widely used, I emphasise more than in the first edition the differences between functions and classes from packages \pkgnameNI{dplyr} and \pkgnameNI{tidyr} and equivalent ones from base \Rlang. I added a section on working with dates and times using the \pkgnameNI{lubridate} package. I updated and reorganised the chapter describing package \pkgname{ggplot2} and some of its extensions.

In numbers, the page count has increased by 27\%, the number of figures from eight to twenty six plus nine in-text diagrams, and tables from none to seven. As for the design, text boxes have been replaced by call-outs marked with marginal bars. In addition, starting from version 2.0.0, the \pkgname{learnrbook} package supports the first and second editions of the book. It contains data, scripts, and all the code examples from both editions. It also helps with the installation of all the packages used in the book. The website at \url{https://www.learnr-book.info/} provides updated open-access content.

\section*{Acknowledgements}
I thank Jaakko Heinonen for introducing me in the late 1990s to the then new \Rlang. Along the way many experts have answered my questions in usenet and more recently in \stackoverflow. I wish to warmly thank members of my research group, students, collaborators, authors of books, and people I have met online or at conferences. They have made it possible for me to write this book. I am specially indebted to Dan Yavorsky, Tarja Lehto, Titta Kotilainen, Tautvydas Zalnierius, Fang Wang, Yan Yan, Neha Rai, Markus Laurel, Brett Cooper, Viivi Lindholm, Mat\v{e}j Rzehulka, Zuzana Svarna, colleagues, students, and anonymous reviewers for many very helpful comments on the draft manuscript and/or the first edition. Rob Calver, editor of both editions, provided advice and encouragement with great patience, Paul Boyd, Shashi Kumar, Ashraf Reza, Vaishali Singh, Lara Spieker, and Sherry Thomas efficiently helped with different aspects of this project.

The writing of this second edition was helped by a six-month sabbatical granted by the Faculty of Biological and Environmental Sciences of the University of Helsinki, Finland. I thank Prof.\ Kurt Fagerstedt for his support.

In many ways this text owes more to people who are not authors than to myself. However, as I am the one who has written \emph{Learn R: As a Language} and decided what to include and exclude, I take full responsibility for any errors and inaccuracies.
\vspace{1ex}

{\raggedleft \emph{Pedro J. Aphalo}\\
\raggedleft \emph{Helsinki, \today}

}

\mainmatter


\chapter{Using the Book to Learn \Rlang}

\begin{VF}
The important part of becoming a programmer is learning to think like a programmer. You don't need to know the details of a programming language by heart, you can just look that stuff up.\vspace{1ex}

\noindent The treasure is in the structure, not the nails.

\VA{P. Burns}{\emph{Tao Te Programming}, 2012}\nocite{Burns2012}
\end{VF}

\section{Aims of This Chapter}

In this chapter, I describe how I imagine the book can be used most effectively to learn the \Rlang language. Learning \Rlang and remembering what one has previously learnt and forgotten makes it also necessary to use this book and other sources as references. Learning to use \Rlang effectively also involves learning how to search for information and how to ask questions from other users, for example through online forums. Thus, I also give advice on how to find answers to \Rlang-related questions and how to use the available documentation.

\section{Approach and Structure}

Depending on previous experience, reading \emph{Learn R: As a Language} will be about exploring a new world or revisiting a familiar one. In both cases this book aims to be a travel guide, neither a traveller's account nor a cookbook of \Rlang recipes. It can be used as a course book, supplementary reading or for self-instruction, and also as a reference. My hope is that as a guide to the use of \Rlang, this book will remain useful to readers as they gain experience and develop skills.\vspace{1ex}

\noindent
\emph{I encourage readers to approach \Rlang like a child approaches his or her mother tongue when learning to speak: do not struggle, just play, and fool around with \Rlang! If the going gets difficult and frustrating, take a break! If you get a new insight, take a break to enjoy the victory!\vspace{1ex}
}

In \Rlang, like in most ``rich'' languages, there are multiple ways of coding the same operations. I have included code examples that aim to strike a balance between execution speed and readability. One could write equivalent \Rlang books using substantially different code examples. Keep this in mind when reading the book and using \Rlang. Keep also in mind that it is impossible to remember everything about \Rlang, and as a user you will frequently need to consult the documentation, even while doing the exercises in this book. The \Rlang language, in a broad sense, is vast because it can be expanded with independently developed packages. Learning to use \Rlang mainly consists of learning the basics plus developing the skill of finding your way in \Rlang, its documentation and on-line question-and-answer forums.

Readers should not aim to remember all the details presented in the book. This is impossible for most of us. Later use of this and other books, and documentation effectively as references, depends on a good grasp of a broad picture of how \Rlang works and on learning how to navigate the documentation; i.e., it is more important to remember abstractions and in what situations they are used, and function names, than the details of how to use them. Developing a sense of when one needs to be careful not to fall into a ``language trap'' is also important.

The book can be used both as a textbook for learning \Rlang and as a reference. It starts with simple concepts and language elements progressing towards more complex language structures and uses. Along the way readers will find, in each chapter, descriptions and examples of the common (usual) cases and the exceptions. Some books hide the exceptions and counterintuitive features from learners to make the learning easier; I instead have included these but marked them using icons and marginal bars. There are two reasons for choosing this approach. First, the boundary between boringly easy and frustratingly challenging is different for each of us, and varies depending on the subject dealt with. So, I hope the marks will help readers predict what to expect, how much effort to put into each section, and even what to read and what to skip. Second, if I had hidden the tricky bits of the \Rlang language, I would have made later use of \Rlang by the readers more difficult. It would have also made the book less useful as a reference.

The book contains many code examples as well as exercises. I expect readers will run code examples and try as many variations of them as needed to develop an understanding of the ``rules'' of the \Rpgrm language, e.g., how the function or feature exemplified works. This is what long-time users of \Rlang do when facing an unfamiliar feature or a gap in their understanding.

Readers who are new to \Rlang should read at least chapters \ref{chap:R:introduction} to \ref{chap:R:functions} sequentially. Possibly, skipping parts of the text and exercises marked as advanced. However, I expect to be most useful to these readers not to completely skip the description of unusual features and special cases but rather to skim enough from them so as to get an idea of what special situations they may face as \Rlang users. Exercises should not be skipped, as they are a key component of the didactic approach used.

Readers already familiar with \Rlang will be able to read the chapters in the book in any order, as the need arises. Marginal bars and icons, and the back and forward cross-references among sections, make possible for readers to \emph{find a good path} within the book both when learning \Rlang and when using the book as a reference.

I expect \emph{Learn R: As a Language} to remain useful as a reference to those readers who use it to learn \Rlang. It will also be useful as a reference to readers already familiar with \Rlang. To support the use of the book as a reference, I have been thorough with indexing, including many carefully chosen terms, their synonyms, and the names of all \Rlang objects and constructs discussed, collecting them in three alphabetical indexes: \emph{General index}, \emph{Index of R names by category}, and \emph{Alphabetic index of R names} starting at pages \pageref{idx:general}, \pageref{idx:rcats} and \pageref{idx:rindex}, respectively. I have also included back and forward cross-references linking related sections throughout the whole book.

\section{Typographic and Naming Conventions}

\subsection{Call-outs}

Marginal bars and icons are used in the book to inform about what content is advanced or included with a specific aim. The following icons and colours are used.

%\begin{infobox}
%Signals ancillary information, in most cases unrelated to \Rlang as a language.
%\end{infobox}

\begin{explainbox}
Signals in-depth explanations of specific \Rlang features or general programming concepts. Several of these explanations make reference to programming concepts or features of the \Rlang language that are explained later in the book. Readers new to \Rlang and computer programming can safely skip these call-outs on the first reading of the book. To become proficient in the use of \Rlang these readers are expected to return at a later time without hurry, preferably with a cup of coffee or tea to these call-outs. Readers with more experience, like those possibly reading individual chapters or using the book as a reference, will find these in-depth explanations useful.
\end{explainbox}

\begin{warningbox}
Signals important bits of information that must be remembered when using \Rlang---i.e., explanations of some unusual, but important, feature of the language or concepts that in my experience are easily missed by those new to \Rlang.
\end{warningbox}

\begin{faqboxNI}{Frequently asked question}
Signals my answer to a question that I expect to be useful to readers based on the popularity of similar or related questions posted in online forums. When reading through the book, they highlight things that are worth special attention. When using the book as a reference, they help find solutions to frequently encountered difficulties. Index on page \pageref{index:faq}.
\end{faqboxNI}

\begin{playground}
Signals a \emph{playground} containing open-ended exercises---ideas and pieces of \Rlang code to play with at the \Rlang console. I expect readers to run these examples both as is and after creating variations by editing the code, studying the output, or diagnosis messages, returned by \Rlang in each case. Numbered by chapter for easy reference.
\end{playground}

\begin{advplayground}
Signals an \emph{advanced playground} that requires more time to play with before grasping concepts than regular \emph{playgrounds}. Numbered by chapter together with other playgrounds.
\end{advplayground}

\subsection{Code conventions and syntax highlighting}

Small sections of program code interspersed within the main text, receive the name of \emph{code chunks}. In this book \Rlang code chunks are typeset in a typewriter font, using colour to highlight the different elements of the syntax, such as variables, functions, constant values, etc. The command line prompts (\verb|>| and \verb|+|) are not displayed in the chunks. \Rlang code elements embedded in the text are similarly typeset but always black. For example, in the code chunk below, \code{mean()} and \code{print()} are functions; 1, 5, and 3 are constant numeric values, and \code{z} is the name of a variable where the result of the computation done in the first line of code is stored. The line starting with \code{\#\#} shows what is printed or shown when executing the second statement: \code{[1] 1}. In the book, \code{\#\#} is used as a marker to signal output from \Rlang, it is not part of the output. As \code{\#} is the marker for comments in the \Rlang language, prepending \code{\#} to the output makes it possible to copy and paste into the \Rlang console the whole contents of the code chunks as they appear in the book.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{mean}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{3}\hlstd{)}
\hlkwd{print}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

When explaining general concepts I use short abstract names, while for real-life examples I use descriptive names. Although not required, for clarity, I use abstract names that hint at the structure of objects stored, such as \code{mat1} for a matrix, \code{vct4} for a vector and \code{df3} for a data frame. This convention resembles that followed by the base \Rlang documentation.

Code in playgrounds either works in isolation, or when it depends on objects created in the examples in the main text, this is mentioned within the playground. In playgrounds I use names in capital letters so that they are distinct. The code outside playgrounds does reuse objects created earlier in the same section, and occasionally in earlier sections of the same chapter.

\subsection{Diagrams}

To describe data objects, I use diagrams similar to Joseph N. Hall's PEGS (Perl Graphical Structures) \autocite{Hall1997}. I use colour fill to highlight the type of the stored objects. I use the ``signal'' sign for the names of whole objects and of their component members, the former with a thicker border. Below is an example from chapter \ref{chap:R:as:calc}.

\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=codeshadecolor},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}},
row 1 column 1/.style={nodes={draw}}}]

\matrix[array] (array) {
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
  &   &   &   &   &   &   &   &   &   \\};
\node[draw, fill=gray, minimum size=4mm] at (array-2-9) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-10.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\textcolor{blue}{\ \code{<name>}\strut}};
\draw (array-1-1.north)--++(90:3mm) node [above] (first) {First index};
\draw (array-1-10.east)--++(0:3mm) node [right]{positional indices};
\draw (array-2-10.east)--++(0:3mm) node [right]{Members or \textcolor{blue}{\code{<values>}}};
\node [align=center, anchor=south] at (array-2-9.north west|-first.south) (8) {element at index 9};
\draw (8)--(box);
%
\end{tikzpicture}
\end{footnotesize}
\end{center}

To describe code structure, I use diagrams based on boxes and arrows, while to describe the flow of code execution I use traditional flow charts.

In the different diagrams, I use the notation \textcolor{blue}{\code{<value>}},  \textcolor{blue}{\code{<statement>}}, \textcolor{blue}{\code{<name>}}, etc., as generic placeholders indicating \emph{any valid value}, \emph{any valid \Rlang statement}, \emph{any valid \Rlang name}, etc.

\section{Findings Answers to Problems}

\subsection{What are the options?}

First of all, do not panic! Every programmer, even those with decades of experience, gets stuck with problems from time to time and can run out of ideas for a while. This is normal and happens to all of us.

It is important to learn how to find answers as part of the routine of using \Rlang. We should start by reading the documentation of the function or object that we are trying to use, which in many cases also includes examples. \Rlang's help pages tell how to use individual functions or objects. In contrast, \Rlang's manual \emph{An Introduction to R}, and other books describe what functions or overall approaches to use for different tasks.

Reading the documentation and books not always helps. Sometimes one can become blind to the obvious, by being too familiar with a piece of code, as it also happens when writing in a natural language like English. A second useful step is, thus, looking at the code with ``different eyes'', those of a friend or workmate, or your own eyes a day or a week later.

One can also seek help in specialised online forums or from peers or ``local experts''. If searching in forums for existing questions and answers fails to yield a useful answer, one can write a new question in a forum.

When searching for answers, asking for an advice, or reading books, one can be confronted with different ways of approaching the same tasks. Do not allow this to overwhelm you; in most cases, it will not matter which approach you use as many computations can be done in \Rpgrm, as in any computer language, in several different ways, still obtaining the same result. Use the alternative that you find easier to understand.

\subsection{\Rlang's built-in help}

Every object available in base \Rlang or exported by an \Rlang extension package (functions, methods, classes, and data) is documented in \Rlang's help system. Sometimes a single help page documents several \Rlang objects. Not only help pages are always available, but they are structured consistently with a title, short description, and frequently also a detailed description. In the case of functions, parameter names, their purpose, and expected arguments are always described, as well as the returned value. Usually at the bottom of help pages, several examples of the use of the objects or functions are given. How to access \Rpgrm help is described in section \ref{sec:intro:using:R} on page \pageref{sec:intro:using:R}.

In addition to help pages, \Rpgrm's distribution includes useful manuals as PDF or HTML files. These manuals are also available at \url{https://rstudio.github.io/r-manuals/} restyled for easier reading in web browsers. In addition to help pages, many packages, contain \emph{vignettes} such as user guides or articles describing the algorithms used and/or containing use case examples. In the case of some packages, a web site with documentation in HTML format is also available. Package documentation can be also found in repositories like the \emph{Comprehensive R Archive Network}, better known as \CRAN. From \CRAN it is possible to download \Rpgrm and many extensions to it. The DESCRIPTION file of each \Rlang package provides contact information for the maintainer, links to web sites, and instructions on how to report bugs. Similar information plus a short description are frequently also available in a README file.

Error messages tend to be terse in \Rpgrm, and may require some lateral thinking and/or ``experimentation'' to understand the real cause behind problems. Learning to interpret error messages is necessary to become a proficient user of \Rpgrm, so forcing errors and warnings with purposely written ``bad'' code is a useful exercise.

\subsection{Online forums}\label{sec:intro:net:help}

\subsubsection*{Netiquette}
When posting requests for help, one needs to abide by what is usually described as ``netiquette'', which in many respects also applies to asking in person or by e-mail for help from a peer or local expert. Preference among sources of information depends on what one finds easier to use. Consideration towards others' time is necessary but has to be balanced against wasting too much of one's own time.

In\index{netiquette}\index{network etiquette} most internet forums, a certain behaviour is expected from those asking and answering questions. Some types of misbehaviour, such as the use of offensive or inappropriate language, will usually result in the user losing writing rights in a forum. Occasional minor misbehaviour usually results in the original question not being answered and, instead, the problem highlighted in a comment. In general, following the steps listed below will greatly increase your chances of getting a detailed and useful answer.

\begin{itemize}
  \item Do your homework: first search for existing answers to your question, both online and in the documentation. (Do mention that you attempted this without success when you post your question.)
  \item Provide a clear explanation of the problem, and all the relevant information. The version of \Rpgrm, operating system, and any packages loaded and their versions can be important.
  \item If at all possible, provide a simplified and short, but self-contained, code example that reproduces the problem (sometimes called a \emph{reprex}).
  \item Be polite.
  \item Contribute to the forum by answering other users' questions when you know the answer.
\end{itemize}

\begin{explainbox}
Carefully preparing a reproducible example\index{reproducible example} (``reprex'') is crucial. A \emph{reprex} is a self-contained and as simple as possible piece of computer code that triggers (and so demonstrates) a problem. If possible, when data are needed, a data set included in base \Rpgrm or artificial data generated within the reprex code should be used. If the problem can only be reproduced with one's own data, then one needs to provide a minimal subset of it that still triggers the problem.

While preparing a \emph{reprex} one has to simplify the code, and sometimes this step makes clear the nature of the problem. Always, before posting a reprex online, check it with the latest versions of \Rpgrm and any package being used. If sharing data, be careful about confidential information and either remove or mangle it.

I must say that about two out of three times I prepare a \emph{reprex}, it allows me to find the root of the problem and a solution or a work-around on my own. Preparing a \emph{reprex} takes some effort but it is worthwhile even if it ends up not being posted online.

\Rlang package \pkgname{reprex} and its \RStudio add-in simplify the creation of reproducible code examples, by creating and copying to the clipboard a reprex encoded in \Markdown and ready to be pasted into a question at \stackoverflow or an issue at \GitHub. See \url{https://reprex.tidyverse.org/} for details.
\end{explainbox}

\subsubsection*{StackOverflow}

Nowadays, \stackoverflow (\url{http://stackoverflow.com/}) is the best question-and-answer (Q\,\&\,A) support site for \Rpgrm. Within the \stackoverflow site there is an \Rlang collective. In most cases, searching for existing questions and their answers will be all that you need to do. If asking a question, make sure that it is really a new question. If there is some question that looks similar, make clear how your question is different.

\stackoverflow has a user-rights system based on reputation, and questions and answers can be up- and down-voted. Questions with the most up-votes are listed at the top of searches, and the most-voted answers to each question are also displayed first. Those who ask a question are expected to accept correct answers to help future readers. If the questions or answers one writes are up-voted or if answers are accepted one gains reputation (expressed as a number). As one accumulates reputation, one gets badges and additional rights, such as editing other users' questions and answers or later on, even deleting wrong answers or off-topic questions from the system. This sounds complicated, but works extremely well at ensuring that the base of questions and answers is relevant and correct, without relying heavily on nominated \emph{moderators}. When using \stackoverflow, do contribute by accepting correct answers, up-voting questions and answers that you find useful, down-voting those you consider poor, and flagging or correcting errors you may discover.

Being careful in the preparation of a reproducible example\index{reproducible example}\index{reprex|see{reproducible example}} is important in two situations: 1) when asking a question at \stackoverflow or other online forums and 2) when reporting a bug to the maintainer of any piece of software. For the question to be reliably answered or the problem to be fixed, the person answering a question, needs to be able to reproduce the problem, and after modifying the code, needs to be able to test if the problem has been solved or not. However, even if you are facing a problem caused by your misunderstanding of how \Rlang works, the simpler the example, the more likely that someone will quickly realise what your intention was when writing the code that produces a result different from what you expected. Even when it is not possible to create a reprex, one needs to ask clearly only one thing per question.

The code of conduct (\url{https://stackoverflow.com/conduct}) and help that explains expected behaviour (\url{https://stackoverflow.com/help}) are available at the site and worthwhile reading before using the site actively for the first time.

\subsubsection*{Contacting the author}

The best way to get in contact with me about this book is by raising an issue at \url{https://github.com/aphalo/learnr-book-crc/issues}. Issues can be used both to ask for support questions related to the book, report mistakes and suggest changes to the text, diagrams and/or example code. Edits to the manuscript of this book can be submitted as a pull request.

Issues are raised by filling-in an online form, on a web page that also contains brief instructions. Git issues are a very efficient way of keeping track of corrections that need to be done. As support questions usually reveal unclear explanations or other problems, raising issues to ask them facilitates the tasks of improving and keeping the book up-to-date.

\section{Further Reading}

To understand what programming as an activity is, you can read \citetitle{Burns2012} \autocite{Burns2012}. It will make easier the learning of programming in \Rlang, both practically and emotionally. In \citeauthor{Burns2012}'s words ``This is a book about what goes on in the minds of programmers''.


% !Rnw root = using-r.main.Rnw



\chapter{\Rlang: The Language and the Program}\label{chap:R:introduction}

\begin{VF}
In a world of \ldots\ relentless pressure for more of everything, one can lose sight of the basic principles---simplicity, clarity, generality---that form the bedrock of good software.

\VA{Brian W. Kernighan and Rob Pike}{\emph{The Practice of Programming}, 1999}\nocite{Kernighan1999}
\end{VF}

\section{Aims of This Chapter}

I share some facts about the history and design of the \Rlang language so that you can gain a good vantage point from which to grasp the logic behind \Rlang's features, making it easier to understand and remember them. You will learn the distinction between the \Rpgrm program itself and the front-end programs, like \RStudio, frequently used together with \Rpgrm.

You will also learn how to interact with \Rpgrm when sitting at a computer. You will learn the difference between typing commands interactively and reading each partial result from \Rlang on the screen as you enter them, versus using \Rlang scripts containing multiple commands stored in a file to execute or run a ``job'' that saves results to another file for later inspection.

I describe the steps taken in a typical scientific or technical study, including the data analysis workflow and the roles that \Rpgrm can play in it. I share my views on the advantages and disadvantages of textual command languages such as \Rlang compared to menu-driven user interfaces, frequently used in other statistics software. I discuss the role of textual languages and \emph{literate programming} in the very important question of the reproducibility of data analyses and mention how I have used them while writing and typesetting this book.

\section{What is \Rlang?}

\subsection{\Rlang as a language}
\index{R as a language@{\Rlang as a language}}
\Rlang is a computer language designed for data analysis and data visualisation, however, in contrast to some other scripting languages, it is, from the point of view of computer programming, a complete language---it is not missing any important feature. In other words, no fundamental operations or data types are lacking \autocite{Chambers2016}. I attribute much of its success to the fact that its design achieves a very good balance between simplicity, clarity, and generality. \Rlang excels at generality, thanks to its extensibility at the cost of only a moderate loss of simplicity, while clarity is ensured by enforced documentation of extensions and support for both object-oriented and functional approaches to programming. The same three principles can be also easily followed by user code written in \Rlang.

In the case of languages like \Cpplang, \Clang, \pascallang, and \langname{FORTRAN}, multiple software implementations exist (different compilers and interpreters, i.e., pieces of software that translate programs encoded in these languages into \emph{machine code} instructions for computer processors to run). So in addition to different flavours of each language stemming from different definitions, e.g., versions of international standards, different implementations of the same standard may have, usually small, unintentional and intentional differences.

Most people think\index{R as a language@{\Rlang as a language}}\index{R as a program@{\Rpgrm as a program}} of \Rpgrm as a computer program, similar to \pgrmname{SAS} or \pgrmname{SPSS}. \Rpgrm is indeed a computer program---a piece of software---but it is also a computer language, implemented in the \Rpgrm program. At the moment, this difference is not as important as for other languages because the \Rpgrm program is the only widely used implementation of the \Rlang language.

\Rlang started as a partial implementation of the then relatively new \Slang language \autocite{Becker1984,Becker1988}. When designed, \Slang, developed at Bell Labs in the U.S.A., provided a novel way of carrying out data analyses. \Slang evolved into \Splang \autocite{Becker1988}. \Splang was available as a commercial program, most recently from TIBCO, U.S. \Rlang started as a poor man's home-brewed implementation of \Slang, for use in teaching, developed by Robert Gentleman and Ross Ihaka at the University of Auckland, in New Zealand \autocite{Ihaka1996}. Initially, \Rpgrm, the program, implemented a subset of the \Slang language. The \Rpgrm program evolved until only relatively few differences between \Slang and \Rlang remained. These remaining differences are intentional---thought of as significant improvements. In more recent times, \Rlang overtook \Splang in popularity. The \Rlang language is not standardised, and no formal definition of its grammar exists. Consequently, the \Rlang language is defined by the behaviour of its implementation in the \Rpgrm program.

What makes \Rlang different from \pgrmname{SPSS}, \pgrmname{SAS}, etc., is that \Slang was designed from the start as a computer programming language. This may look unimportant for someone not actually needing or willing to write software for data analysis. However, in reality, it makes a huge difference because \Rlang is easily extensible, both using the \Rlang language for implementation and by calling from \Rlang functions and routines written in other computer programming languages such as \Clang, \Cpplang, \langname{FORTRAN}, \pythonlang, or \javalang. This flexibility means that new functionality can be easily added, and easily shared with a consistent \Rlang-based user interface. In other words, instead of having to switch between different pieces of software to do different types of analyses or plots, one can usually find a package that will make new tools seamlessly available within \Rlang.

The name\index{base R@{base \Rlang}} ``base \Rlang{}'' is used to distinguish \Rlang itself, as in the \Rpgrm executable included in the \Rpgrm distribution and its default packages, from \Rlang in a broader sense, which includes contributed packages. A few packages are included in the \Rpgrm distribution, but most \Rlang packages are independently developed extensions and separately distributed. The number of freely available open-source \Rlang packages available is huge, in the order of 20\,000.

The most important advantage of using a language like \Rlang is that instructions to the computer are given as text. This makes it easy to repeat or \emph{reproduce} a data analysis. Textual instructions serve to communicate to other people what has been done in a way that is unambiguous. Sharing the instructions themselves avoids a translation from a set of instructions to the computer into text readable to humans---for example, the materials and methods section of a paper.

\begin{explainbox}
Readers with programming experience will notice that some features of \Rlang differ from those in other programming languages. \Rlang does not have the strict type checks of \langname{Pascal} or \Cpplang. It has operators that can take vectors and matrices as operands. Reliable and fast \Rlang code tends to rely on different \emph{idioms} than well-written \langname{Pascal} or \Cpplang code.
\end{explainbox}

\subsection{\Rlang as a computer program}
\index{R as a program@{\Rpgrm as a program}}
\index{Windows@{\textsf{Windows}}|see{\textsf{MS-Windows}}}
The \Rpgrm program itself is open-source, i.e., its source code is available for anybody to inspect, modify, and use. A very small fraction of users will directly contribute improvements to the \Rpgrm program itself. However, those contributions and bug reports are important in making \Rpgrm extremely reliable. The executable \Rpgrm program we actually use can be built for different operating systems and computer hardware. The members of the \Rpgrm developing team aim to keep the results obtained from calculations done on all the different builds and computer architectures as consistent as possible. The idea is to ensure that computations return consistent results not only across updates to \Rpgrm but also across different operating systems, like \osname{Linux}, \osname{Unix} (including \osname{OS X}) and \osname{MS-Windows}, or computer hardware, like that based on \textsf{ARM} and \textsf{x86} processors.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/R-console-r}
  \caption[The \Rpgrm console]{The \Rpgrm console. This is where the user can type textual commands line by line. Here a user has typed \code{print("Hello")} and \textit{entered} it by ending the line of text by pressing the ``enter'' key. The result of running the command is displayed below the command. The character at the head of the input line, a ``$>$'' in this case, is called the command prompt, signalling where a command can be typed in. Commands entered by the user are displayed in red, while results returned by \Rlang are displayed in blue. ``\code{[1]}'' can be ignored here, its meaning is explained on page \pageref{par:print:vec:index}. The console as displayed in \Rpgrm \textsf{GUI} under \osnameNI{MS-Windows} is shown.}\label{fig:intro:console}
\end{figure}

The \Rpgrm program does not have a full-fledged graphical user interface (GUI), or menus from which to start different types of analyses. Instead, the user types the commands at the \Rpgrm console and the result is displayed starting on the next line (Figure \ref{fig:intro:console}). The same textual commands can also be saved into a text file, line by line, and such a file, called a ``script'' can substitute for the direct typing of the same sequence of commands at the console (writing and use of \Rlang scripts are explained in chapter \ref{chap:R:scripts} on page \pageref{chap:R:scripts}). When we work at the console, typing-in commands one by one, we use \Rlang \emph{interactively}. When we run a script, we may say that we run a ``batch job''. The two approaches described above are available in the \Rpgrm program itself.

\begin{explainbox}
As \Rpgrm is essentially a command-line application, it can be used on what nowadays are frugal computing resources, equivalent to a personal computer of three decades ago. \Rpgrm can run even on the Raspberry Pi\index{Raspberry Pi}, a micro-controller board with the processing power of a modest smartphone (see \url{https://r4pi.org/}). At the other end of the spectrum, on really powerful servers, \Rpgrm can be used for the analysis of big data sets with millions of observations. How powerful a computer is needed for a given data analysis task depends on the size of the data sets, on how patient one is, on the ability to select efficient algorithms and on writing ``good'' code.
\end{explainbox}

\section{Using \Rlang}\label{sec:intro:using:R}

\subsection{Editors and IDEs}
Integrated Development Environments (IDEs)\index{integrated development environment}\index{IDE|see{integrated development environment}} are normally used when developing computer programs. IDEs provide a centralised user interface from within which the different tools used to create and test a computer program can be accessed and used in coordination. Most IDEs include a dedicated editor capable of syntax highlighting (automatically colouring ``code words'' based on their role in the programming language), and even able to report some mistakes in advance of running the code. One could describe such an editor as the equivalent of a word processor with spelling and grammar checking that can alert about spelling and syntax errors for a computer language like \Rlang instead of a natural language like English. IDEs frequently add other features that help navigation of the programme source code and give easy access to documentation.

Nowadays, it is very common to use an IDE as a front-end or middleman between the user and the \Rpgrm program. Computations are still done in the \Rpgrm program, which is \emph{not} built-in in the IDEs. Of the available IDEs for \Rpgrm, \RStudio is currently the most popular by a wide margin. Recent versions of \RStudio support \pythonlang in addition to \Rlang.

\begin{explainbox}
  Readers with programming experience may be already familiar with Microsoft's free \pgrmname{Visual Studio Code} or the open-source \pgrmname{Eclipse} IDEs for which plugins supporting \Rpgrm are available.
\end{explainbox}

The main window of IDEs is in most cases divided into windows or panes, possibly with tabs. In \RStudio one has access to the \Rpgrm console, a text editor, a file-system browser, a pane for graphical output, and access to several additional tools such as for installing and updating extension packages. Although \RStudio supports very well the development of large scripts and packages, it is currently, in my opinion, also the best possible way of using \Rpgrm at the console as it has the \Rpgrm help system very well integrated both in the editor and \Rlang console. Figure \ref{fig:intro:rstudio} shows the main window displayed by \RStudio after running the same script as shown at the \Rpgrm console (Figure \ref{fig:intro:script}) and at the operating system command prompt (Figure \ref{fig:intro:shell}). By comparing these three figures, it is clear that \RStudio is really only a software layer between the user and an unmodified \Rpgrm executable. In \RStudio, the script was sourced by pressing the ``Source'' button at the top of the editor panel. \RStudio, in response to this, generated the code needed to source the file and ``entered'' it at the console (\ref{fig:intro:rstudio}, lower left screen panel, text in purple), the same console where we can directly type this same \Rpgrm command if we wish.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/Rstudio-script}
  \caption[Script in \RStudio]{The \RStudio interface after running the script that is visible in tab \texttt{my-script.R} of the editor pane (top left). Here I used the ``Source'' button to run the script and \Rpgrm printed the results to the \Rpgrm console in the lower left pane. The lower right pane shows a list of files, including the script open in the editor. The upper right pane displays a list of the objects currently visible in the user workspace, object \code{a}, which was created by the code in the second line of the \Rlang script.}\label{fig:intro:rstudio}
\end{figure}

\begin{explainbox}
When a script is run, if an error is triggered, \RStudio automatically finds the location of the error, a feature you will find useful when running code from exercises in this book. Other features are beyond what one needs for simple everyday data analysis and are aimed at package development and report generation. Tools for debugging, code profiling, benchmarking of code and unit tests, make it possible to analyse and improve performance as well as help with quality assurance and certification of \Rlang packages and exceed what you will need for this book's exercises and simple data analysis. \RStudio also integrates support for file version control, which is not only useful for package development but also for keeping track of the progress or concurrent work with collaborators in the analysis of data.
\end{explainbox}

The ``desktop'' version of \RStudio that one installs and uses locally, runs on most modern operating systems, such as \osname{Linux}, \osname{Unix}, \osname{OS X}, and \osname{MS-Windows}. There is also a server version that runs on \osname{Linux}, as well as a cloud service (\url{https://posit.cloud/}) providing shared access to such a server. The \RStudio server is used remotely through a web browser. The user interface is almost the same in all cases. Desktop and server versions are both distributed as unsupported free software and as supported commercial software.

\RStudio and other IDEs support saving of their state and some settings per working folder under the name of \emph{project}, so that work on a data analysis can be interrupted and later continued, even on a different computer. As mentioned in section \ref{sec:R:workspace} on page \pageref{sec:R:workspace}, when working with \Rlang we keep related files in a folder.

In this book, I provide only a minimum of guidance on the use of \RStudio, and no guidance for other IDEs. To learn more about \RStudio, please, read the documentation available through \RStudio's help menu and keep at hand a printed copy of the \RStudio cheat sheet while learning how to use it. This and other useful \Rlang-related cheatsheets can be downloaded at \url{https://posit.co/resources/cheatsheets/}. Additional instructions on the use of \RStudio, including a video, are available through the Resources menu entry of the book's website at \url{https://www.learnr-book.info/}.

\subsection{\Rlang sessions and workspaces}\label{sec:R:workspace}

We use \emph{session} to describe the interactive execution from start to finish of one running instance of the \Rpgrm program. We use \emph{workspace} to name the imaginary space were all objects currently available in an \Rpgrm session are stored. In \Rpgrm, the whole workspace can be stored in a single file on disk at the end or during a session and restored later into another session, possibly on a different computer. Usually, when working with \Rpgrm, we dedicate a folder in disk storage to store all files from a given data analysis project. We normally keep in this folder files with data to read in, scripts, a file storing the whole contents of the workspace, named by default \code{.Rdata} and a text file with the history of commands entered interactively, named by default \code{.Rhistory}. The user's files within this folder can be located in nested folders. There are no strict rules on how the files should be organised or on their number. The recommended practice is to avoid crowded folders and folders containing unrelated files. It is a good idea to keep in a given folder and workspace the work in progress for a single data analysis project or experiment, so that the workspace can be saved and restored easily between sessions and work continued from where one left it independently of work done in other workspaces. The folder where files are currently read and saved is in \Rpgrm documentation called the \emph{current working directory}. When opening an \code{.Rdata} file the current working directory is automatically set to the location where the \code{.Rdata} file was read from.

\begin{warningbox}
\RStudio projects are implemented as a folder with a name ending in \code{.Rprj}, located under the same folder where scripts, data, \code{.Rdata}, and \code{.Rhistory} are stored. This folder is managed by \RStudio and should be not modified or deleted by the user. Only in the very rare case of its corruption, it should be deleted, and the \RStudio project created again from scratch. Files \code{.Rdata} and \code{.Rhistory} should not be deleted by the user, except to reset the \Rlang workspace. However, this is unnecessary as it can be also easily achieved from within \Rpgrm.
\end{warningbox}

\subsection{Using \Rlang interactively}

Decades ago, users communicated with computers through a physical terminal (keyboard plus text-only screen) that was frequently called a \emph{console}\index{console}. A text-only interface to a computer program, in most cases a window or a pane within a graphical user interface, is still called a console. In our case, the \Rpgrm console (Figure \ref{fig:intro:console}). This is the native user interface of \Rpgrm.

Typing commands at the \Rpgrm console is useful when one is playing around, rather aimlessly exploring things, or trying to understand how an \Rpgrm function or operator we are not familiar with works. Once we want to keep track of what we are doing, there are better ways of using \Rpgrm, which allow us to keep a record of how an analysis has been carried out. The different ways of using \Rpgrm are not exclusive of each other, so most users will use the \Rpgrm console to test individual commands and plot data during the first stages of exploration. As soon as we decide how we want to plot or analyse the data, it is best to start using scripts. This is not enforced in any way by \Rpgrm, but scripts are what really brings to light the most important advantages of using a programming language for data analysis. In Figure \ref{fig:intro:console}, we can see how the \Rpgrm console looks. The text in red has been typed in by the user, except for the prompt \code{\textcolor{red}{$>$}}, and the text in blue is what \Rpgrm has displayed in response. It is essentially a dialogue between user and \Rpgrm. The console can \emph{look} different when displayed within an IDE like \RStudio, but the only difference is in the appearance of the text rather than in the text itself (cf.\ Figures \ref{fig:intro:console} and \ref{fig:intro:console:rstudio}).

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/r-console-rstudio}
  \caption[The \Rpgrm console in \RStudio]{The \Rpgrm console embedded in \RStudio. The same commands have been typed in as in Figure \ref{fig:intro:console}. Commands entered by the user are displayed in purple, while results returned by \Rpgrm are displayed in black.}\label{fig:intro:console:rstudio}
\end{figure}

The two previous figures showed the result of entering a single command. Figure \ref{fig:intro:console:capture} shows how the console looks after the user has entered several commands, each as a separate line of text.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/r-console-capture}
  \caption[The \Rpgrm console in use]{The \Rpgrm console after several commands have been entered. Commands entered by the user are displayed in red, while results returned by \Rpgrm are displayed in blue.}\label{fig:intro:console:capture}
\end{figure}

The examples in this book require only the console window for user input. Menu-driven programs are not necessarily bad, they are just unsuitable when there is a need to set very many options and choose from many different actions. They are also difficult to maintain when extensibility is desired, and when independently developed modules of very different characteristics need to be integrated. Textual languages also have the advantage, to be addressed in later chapters, that command sequences can be stored in human- and computer-readable text files. Such files constitute a record of all the steps used, and in most cases, make it trivial to manually reproduce the same steps at a later time. Scripts are a very simple and handy way of communicating to other users how a given data analysis has been done or can be done.

\begin{explainbox}
In the console one types commands at the \code{>} prompt. When one ends a line by pressing the return or enter key, if the line can be interpreted as an \Rlang command, the result will be printed at the console, followed by a new \code{>} prompt.
If the command is incomplete, a \code{+} continuation prompt will be shown, and you will be able to type in the rest of the command. For example, if the whole calculation that you would like to do is $1 + 2 + 3$, if you enter in the console \code{1 + 2 +} in one line, you will get a continuation prompt where you will be able to type \code{3}. However, if you type \code{1 + 2}, the result will be calculated, and printed.
\end{explainbox}

For example, one can search for a help page at the \Rpgrm console. Below are the first code example and the first playground in the book. This first example is for illustration only, and you can return to them later as only on page \pageref{sec:R:install} I discuss how to install or get access to the \Rpgrm program.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{help}\hlstd{(}\hlstr{"sum"}\hlstd{)}
\hlopt{?}\hlstd{sum}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Look at help for some other functions like \code{mean()}, \code{var()}, \code{plot()} and, why not, \Rfunction{help()} itself!

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{help}\hlstd{(help)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\begin{warningbox}
When trying to access help related to \Rlang extension packages through \Rlang's built in help, make sure the package is loaded into the current \Rlang session, as described on page \pageref{sec:packages:install}, before calling \Rfunction{help()}.
\end{warningbox}

When using \RStudio, there are easier ways of navigating to a help page than calling function \Rfunction{help()} by typing its name, for example, with the cursor on the name of a function in the editor or console, pressing the \textsf{F1} key opens the corresponding help page in the help pane. Letting the cursor hover for a few seconds over the name of a function at the \Rpgrm console will open ``bubble help'' for it. If the function is defined in a script or another file that is open in the editor pane, one can directly navigate from the line where the function is called to where it is defined. In \RStudio one can also search for help through the graphical interface. The \Rlang manuals can also be accessed most easily through the Help menu in \RStudio or \pgrmname{RGUI}.

\subsection{Using \Rlang in a ``batch job''}

To run a script,\index{scripts}\index{batch job} we need first to prepare a script in a text editor. Figure \ref{fig:intro:script} shows the console immediately after running the script file shown in the text editor. As before, red text, the command \code{source("my-script.R")}, was typed by the user, and the blue text in the console is what was displayed by \Rpgrm as a result of this action. The title bar of the console, shows ``R-console'', while the title bar of the editor shows the \emph{path} to the script file that is open and ready to be edited followed by ``R-editor''.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/R-console-script}
  \caption[Script sourced at the \Rpgrm console]{Screen capture of the \Rpgrm console and editor just after running a script. The upper pane shows the \Rpgrm console, and the lower pane, the script file in an editor. }\label{fig:intro:script}
\end{figure}

\begin{warningbox}
When working at the command prompt, most results are printed by default. However, within scripts one needs to use function \Rfunction{print()} explicitly when a result is to be displayed.
\end{warningbox}

A true ``batch job'' is not run at the \Rpgrm console but at the operating system command prompt, or shell. The shell is the console of the operating system---\osname{Linux}, \osname{Unix}, \osname{OS X}, or \osname{MS-Windows}. Figure \ref{fig:intro:shell} shows how running a script at the Windows command prompt looks. A script can be run at the operating system prompt to do time-consuming calculations with the output saved to a file. One may use this approach on a server, say, to leave a large data analysis job running overnight or even for several days.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/windows-cmd-script}
  \caption[Script at the Windows cmd prompt]{Screen capture of the \osname{MS-Windows} command console just after running the same script. Here we use \code{Rscript} to run the script; the exact syntax will depend on the operating system in use. In this case, \Rpgrm prints the results at the operating system console or shell, rather than in its own \Rpgrm console.}\label{fig:intro:shell}
\end{figure}

Within \RStudio desktop it is possible to access the operating system shell through the tab named ``Terminal'' and through the menu. It is also possible to run jobs in the background in the tab ``Background jobs'', i.e., while simultaneously using the \Rpgrm console. This is made possible by concurrently running two or more instances of the \Rpgrm program.

\section{Reproducible Data Analysis with \Rlang}
\index{reproducible data analysis|(}
Statistical concepts and procedures are not only important after data are collected but also crucial at the design stage of any data-based study. Rather frequently, we deal with pre-existing data already at the planning stage of an experiment or survey. Statistics provides the foundation for the design of experiments and surveys, data analysis, and data visualisation. This is similar to the role played by grammar and vocabulary in communication in a natural language like English. Statistics makes possible decision-making based on partial evidence (or samples), but it is also a means of communication. Data visualisation also plays a key role in the written and oral communication of study conclusions. \Rlang is useful throughout all stages of the research process, from the design of studies to the communication of the results.

During recent years, the lack of reproducibility in scientific research, frequently described as a \emph{reproducibility crisis}, has been broadly discussed and analysed \autocite{Gandrud2015}. One of the problems faced when attempting to reproduce scientific and technical studies is reproducing the data analysis. More generally, under any situation where accountability is important, from scientific research to decision making in commercial enterprises, industrial quality control and safety, and environmental impact assessments, being able to reproduce a data analysis reaching the same conclusions from the same data is crucial. Thus, an unambiguous description of the steps taken for an analysis is a requirement. Currently, most approaches to reproducible data analysis are based on automating report generation and including, as part of the report, all the computer commands that were used.

A reliable record of what commands have been run on which data is especially difficult to keep when issuing commands through menus and dialogue boxes in a graphical user interface or by interactively typing commands as text at a console. Even working interactively at the \Rpgrm console using copy and paste to include commands and results in a report typed in a word processor is error prone, and laborious. The use and archiving of \Rlang scripts alleviate this difficulty.

However, a further requirement to achieve reproducibility is the consistency between the saved and reported output and the \Rlang commands reported as having been used to produce them, saved separately when using scripts. This creates an error-prone step between data analysis and reporting. To solve this problem an approach to data analysis derived from what is called \emph{literate programming} \autocite{Knuth1984a} was developed: running an especially formatted script that produces a document that includes the \Rlang code used for the analysis; the results of running this code and any explanatory text needed to describe the methodology used and interpret the results of the analysis.

Although a system capable of producing such reports with \Rlang, called \pkgname{Sweave} \autocite{Leisch2002}, has been available for a couple of decades, it was rather limited and not supported by an IDE, making its use rather tedious. Package \pkgname{knitr} \autocite{Xie2013} further developed the approach and together with its integration into \RStudio made the use of this type of report much easier. Less sophisticated reports, called \Rlang \emph{notebooks}, formatted as HTML files can be created directly from ordinary \Rlang scripts containing no special formatting. Notebooks are HTML files that show as text the code used interspersed with the results, and can contain embedded the actual source script used to generate them.

Package \pkgname{knitr} supports the writing of reports with the textual explanations encoded using either \Markdown or \Latex\ as markup for text-formatting instructions. While \Markdown (\url{https://daringfireball.net/projects/markdown/}) is an easy-to-learn and use text markup approach, \Latex\ \autocite{Lamport1994} is based on \TeX\ \autocite{Knuth1987}, the most powerful typesetting engine freely available. There are different flavours of \Markdown, including \Rmarkdown (see \url{https://rmarkdown.rstudio.com/}) with special support for \Rlang code. \Quarto (see \url{https://quarto.org/}) was recently released as an enhancement of \Rmarkdown (see \url{https://rmarkdown.rstudio.com/}), improving typesetting and styling, and providing a single system capable of generating a broad selection of outputs. When used together with \Rlang, \Quarto relies on package \pkgname{knitr} for the key step in the conversion, so in a strict sense \Quarto does not replace it.

Because of the availability of these approaches to the generation of reports, the \Rlang language is extremely useful when reproducibility is important. Both \pkgname{knitr} and \Quarto are powerful and flexible enough to write whole books, such as this very book you are now reading, produced with \Rpgrm, \pkgname{knitr} and \LaTeX. All pages in the book were typeset directly, with plots and other \Rlang output generated on-the-fly by \Rpgrm and inserted automatically. All diagrams were generated by \LaTeX\ during the typesetting step. The only exceptions are the figures in this chapter that have been manually captured from the computer screen. Why am I using this approach? First, because I want to make sure that every bit of code, as you will see printed, runs without error. In addition, I want to make sure that the output displayed below every line or chunk of \Rlang language code is exactly what \Rpgrm returns. Furthermore, it saves a lot of work for me as an author, as I can just update \Rpgrm and all the packages used to their latest version, and build the book again, after any changes needed to keep it up to date and free of errors. By using these tools and markup in plain text files, the indices, cross-references, citations, and list of references are all generated automatically.

Although the use of these tools is very important, they are outside the scope of this book and well described in other books dedicated to them \autocite{Gandrud2015,Xie2013}. When using \Rlang in this way, a good command of \Rlang as a language for communication with both humans and computers is very useful.
\index{reproducible data analysis|)}

\section{Getting Ready to Use \Rlang}\label{sec:R:install}

As the book is designed with the expectation that readers will run code examples as they read the text, you have to ensure access to the \Rpgrm before reading the next chapter. It is likely that your school, employer or teacher has already enabled access to \Rpgrm. If not, or if you are reading the book on your own, you should install \Rpgrm or secure access to an online service. Using \RStudio or another IDE can facilitate the use of \Rpgrm, but all the code in the remaining chapters makes only use of \Rpgrm and packages available through \CRAN.

I have written an \Rlang package, named \pkgname{learnrbook}, containing original data and computer-readable listings for all code examples and exercises in the book. It also contains code and data that makes it easier to install the packages used in later chapters. Its name is \pkgname{learnrbook} and is available through \CRAN. \textbf{It is not necessary for you to install this or any other packages until section \ref{sec:packages:install} on page \pageref{sec:packages:install}, where I explain how to install and use \Rlang packages.}

\begin{faqbox}{Are there any resources to support the \emph{Learn R: As a Language} book?}
Please, visit \url{https://www.learnr-book.info/} to find additional material related to this book, including additional free chapters. Up-to-date instructions for software installation are provided online at this and other sites, as these instructions are likely to change after the publication of the book.
\end{faqbox}

\begin{faqbox}{How to install the \textsf{R} program in my computer?}
Installation of \Rpgrm varies depending on the operating system and computer hardware, and is in general similar to that of other software under a given operating system distribution. For most types of computer hardware, the current version of \Rpgrm is available through the Comprehensive \Rlang Archive Network (\CRAN) at \url{https://cran.r-project.org/}. Especially in the case of Linux distributions, \Rpgrm can frequently be installed as a component of the operating system distribution. There are some exceptions, such as the \textsl{R4Pi}\index{Raspberry Pi} distribution of \Rpgrm for the Raspberry Pi, which is maintained independently (\url{https://r4pi.org/}).

Installers for Linux, Windows and MacOS are available through \CRAN (\url{https://cran.r-project.org/}) together with brief but up-to-date installation instructions.
\end{faqbox}

\begin{faqbox}{How to install the \textsf{RStudio} IDE in my computer?}
\RStudio installers are available at Posit's web site (\url{https://posit.co/products/open-source/rstudio/}) of which the free version is suitable for running the code examples and exercises in the book. In many cases, the IT staff at your employer or school will install them, or they may be already included in the default computer setup.
\end{faqbox}

\begin{faqbox}{How to get access to \textsf{RStudio} as a cloud service?}
An alternative, that is very well suited for courses or learning as part of a group is the \RStudio cloud service, recently renamed Posit cloud (\url{https://posit.co/products/cloud/cloud/}). For individual use, a free account is in many cases enough, and for groups that qualify for the discounted price, a low-cost teacher's account works very well.
\end{faqbox}

\section{Further Reading}
Suggestions\index{further reading!shell scripts in Unix and Linux} for further reading are dependent on how you plan to use \Rlang. If you envision yourself running batch jobs under \pgrmname{Linux} or \pgrmname{Unix}, you would profit from learning to write shell scripts. Because \pgrmname{bash} is widely used nowadays, \citebooktitle{Newham2005} \autocite{Newham2005} can be recommended. If you aim at writing \Rlang code that is going to be reused, and have some familiarity with \Clang, \Cpplang or \javalang, reading \citetitle{Kernighan1999} \autocite{Kernighan1999} will provide a mostly language-independent view of programming as an activity and help you master the all-important tricks of the trade. The history of \Rlang, and its relation or \Slang, is best told by those who were involved at the early stages of its development, \citeauthor{Chambers2016} (\citeyear[][, chapter 2]{Chambers2016}), and \citeauthor{Ihaka1998} (\citeyear{Ihaka1998}).




% !Rnw root = appendix.main.Rnw



\chapter{Base \Rlang: ``Words'' and ``Sentences''}\label{chap:R:as:calc}

\begin{VF}
The desire to economise time and mental effort in arithmetical computations, and to eliminate human liability to error, is probably as old as the science of arithmetic itself.

\VA{Howard Aiken}{\emph{Proposed automatic calculating machine}, 1937; reprinted 1964}\nocite{Aiken1964}
\end{VF}

%\dictum[Howard Aiken, \emph{Proposed automatic calculating machine}, presented to IBM in 1937]{The desire to economise time and mental effort in arithmetical computations, and to eliminate human liability to error, is probably as old as the science of arithmetic itself.}\vskip2ex

\section{Aims of This Chapter}

In my experience, for those who are not familiar with computer programming languages, the best first step in learning the \Rlang language is to use it interactively by typing textual commands at the \Rpgrm \emph{console}. This teaches not only the syntax and grammar rules, but also gives a glimpse at the advantages and flexibility of this approach to data analysis. In this chapter, I focus on the different simple values or items that can be stored and manipulated in \Rpgrm, as well as the role of computer program statements, the equivalent of ``sentences'' in natural languages.

In the first part of the chapter, you will use \Rlang to do everyday calculations that should be so easy and familiar that you will not need to think about the operations themselves. This easy start will give you a chance to focus on learning how to issue textual commands at the command prompt.

Later in the chapter, you will gradually need to focus more on the \Rlang language and its grammar and less on how commands are entered. By the end of the chapter, you will be familiar with most of the kinds of simple ``words'' used in the \Rlang language and you will be able to read and write simple \Rlang statements.

Throughout the chapter, I will occasionally show the equivalent of the \Rlang code in mathematical notation. If you are not familiar with the mathematical notation, you can safely ignore the mathematics, as long as you understand the diagrams and the \Rlang code.

\section{Natural and Computer Languages}
\index{languages!natural and computer}
Computer languages have strict rules, and the interpreters and compilers that translate these languages into machine code are unforgiving about errors. They will issue error messages, but in contrast to human readers or listeners, will not guess your intentions and continue. However, computer languages have a much smaller set of words than natural languages, such as English. If you are new to computer programming, understanding the parallels between computer and natural languages may be useful.

One can think of constant values and variables (values stored under a name) as nouns and of operators and functions as verbs. A complete command, or statement, is the equivalent of a natural language sentence: ``a comprehensible utterance''. The simple statement \code{a + 1} has three components: \code{a}, a variable, \code{+}, an operator and \code{1} a constant. The statement \code{sqrt(4)} has two components, a function \code{sqrt()} and a numerical constant \code{4}. We say that ``to compute $\sqrt{4}$ we \emph{call} \code{sqrt()} with \code{4} as its \emph{argument}''.

Although all values manipulated in a digital computer are stored as \textit{bits} in memory, multiple interpretations are possible. Numbers, letters, logical values, etc., can be encoded into bits and decoded as long as their type or \code{mode} is known. The concept of \code{class} is not directly related to how values are encoded when stored in computer memory, but instead how they are interpretated as part of a computer program. We can have, for example, RGB colour values, stored as three numbers such as \code{0, 0, 255}, as hexadecimal numbers stored as characters {\#0000FF}, or even use fancy names stored as character strings like \code{"blue"}. We could create a \code{class} for colours using any of these representations, based on two different modes: \code{numeric} and \code{character}.

\section{Numeric Values and Arithmetic}\label{sec:calc:numeric}
\index{classes and modes!numeric, integer, double|(}\index{numbers and their arithmetic|(}\qRclass{numeric}\index{math operators}\index{math functions}\index{numeric values}\qRoperator{+}\qRoperator{-}\qRoperator{*}\qRoperator{/}
When working in \Rlang with arithmetic expressions, the normal mathematical precedence rules are followed and parentheses can be used to alter this order. Parentheses can be nested, but in contrast to the usual practice in mathematics, the same parenthesis symbol is used at all nesting levels.

\begin{explainbox}
 Both in mathematics and programming languages \emph{operator precedence rules} determine which subexpressions are evaluated first and which later. Contrary to primitive electronic calculators, \Rlang evaluates numeric expressions containing operators according to the rules of mathematics. In the expression $1 + 2 \times 3$, the product $2 \times 3$ has precedence over the addition, and is evaluated first, yielding as the result of the whole expression, 7. Similar rules apply to other operators, even those taking as operands non-numeric values.
\end{explainbox}

The equivalent of the math expression\qRfunction{exp()}\qRfunction{cos()}\qRconst{pi}
$$
\frac{3 + e^2}{\cos \pi}
$$
is, in \Rlang, written as follows:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{(}\hlnum{3} \hlopt{+} \hlkwd{exp}\hlstd{(}\hlnum{2}\hlstd{))} \hlopt{/} \hlkwd{cos}\hlstd{(pi)}
\end{alltt}
\begin{verbatim}
## [1] -10.38906
\end{verbatim}
\end{kframe}
\end{knitrout}

Where constant \Rconst{pi} ($\pi = 3.1415\ldots$) and function \Rfunction{cos()} (cosine) are defined in base \Rlang. Many trigonometric and mathematical functions are available in addition to operators like \verb|+|, \verb|-|, \verb|*|, \verb|/|, and \verb|^|.

\begin{warningbox}
  In \Rlang, angles are expressed in radians, thus $\cos(\pi) = 1$ and $\sin(\pi) = 0$, according to trigonometry. Degrees can be converted into radians taking into account that the circle corresponds to $2 \times \pi$ when expressed in radians and to $360^\circ$ when expressed in degrees. Thus the cosine of an angle of $45^\circ$ can be computed as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{45}\hlopt{/}\hlnum{180} \hlopt{*} \hlstd{pi)}
\end{alltt}
\begin{verbatim}
## [1] 0.7071068
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

One thing to remember when translating fractions into \Rlang code is that in arithmetic expressions the bar of the fraction generates a grouping that alters the normal precedence of operations. In contrast, in \Rlang expressions this grouping must be explicitly signalled with additional parentheses.

If you are in doubt about how precedence rules work, you can add parentheses to make sure the order of computations is the one you intend. Redundant parentheses have no effect.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{+} \hlnum{2} \hlopt{*} \hlnum{3}
\end{alltt}
\begin{verbatim}
## [1] 7
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{+} \hlstd{(}\hlnum{2} \hlopt{*} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 7
\end{verbatim}
\begin{alltt}
\hlstd{(}\hlnum{1} \hlopt{+} \hlnum{2}\hlstd{)} \hlopt{*} \hlnum{3}
\end{alltt}
\begin{verbatim}
## [1] 9
\end{verbatim}
\end{kframe}
\end{knitrout}

The number of opening (left side) and closing (right side) parentheses must be balanced, and they must be located so that each enclosed term is a valid mathematical expression, i.e., code that can be evaluated to return a value, a value that can be inserted in place of the expression enclosed in parenthesis before evaluating the remaining of the expression. For example, \code{(1 + 2) * 3} after evaluating \code{(1 + 2)} becomes \code{3 * 3} yielding \code{9}. In contrast, \code{(1 +) 2 * 3} is a syntax error as \code{1 +} is incomplete and does not yield a number.

\begin{playground}
In \emph{playgrounds} the output from running the code in \Rpgrm is not shown, as these are exercises for you to enter at the \Rpgrm console and run. In general, you should not skip them as in most cases playgrounds aim to teach or demonstrate concepts or features that I have \emph{not} included in full-detail in the main text. You are strongly encouraged to \emph{play}, in other words, to create new variations of the examples and execute them to explore how \Rlang works.\qRfunction{sqrt()}\qRfunction{sin()}\qRfunction{log()}\qRfunction{log10()}\qRfunction{log2()}\qRfunction{exp()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{+} \hlnum{1}
\hlnum{2} \hlopt{*} \hlnum{2}
\hlnum{2} \hlopt{+} \hlnum{10} \hlopt{/} \hlnum{5}
\hlstd{(}\hlnum{2} \hlopt{+} \hlnum{10}\hlstd{)} \hlopt{/} \hlnum{5}
\hlnum{10}\hlopt{^}\hlnum{2} \hlopt{+} \hlnum{1}
\hlkwd{sqrt}\hlstd{(}\hlnum{9}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pi}
\hlkwd{sin}\hlstd{(pi)}
\hlkwd{log}\hlstd{(}\hlnum{100}\hlstd{)}
\hlkwd{log10}\hlstd{(}\hlnum{100}\hlstd{)}
\hlkwd{log2}\hlstd{(}\hlnum{8}\hlstd{)}
\hlkwd{exp}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

Variables\index{variables}\index{assignment} are used to store values. After we \emph{assign} a value to a variable, we can use in our code the name of the variable in place of the stored value. The ``usual'' assignment operator is \Roperator{<-}. In \Rlang, all names, including variable names, are case sensitive. Variables \code{a} and \code{A} are two different variables. Variable names can be long in \Rlang, although it is not a good idea to use very long names. Here I am using very short names, something that is usually also a very bad idea. However, in the examples in this chapter, where the stored values have no connection to the real world, simple names emphasise their abstract nature. In the chunk below, \code{vct1} and \code{vct2} are arbitrarily chosen variable names; I should have used names like \code{height.cm} or \code{outside.temperature.C} if they had been useful to convey information.

In the book, I use variable names that help recognise the kind of object stored, as this is most relevant when learning \Rlang. Here I use \code{vct1} because in \Rlang, as we will see on page \pageref{par:numeric:vectors:start}, numeric objects are always vectors, even when of length one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlnum{1}
\hlstd{vct1} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlnum{10}
\hlstd{vct2} \hlkwb{<-} \hlstd{vct1} \hlopt{+} \hlstd{vct2}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
## [1] 11
\end{verbatim}
\end{kframe}
\end{knitrout}

Entering the name of a variable \emph{at the \Rlang console} implicitly calls function \code{print()} displaying the stored value on the console. The same applies to any other statement entered \emph{at the \Rlang console}: \code{print()} is implicitly called with the result of executing the statement as its argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{vct1} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(vct1} \hlopt{+} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}
\begin{playground}
There are some syntactically legal assignment statements that are not very frequently used, but you should be aware that they are valid, as they will not trigger error messages and may surprise you. The most important thing is to write code consistently. The ``backwards'' assignment operator \Roperator{->} and resulting code like \code{1 -> vct1}\index{assignment!leftwise} are valid but less frequently used. The use of the equals sign (\Roperator{=}) for assignment in place of \Roperator{<-} although valid is discouraged. Chaining\index{assignment!chaining} assignments as in the first statement below can be used to signal to the human reader that \code{vct1}, \code{vct2} and \code{vct3} are being assigned the same value.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{VCT1} \hlkwb{<-} \hlstd{VCT2} \hlkwb{<-} \hlstd{VCT3} \hlkwb{<-} \hlnum{0}
\hlstd{VCT1}
\hlstd{VCT2}
\hlstd{VCT3}
\hlnum{1} \hlkwb{->} \hlstd{VCT1}
\hlstd{VCT1}
\hlstd{VCT1} \hlkwb{=} \hlnum{3}
\hlstd{VCT1}
\hlkwd{remove}\hlstd{(VCT1, VCT2, VCT3)} \hlcom{# cleanup}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{explainbox}\label{box:integer:float}
In\index{numeric, integer and double values} \Rlang, all numbers belong to mode \Rclass{numeric} (we will discuss the concepts of \emph{mode} and \emph{class} in section \ref{sec:rlang:mode} on page \pageref{sec:rlang:mode}). We can query if the mode of an object is \Rclass{numeric} with function \Rfunction{is.numeric()}. The returned values are either \code{TRUE} or \code{FALSE}. These are logical values that will be discussed in section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlnum{1}
\hlkwd{is.numeric}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Because numbers can be stored in computer memory in different formats, most computing languages, including \Rlang, implement multiple types of numerical values. In most cases, \Rpgrm's \code{numeric} values can be used everywhere that a number is expected. However, in some cases, explicitly using class \Rclass{integer} to indicate that we will store or operate on whole numbers, can be advantageous, e.g., \Rclass{integer} constants are identified by a trailing capital ``L'', as in  \code{32L}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(}\hlnum{1L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.integer}\hlstd{(}\hlnum{1L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.double}\hlstd{(}\hlnum{1L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Real numbers are a mathematical abstraction, and do not have an exact equivalent in computers. Instead of Real numbers, computers store and operate on numbers that are restricted to a broad but finite range of values and have a finite resolution. They are called, \emph{floats} (or \emph{floating-point} numbers); in \Rlang they go by the name of \Rclass{double} and can be created with the constructor \Rfunction{double()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.integer}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.double}\hlstd{(}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\index{vectors!introduction|(}\label{par:calc:vectors:diag}
Vectors\label{par:numeric:vectors:start} are one-dimensional in structure, of varying length and used to store similar values, e.g., numbers. They are different from the vectors, commonly used in Physics when describing directional forces, which are symbolised with an arrow as an ``accent'', such as $\overrightarrow{\mathbf{F}}$. In \Rlang numeric values and other atomic values are always \Rclass{vector}s that can contain zero, one or more elements. The diagram below exemplifies a vector containing ten elements, also called members. These elements can be extracted using integer numbers as positional indices, and manipulated as described in more detail in section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}.\vspace{1ex}

\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=codeshadecolor},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}},
row 1 column 1/.style={nodes={draw}}}]

\matrix[array] (array) {
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
  &   &   &   &   &   &   &   &   &   \\};
\node[draw, fill=gray, minimum size=4mm] at (array-2-9) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-10.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\textcolor{blue}{\ \code{<name>}\strut}};
\draw (array-1-1.north)--++(90:3mm) node [above] (first) {First index};
\draw (array-1-10.east)--++(0:3mm) node [right]{\code{integer} positional indices};
\draw (array-2-10.east)--++(0:3mm) node [right]{Elements or \textcolor{blue}{\code{<values>}}};
\node [align=center, anchor=south] at (array-2-9.north west|-first.south) (8) {element at index 9};
\draw (8)--(box);
%
\end{tikzpicture}
\end{footnotesize}
\end{center}

Vectors, in mathematical notation, are similarly represented using positional indexes as subscripts,
\begin{equation}\label{eq:vector}
  a_{1\ldots n} = a_1, a_2, \cdots a_i, \cdots, a_n,
\end{equation}
where $a_{1\ldots n}$ is the whole vector and $a_1$ its first member. The length of $a_{1\ldots n}$ is $n$ as it contains $n$ members. In the diagram above $n = 10$.

As you have seen above, the results of calculations were printed preceded with \code{[1]}. This is the index or position in the vector of the first number (or other value) displayed at the head of the current line. As in \Rlang single values are vectors of length one, when they are printed, they are also preceded with \code{[1]}.\label{par:print:vec:index}

One\label{par:calc:concatenate} can use function \Rfunction{c()} ``concatenate'' to create a vector from other vectors, including vectors of length 1, or even vectors of length 0, such as the \code{numeric} constants in the statements below. The first example shows an anonymous vector created, printed, and then automatically discarded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

To be able to reuse the vector, we assign it to a variable, giving a name to it. The length of a vector can be queried with function \Rfunction{length()}. Below, \Rlang code is followed by diagrams depicting the structure of the vectors created.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct4} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)}
\hlkwd{length}\hlstd{(vct4)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlstd{vct4}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

%\begin{center}
\noindent
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=blue!20},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}}]

\matrix[array] (array) {
1 & 2 & 3 \\
3  & 1  & 2 \\};
%\node[draw, fill=gray, minimum size=4mm] at (array-2-9) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-3.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\strut\code{\ vct4\phantom{mm}}};
\draw (array-1-3.east)--++(0:3mm) node [right]{\code{integer} positional indices};
\draw (array-2-3.east)--++(0:3mm) node [right]{\code{numeric} values};
%
\end{tikzpicture}
\end{footnotesize}
%\end{center}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct5} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{0}\hlstd{)}
\hlstd{vct5}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
%\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=blue!20},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}}]

\matrix[array] (array) {
1 & 2 & 3 \\
4  & 5  & 0 \\};
%\node[draw, fill=gray, minimum size=4mm] at (array-2-9) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-3.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\strut\code{\ vct5\phantom{mm}}};
\draw (array-1-3.east)--++(0:3mm) node [right]{\code{integer} positional indices};
\draw (array-2-3.east)--++(0:3mm) node [right]{\code{numeric} values};
%
\end{tikzpicture}
\end{footnotesize}
%\end{center}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct6} \hlkwb{<-} \hlkwd{c}\hlstd{(vct4, vct5)}
\hlstd{vct6}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2 4 5 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
%\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=blue!20},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}}]

\matrix[array] (array) {
1 & 2 & 3 & 4 & 5 & 6\\
3 & 1 & 2 & 4  & 5  & 0 \\};
%\node[draw, fill=gray, minimum size=4mm] at (array-2-9) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-6.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\strut\code{\ vct6\phantom{mm}}};
\draw (array-1-6.east)--++(0:3mm) node [right]{\code{integer} positional indices};
\draw (array-2-6.east)--++(0:3mm) node [right]{\code{numeric} values};
%
\end{tikzpicture}
\end{footnotesize}
%\end{center}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct7} \hlkwb{<-} \hlkwd{c}\hlstd{(vct5, vct4)}
\hlstd{vct7}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0 3 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
%\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=blue!20},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}}]

\matrix[array] (array) {
1 & 2 & 3 & 4 & 5 & 6\\
4 & 5 & 0 & 3 & 1 & 2\\};
%\node[draw, fill=gray, minimum size=4mm] at (array-2-9) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-6.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\strut\code{\ vct7\phantom{mm}}};
\draw (array-1-6.east)--++(0:3mm) node [right]{\code{integer} positional indices};
\draw (array-2-6.east)--++(0:3mm) node [right]{\code{numeric} values};
%
\end{tikzpicture}
\end{footnotesize}
%\end{center}

One or more member values of a vector can be extracted using the positional indexes and the extraction operator \Roperator{[ ]}. The returned value is a new vector. Member extraction is discussed in detail in section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct7[}\hlnum{3}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{vct7[}\hlkwd{c}\hlstd{(}\hlnum{6}\hlstd{,} \hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] 2 5
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{faqbox}{How to create an empty vector?}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{numeric}\hlstd{()}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

Next, I show concatenation of two vectors of the same class, the second of them of length zero.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(vct7,} \hlkwd{numeric}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] 4 5 0 3 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \code{c()} accepts as arguments two or more vectors and concatenates them, one after another. Quite frequently we may need to insert one vector in the middle of another. For this operation, \code{c()} is not useful by itself. One could use indexing combined with \code{c()}, but this is not needed as \Rlang provides a function capable of directly doing this operation. Although it can be used to ``insert'' values, it is named \code{append()}, and by default, it indeed appends one vector at the end of another.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{append}\hlstd{(vct4, vct5)}
\end{alltt}
\begin{verbatim}
## [1] 3 1 2 4 5 0
\end{verbatim}
\end{kframe}
\end{knitrout}

The output above is the same as for \code{c(a, b)}, however, \Rfunction{append()} accepts as an argument an index position after which to ``append'' its second argument. This results in an \emph{insert} operation when the index points at any position different from the end of the vector.\label{par:calc:append:end}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{append}\hlstd{(vct4,} \hlkwc{values} \hlstd{= vct5,} \hlkwc{after} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3 1 4 5 0 2
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}\label{pg:seq:rep}
One can create sequences\index{sequence} using function \Rfunction{seq()} or the operator \Roperator{:}, or repeat values using function \Rfunction{rep()}. In this case, I leave it to the reader to work out the rules by running these and his/her own examples, with the help of the documentation, available through \code{help(seq)} and \code{help(rep)}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlopt{-}\hlnum{1}\hlopt{:}\hlnum{5}
\hlnum{5}\hlopt{:-}\hlnum{1}
\hlkwd{seq}\hlstd{(}\hlkwc{from} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{to} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{by} \hlstd{=} \hlnum{0.1}\hlstd{)}
\hlkwd{rep}\hlstd{(}\hlopt{-}\hlnum{5}\hlstd{,} \hlkwc{times} \hlstd{=} \hlnum{4}\hlstd{)}
\hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlkwc{length.out} \hlstd{=} \hlnum{4}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{faqbox}{How to create a vector of zeros?}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{numeric}\hlstd{(}\hlkwc{length} \hlstd{=} \hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 0 0 0 0 0 0 0 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

or

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{rep}\hlstd{(}\hlnum{0}\hlstd{,} \hlkwc{times} \hlstd{=} \hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 0 0 0 0 0 0 0 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

Next,\label{par:calc:vectorised:opers} something that makes \Rlang different from most other programming languages: vectorised arithmetic\index{vectorised arithmetic}. Operators and functions that are vectorised accept, as arguments, vectors of arbitrary length, in which case the result returned is equivalent to having applied the same function or operator individually to each element of the vector.\label{par:vectorised:numeric}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{log10}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{log10}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{100}\hlstd{,} \hlnum{200}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 1.00000 0.69897 2.00000 2.30103
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{sum()} accepts vectors of different lengths as input but is not vectorised, as it always returns a vector of length one as result.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sum}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 100
\end{verbatim}
\begin{alltt}
\hlkwd{sum}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{100}\hlstd{,} \hlnum{200}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 315
\end{verbatim}
\end{kframe}
\end{knitrout}

A vectorised sum, also called a parallel sum of  vectors, to differentiate it from obtaining the sum of the members of a vector, as computed above with function \Rfunction{sum()}, is the usual way in which operators like \Roperator{+} and other arithmetic operators and functions work in \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{+} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{31}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  4  3 33
\end{verbatim}
\end{kframe}
\end{knitrout}

Vectorised\index{recycling of arguments}\index{recycling of operands} functions and operators that operate on more than one vector simultaneously, in many cases accept vectors of mismatched length as arguments or operands. When two or more vectors are of different length, these functions and operators recycle the shorter vector(s) to match the length of the longest one. The two statements below are equivalent; in the first statement, the short vector \code{1} is first recycled into \code{c(1, 1, 1)}. The operation, addition in this example, is applied to the numbers stored at the same position in the two vectors, returning a new vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] 4 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{+} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 4 2 3
\end{verbatim}
\end{kframe}
\end{knitrout}

In the second code statement (line) below, \code{vct4} is of length 3, but the \code{numeric} constant 2 is a vector of length 1, this short constant vector is extended, by recycling (replicating) its value, into a longer vector of ones---i.e., a vector of the same length as the longest vector in the statement, \code{a}.\label{par:recycling:numeric}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct4} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)}
\hlstd{(vct4} \hlopt{+} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 8 4 6
\end{verbatim}
\begin{alltt}
\hlstd{vct4} \hlopt{*} \hlnum{0}\hlopt{:}\hlnum{1}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in vct4 * 0:1: longer object length is not a multiple of shorter object length}}\begin{verbatim}
## [1] 0 1 0
\end{verbatim}
\begin{alltt}
\hlstd{vct4} \hlopt{-} \hlstd{vct4}
\end{alltt}
\begin{verbatim}
## [1] 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

Make sure you understand what calculations are taking place in the chunk above, and also the one below. Vectorisation and vector recycling are key features of the \Rlang language.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct8} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{)}
\hlstd{vct8}
\end{alltt}
\begin{verbatim}
## [1] 1 1 1 1 1 1
\end{verbatim}
\begin{alltt}
\hlstd{vct8} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 2 3 2 3 2 3
\end{verbatim}
\begin{alltt}
\hlstd{vct8} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{3}
\end{alltt}
\begin{verbatim}
## [1] 2 3 4 2 3 4
\end{verbatim}
\begin{alltt}
\hlstd{vct8} \hlopt{+} \hlnum{1}\hlopt{:}\hlnum{4}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in vct8 + 1:4: longer object length is not a multiple of shorter object length}}\begin{verbatim}
## [1] 2 3 4 5 2 3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  Create further variants of the statements in the code chunk above to work out when warnings or errors are issued. Does the length of the operands matter?
\end{playground}

\begin{warningbox}
  Most functions defined in base \Rlang apply recycling to vectors passed as arguments to at least some of their parameters. When recycling is supported, the conditions triggering warnings or errors are consistent with those you discovered in the playground above. However, if and how recycling is applied depends on how functions have been defined. Thus, there is variation, especially, but not only, in the case of functions and operators defined in contributed extension packages. For example, package \pkgname{tibble} and some other packages in the \pkgname{tidyverse} support recycling but some boundary cases that trigger a warning in base \Rlang functions, trigger an error in functions defined in these packages. See section \ref{sec:data:tibble} on page \pageref{sec:data:tibble} about package \pkgname{tibble}.
\end{warningbox}

\begin{explainbox}
As mentioned above, a vector can contain zero or more member values. Vectors of length zero may seem at first sight quite useless, but in practice they are very useful. They allow the handling of ``no input'' or ``nothing to do'' cases as normal cases, which in the absence of vectors of length zero would require to be treated as special cases. Constructors for \Rlang classes like \Rfunction{numeric()} return vectors of a length given by their first argument, which defaults to zero.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct9} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwc{length} \hlstd{=} \hlnum{0}\hlstd{)} \hlcom{# named argument}
\hlstd{vct9}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(vct8)}
\end{alltt}
\begin{verbatim}
## [1] 6
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{numeric}\hlstd{()} \hlcom{# default argument}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\end{kframe}
\end{knitrout}

Vectors of length zero, behave in most cases, as expected---e.g., they can be concatenated as shown here.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{c}\hlstd{(vct4, vct9, vct5))}
\end{alltt}
\begin{verbatim}
## [1] 6
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{c}\hlstd{(vct4, vct5))}
\end{alltt}
\begin{verbatim}
## [1] 6
\end{verbatim}
\end{kframe}
\end{knitrout}

Many functions, such as \Rlang's maths functions and operators, will accept numeric vectors of length zero as valid input, returning also a vector of length zero, issuing neither a warning nor an error message. In other words, \emph{these are valid operations} in \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{log}\hlstd{(}\hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{))}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\begin{alltt}
\hlnum{5} \hlopt{+} \hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## numeric(0)
\end{verbatim}
\end{kframe}
\end{knitrout}

Even when of length zero, vectors do have to belong to a class acceptable for the operation: \code{5 + character(0)} is an error (\code{character} values are described in section \ref{sec:calc:character} on page \pageref{sec:calc:character}).

Passing as an argument to parameter \code{length} a value larger than zero creates a longer vector filled with zeros in the case of \Rfunction{numeric()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{numeric}\hlstd{(}\hlkwc{length} \hlstd{=} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0 0 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

The length of a vector can be explicitly increased, with missing values filled automatically with \code{NA}, the marker for not available.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct10} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{5}
\hlkwd{length}\hlstd{(vct10)} \hlkwb{<-} \hlnum{10}
\hlstd{vct10}
\end{alltt}
\begin{verbatim}
##  [1]  1  2  3  4  5 NA NA NA NA NA
\end{verbatim}
\end{kframe}
\end{knitrout}

If the length is decreased, the values in the \emph{tail} of the vector are discarded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct11} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct11}
\end{alltt}
\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(vct11)} \hlkwb{<-} \hlnum{5}
\hlstd{vct11}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}
\label{par:numeric:vectors:end}\index{vectors!introduction|)}

There\index{special values!NA} are some special values available for numbers. \Rconst{NA} meaning ``not available'' is used for missing values. (\Rconst{NA}) values play a very important role in the analysis of data, as frequently some observations are missing from an otherwise complete data set due to ``accidents'' during the course of an experiment or survey. It is important to understand how to interpret \Rconst{NA} values: They are placeholders for something that is unavailable, in other words, whose value is \emph{unknown}. \Rconst{NA} values propagate when used, so that numerical computations yield \Rconst{NA} when one or more input of the values is unknown.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct12} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{5}\hlstd{)}
\hlstd{vct12}
\end{alltt}
\begin{verbatim}
## [1] NA  5
\end{verbatim}
\begin{alltt}
\hlstd{vct12} \hlopt{+} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] NA  6
\end{verbatim}
\end{kframe}
\end{knitrout}

Calculations\index{special values!NaN}\label{par:special:values} can also yield the following values \Rconst{NaN} ``not a number'', \Rconst{Inf} and \Rconst{-Inf} for $\infty$ and $-\infty$. As you will see below, calculations yielding these values do \textbf{not} trigger errors or warnings, as they are arithmetically valid. \Rconst{Inf} and \Rconst{-Inf} are also valid numerical values for input and constants.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct12} \hlopt{+} \hlnum{Inf}
\end{alltt}
\begin{verbatim}
## [1]  NA Inf
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{/} \hlstd{vct12}
\end{alltt}
\begin{verbatim}
## [1]  NA Inf
\end{verbatim}
\begin{alltt}
\hlopt{-}\hlnum{1} \hlopt{/} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] -Inf
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{/} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{/} \hlnum{Inf}
\end{alltt}
\begin{verbatim}
## [1] NaN
\end{verbatim}
\begin{alltt}
\hlnum{Inf} \hlopt{+} \hlnum{4}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\begin{alltt}
\hlopt{-}\hlnum{Inf} \hlopt{* -}\hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
\textbf{When to use vectors of length zero, and when \code{NA}s?}\index{zero length objects}\index{vectors!zero length} Make sure you understand the logic behind the different behaviour of functions and operators with respect to \code{NA} and \code{numeric()} or its equivalent \code{numeric(0)}. What do they represent? Why \Rconst{NA}s are not ignored, while vectors of length zero are?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{123} \hlopt{+} \hlkwd{numeric}\hlstd{()}
\hlnum{123} \hlopt{+} \hlnum{NA}
\end{alltt}
\end{kframe}
\end{knitrout}

\emph{Model answer:}
\Rconst{NA} values are used to signal a value that ``was lost'' or ``was expected'' but is unavailable because of some accident. A vector of length zero, represents no values, but within the normal expectations. In particular, if vectors are expected to have a certain length, or if index positions along a vector are meaningful, then using \Rconst{NA} is a must.

\end{playground}

Any operation, even tests of equality, involving one or more \Rconst{NA}'s return an \Rconst{NA}. In other words, when one input to a calculation is unknown, the result of the calculation is unknown. This means that a special function is needed for testing for the presence of \code{NA} values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.na}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

In the example above, we can also see that \Rfunction{is.na()} is vectorised, and that it applies the test to each of the elements of the vector individually, returning the result as \code{TRUE} or \code{FALSE}.

One\index{precision!math operations}\index{numbers!floating point} needs to be aware of the consequences of numbers in computers being almost always stored with finite precision and/or range: the expectations derived from the mathematical definition of Real numbers are not always fulfilled. See the box on page \pageref{box:floats} for an in-depth explanation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{-} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

When using \Rclass{integer}\index{numbers!whole}\index{numbers!integer} values these problems do not exist, as integer arithmetic is not affected by loss of precision in calculations restricted to integers. Because of the way integers are stored in the memory of computers, within the representable range, they are stored exactly. One can think of computer integers as a subset of whole numbers restricted to a certain range of values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1L} \hlopt{+} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{*} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

Using the ``usual'' division operator yields a floating-point \code{double} result, while the integer division operator \Roperator{\%/\%} yields an \code{integer} result, and the modulo operator \Roperator{\%\%} returns the remainder from the integer division.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1L} \hlopt{/} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 0.3333333
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{%/%} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlnum{1L} \hlopt{%%} \hlnum{3L}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

If an operation would create an \code{integer} value that falls outside the range representable in \Rlang, the value returned is \code{NA} (not available).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1000000L} \hlopt{*} \hlnum{1000000L}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in 1000000L * 1000000L: NAs produced by integer overflow}}\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Both doubles and integers are considered numeric. In most situations, conversion is automatic and we do not need to worry about the differences between these two types of numeric values. The functions in the next chunk return \code{TRUE} or \code{FALSE}, i.e., \code{logical} values (see section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean}).\index{numbers!double}\index{numbers!integer}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(}\hlnum{1L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.integer}\hlstd{(}\hlnum{1L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.double}\hlstd{(}\hlnum{1L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.double}\hlstd{(}\hlnum{1L} \hlopt{/} \hlnum{3L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(}\hlnum{1L} \hlopt{/} \hlnum{3L}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Study the variations of the previous example shown below, and explain why the two statements return different values. Hint: 1 is a \code{double} constant. You can use \code{is.integer()} and \code{is.double()} in your explorations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{*} \hlnum{1000000L} \hlopt{*} \hlnum{1000000L}
\hlnum{1000000L} \hlopt{*} \hlnum{1000000L} \hlopt{*} \hlnum{1}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

\begin{explainbox}
\label{box:floats} \label{par:float}
\index{integer numbers!arithmetic|(}\index{double precision numbers!arithmetic|(}
\index{floating point numbers!arithmetic|(}\index{machine arithmetic!precision|(}
\index{floats|see{floating point numbers}}\index{machine arithmetic!rounding errors}\index{Real numbers and computers}\index{integer numbers and computers}
\index{EPS ($\epsilon$)|see{machine arithmetic precision}}%
The usual way to store numerical values in computers is to reserve a fixed amount of space in memory for each value, which imposes limits on which numbers can be represented or not, and the maximum precision that can be achieved. The difference between \Rclass{integer} and \Rclass{double} is explained on page \pageref{box:integer:float}. Integers, or ``whole numbers'', like \Rlang \Rclass{integer} values are stored always with the same resolution such that the smallest difference between two integer values is 1. The amount of memory available to store an individual value creates a limit for the size of the largest and smallest values that can be represented. Thus integers in \Rlang behave like Integers or whole numbers as defined in mathematics, but constrained to a restricted finite range of values. In the computing language \Clang, different types of integer numbers are available \code{short} and \code{long}, these differ in the size of the space reserved for them in memory. \Rlang \Rclass{integer} type is equivalent to \code{long} in \Clang, thus the use of \code{L} for integer constant values like \code{5L}.

Floating point numbers like \Rlang \Rclass{double} values are stored in two parts: an integer \emph{significand} and an integer \emph{exponent}, each part using a fixed amount of space in memory. The relative resolution is constrained by the number of digits that can be stored in the significand while the absolute size of the largest and smallest numbers that can be represented is limited by the largest and smallest values that fit in the memory reserved for the exponent. In many computing languages, different types of floating point numbers are available, these differ in the size of the space reserved for them in memory. The properties of Real numbers as defined in mathematics differ from floating point numbers in assuming unlimited resolution and an unlimited range of representable values.

In \Rpgrm, numbers that are not integers are stored as \emph{double-precision floats}. Precision of numerical values in computers is usually symbolised by ``epsilon'' ($\epsilon$), commonly abbreviated \emph{eps}, defined as the largest value of $\epsilon$ for which $1 + \epsilon = 1$. The finite resolution of floats can lead to unexpected results when testing for equality or inequality. Test for equality is done with operator \code{==}. The use of this and other comparison operators is explained in section \ref{sec:calc:comparison} on page \pageref{sec:calc:comparison}.


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1e20} \hlopt{==} \hlnum{1} \hlopt{+} \hlnum{1e20}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{==} \hlnum{1} \hlopt{+} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{0} \hlopt{==} \hlnum{1e-20}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Another way of revealing the limited precision is during conversion to \code{character}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{format}\hlstd{(}\hlnum{5.123}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{16}\hlstd{)} \hlcom{# near maximun resolution}
\end{alltt}
\begin{verbatim}
## [1] "5.123"
\end{verbatim}
\begin{alltt}
\hlkwd{format}\hlstd{(}\hlnum{5.123}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{22}\hlstd{)} \hlcom{# more digits than in resolution}
\end{alltt}
\begin{verbatim}
## [1] "5.123000000000000220268"
\end{verbatim}
\end{kframe}
\end{knitrout}

The accumulation of successive small losses of precision from multiple operations on \Rlang \code{double} values can be a problem. Thus when computations involve both very large and very small numbers, the returned value can depend on the order of the operations. In practice ordinary users rarely need to be concerned about losses in precision except when testing for equality and inequality. On the other hand, finite resolution of \code{double} numerical values can explain why sometimes returned values for equivalent computations differ, and why some computation algorithms may be preferable, and others even fail, in specific cases.

As the \Rpgrm program can be used on different types of computer hardware, the actual machine limits for storing numbers in memory may vary depending on the type of processor and even the compiler used to build the \Rpgrm program executable. However, it is possible to obtain these values at run time, i.e., while the \Rpgrm is being used, from the variable \code{.Machine}, which is part of the \Rlang language. Please see the help page for \code{.Machine} for a detailed and up-to-date description of the available constants. \emph{Beware that when you run the examples below, the values returned by \Rlang in your own computer can differ from those returned in the computer I have used to typeset the book as you are reading it here.}\qRconst{.Machine\$double.eps}\qRconst{.Machine\$double.neg.eps}\qRconst{.Machine\$double.max}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.eps}
\end{alltt}
\begin{verbatim}
## [1] 2.220446e-16
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.neg.eps}
\end{alltt}
\begin{verbatim}
## [1] 1.110223e-16
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.max}
\end{alltt}
\begin{verbatim}
## [1] 1024
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.min}
\end{alltt}
\begin{verbatim}
## [1] -1022
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.base}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}

The last two values refer to the exponents of a base number or \emph{radix}, 2, rather than the maximum and minimum size of numbers that can be handled as objects of class \Rclass{double}. The maximum size of normalised \code{double} values, given by \code{.Machine\$double.xmax}, is much larger than the maximum value of \code{integer} values, given by \code{.Machine\$integer.max}.\qRconst{.Machine\$double.min}\qRconst{.Machine\$double.xmax}\qRconst{.Machine\$integer.max}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{double.xmax}
\end{alltt}
\begin{verbatim}
## [1] 1.797693e+308
\end{verbatim}
\begin{alltt}
\hlstd{.Machine}\hlopt{$}\hlstd{integer.max}
\end{alltt}
\begin{verbatim}
## [1] 2147483647
\end{verbatim}
\end{kframe}
\end{knitrout}

As \Rclass{integer} values are stored in machine memory without loss of precision, epsilon is not defined for \Rclass{integer} values.
In \Rlang not all out-of-range \code{numeric} values behave in the same way: while off-range \code{double} values are stored as \Rconst{-Inf} or \Rconst{Inf} and enter arithmetic as infinite values according to the mathematical rules, off-range \code{integer} values become \code{NA} with a warning.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1e1026}
\end{alltt}
\begin{verbatim}
## [1] Inf
\end{verbatim}
\begin{alltt}
\hlnum{1e-1026}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{2147483699L}
\end{alltt}
\begin{verbatim}
## [1] 2147483699
\end{verbatim}
\end{kframe}
\end{knitrout}

In those statements in the chunk below where at least one operand is \Rclass{double} the \Rclass{integer} operands are \emph{promoted} to \Rclass{double} before computation. A similar promotion does not take place when operations are among \Rclass{integer} values, resulting in \emph{overflow}\index{arithmetic overflow}\index{overflow|see{arithmetic overflow}}, meaning numbers that are too big to be represented as \Rclass{integer} values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{2147483600L} \hlopt{+} \hlnum{99L}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in 2147483600L + 99L: NAs produced by integer overflow}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{2147483600L} \hlopt{+} \hlnum{99}
\end{alltt}
\begin{verbatim}
## [1] 2147483699
\end{verbatim}
\begin{alltt}
\hlnum{2147483600L} \hlopt{*} \hlnum{2147483600L}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in 2147483600L * 2147483600L: NAs produced by integer overflow}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{2147483600L} \hlopt{*} \hlnum{2147483600}
\end{alltt}
\begin{verbatim}
## [1] 4.611686e+18
\end{verbatim}
\end{kframe}
\end{knitrout}

The exponentiation operator \Roperator{\^{}} forces the promotion\index{type promotion}\index{arithmetic overflow!type promotion} of its arguments to \Rclass{double}, resulting in no overflow. In contrast, as seen above, the multiplication operator \Roperator{*} operates on \code{integer} values resulting in overflow.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{2147483600L} \hlopt{*} \hlnum{2147483600L}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning in 2147483600L * 2147483600L: NAs produced by integer overflow}}\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{2147483600L}\hlopt{^}\hlnum{2L}
\end{alltt}
\begin{verbatim}
## [1] 4.611686e+18
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{integer numbers!arithmetic|)}\index{double precision numbers!arithmetic|)}
\index{floating point numbers!arithmetic|)}\index{machine arithmetic!precision|)}
\end{explainbox}

Both\label{par:calc:round} for display or as part of computations, we may want to decrease the number of significant digits or the number of digits after the decimal marker. Be aware that in the examples below, even if printing is being done by default, these functions return \code{numeric} values that are different from their input and can be stored and used in computations. Function \Rfunction{round()} is used to round numbers to a certain number of decimal places after or before the decimal marker, with a positive or negative value for \code{digits}, respectively. In contrast, function \Rfunction{signif()} rounds to the requested number of significant digits, i.e., ignoring the position of the decimal marker.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.012
\end{verbatim}
\begin{alltt}
\hlkwd{signif}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.0125
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1790
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1789.123
\end{verbatim}
\begin{alltt}
\hlkwd{signif}\hlstd{(}\hlnum{1789.1234}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1790
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct13} \hlkwb{<-} \hlnum{0.12345}
\hlstd{vct14} \hlkwb{<-} \hlkwd{round}\hlstd{(vct13,} \hlkwc{digits} \hlstd{=} \hlnum{2}\hlstd{)}
\hlstd{vct13} \hlopt{==} \hlstd{vct14}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstd{vct13} \hlopt{-} \hlstd{vct14}
\end{alltt}
\begin{verbatim}
## [1] 0.00345
\end{verbatim}
\begin{alltt}
\hlstd{vct14}
\end{alltt}
\begin{verbatim}
## [1] 0.12
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Functions are described in detail in section \ref{sec:script:functions} on page \pageref{sec:script:functions}. Here I describe them briefly in relation to their use. Functions are objects containing \Rlang code that can be used to perform an operation on values passed as arguments to its parameters. They return the result of the operation as a single \Rlang object, or less frequently, as a side effect. Functions have a name like any other \Rlang object. If the name of a function is followed by parentheses \code{()} and included in a code statement, it becomes a function \emph{call} or a ``request'' for the code stored in the function object to be run. Many functions, accept \Rlang objects and/or constant values as \emph{arguments} to their \emph{formal parameters}. Formal parameters are placeholder names in the code stored in the function object, or the \emph{definition} of the function. In a function call, the code in its definition is evaluated (or run) with formal parameter names taking the values passed as arguments to them.

In a function definition, formal parameters can be assigned default values, which are used if no explicit argument is passed in the call. Arguments can be passed to formal parameters by name or by position. In most cases, passing arguments by name makes the code easier to understand and more robust against coding mistakes. In the examples presented in the book, I most frequently pass arguments by name, except for the first parameter.

Being \code{digits}, the second parameter, its argument can also be passed by position.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.012
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.012
\end{verbatim}
\end{kframe}
\end{knitrout}

When passing arguments by name, in most cases unambiguous partial matching is acceptable, but can make code difficult to read.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlnum{0.0124567}\hlstd{,} \hlkwc{di} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.012
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

Functions \Rfunction{trunc()} and \Rfunction{ceiling()} return the non-fractional part of a numeric value as a new numeric value. They differ in how they handle negative values, and neither of them rounds the returned value to the nearest whole number. Hint: you can use \code{help(trunc)} or \code{trunc?} at the \Rpgrm console, or the help tab of \RStudio to find out the answer.

\begin{playground}
What does value truncation mean? Function \Rfunction{trunc()} truncates a numeric value, but it does not return an \code{integer}.
\begin{itemize}
  \item Explore how \Rfunction{trunc()} and \Rfunction{ceiling()} differ. Test them both with positive and negative values.
  \item \textbf{Advanced} Use function \Rfunction{abs()} and operators \Roperator{+} and \Roperator{-} to reproduce the output of \Rfunction{trunc()} and \Rfunction{ceiling()} for the different inputs.
  \item Can \Rfunction{trunc()} and \Rfunction{ceiling()} be considered type conversion functions in \Rlang?
\end{itemize}
\end{playground}

\begin{explainbox}
  \Rlang supports complex numbers and arithmetic operations with class \Rclass{complex}. As complex numbers rarely appear in user-written scripts, I give only one example of their use. Complex numbers, as defined in mathematics, have two parts, a real component and an imaginary one. Complex numbers can be used, for example, to describe the result of $\sqrt{-1} = 1i$.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cmp1} \hlkwb{<-} \hlkwd{complex}\hlstd{(}\hlkwc{real} \hlstd{=} \hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{),} \hlkwc{imaginary} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0}\hlstd{))}
\hlstd{cmp1}
\end{alltt}
\begin{verbatim}
## [1] -1+0i  1+0i
\end{verbatim}
\begin{alltt}
\hlstd{cmp2} \hlkwb{<-} \hlkwd{sqrt}\hlstd{(cmp1)}
\hlstd{cmp2}
\end{alltt}
\begin{verbatim}
## [1] 0+1i 1+0i
\end{verbatim}
\begin{alltt}
\hlstd{cmp2}\hlopt{^}\hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] -1+0i  1+0i
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\index{classes and modes!numeric, integer, double|)}\index{numbers and their arithmetic|)}

\begin{warningbox}
  Instants in time and periods of time in computers are usually encoded as classes derived from \code{integer}, and thus considered in \Rlang as atomic classes and the objects vectors. Some of these encodings are standardised and supported by \Rlang classes \Rclass{POSIXlt} and \Rclass{POSIXct}. The computations based on times and dates are difficult because the relationship between local time at a given location and Universal Time Coordinates (UTC) has changed with time, as well as with changes in national borders. Packages \pkgname{lubridate} and \pkgname{anytime} support operations among time-related data and conversions between character strings and time and date classes, making them easier and less error prone than when using base \Rlang functions. Thus I describe classes and operations related to dates and times in section \ref{sec:data:datetime} on page \pageref{sec:data:datetime}.
\end{warningbox}

It\index{removing objects}\index{deleting objects|see {removing objects}}\label{par:clac:remove}\label{par:calc:remove} is good to \emph{remove} from the workspace objects that are no longer needed. We use function \Rfunction{remove()} to delete objects stored in the current workspace.

Arguments passed to \Rfunction{remove()} can be bare object names as shown here.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{an.object} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{4}
\hlkwd{remove}\hlstd{(an.object)} \hlcom{# using a bare name}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{remove()} also accepts the names of the objects to remove as a \code{character} vector passed to its parameter \code{list}. In spite of its name, the argument must be a \code{vector} rather than a \code{list} (see section \ref{sec:calc:character} on \code{character} and section \ref{sec:calc:lists} on \code{list} on pages \pageref{sec:calc:character} and \pageref{sec:calc:lists}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{an.object} \hlkwb{<-} \hlnum{5}\hlopt{:}\hlnum{2}
\hlkwd{remove}\hlstd{(}\hlkwc{list} \hlstd{=} \hlstr{"an.object"}\hlstd{)} \hlcom{# using a character vector}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{objects()} returns a \code{character} vector containing the names of all objects visible in the current environment, or by passing an argument to parameter \code{pattern}, only the objects with names matching it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{an.object} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{4}
\hlstd{another.object} \hlkwb{<-} \hlnum{2}
\hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"*.object"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "an.object"      "another.object"
\end{verbatim}
\begin{alltt}
\hlkwd{remove}\hlstd{(an.object)}
\hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"*.object"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "another.object"
\end{verbatim}
\end{kframe}
\end{knitrout}

In \pgrmname{RStudio}, all objects are listed in the \textbf{Environment} tab and the search box of this tab can be used to find a given object.

\begin{explainbox}
Function \Rfunction{remove()} accepts both bare names of objects as in the chunk above and \code{character} strings corresponding to object names like in \code{remove("any.object")}. However, While \Rfunction{objects()} accept patterns to be matched to object names, \Rfunction{remove()} does not. Because of this, these two functions have to be used together for removing all objects with names that match a pattern. The pattern can be given as a regular expression (see section \ref{sec:calc:regex} on page \pageref{sec:calc:regex}).

Both functions are available under short names matching those used in \osnameNI{Linux} and \osnameNI{Unix} for managing files: \Rfunction{ls()} is a synonym of \Rfunction{objects()} and \Rfunction{rm()} of \Rfunction{remove()}.

Using a simple search pattern we obtain the names of all objects with names \code{"vct1"}, \code{"vct2"}, and so on. When using a pattern to remove objects, it is good to first use \Rfunction{objects()} on its own to get a list of the objects that would be deleted by calling \Rfunction{remove()} when passing the names returned by \Rfunction{objects()} as the argument for parameter \code{list}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^vec.*"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\end{kframe}
\end{knitrout}

The code below removes all objects with names \code{"vct1"}, \code{"vct2"}, and so on. We do this at the end of the section before reusing the same names in the code examples of the next section.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{remove}\hlstd{(}\hlkwc{list} \hlstd{=} \hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^vct[[:digit:]]?"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Similar code chunks are included at the end of each section throughout the book to ensure that code examples are self-contained by section. The chunk about is shown above as an example, but kept hidden in later sections.
\end{explainbox}

\section{Character Values}\label{sec:calc:character}
\index{character strings}\index{classes and modes!character|(}\qRclass{character}
In spite of the name \code{character}, values of this mode, are vectors of \emph{character strings"}. Character constants are written by enclosing characters strings in quotation marks, i.e., \code{"this is a character string"}. There are three types of quotation marks in the ASCII character set, double quotes \code{"}, single quotes \code{'}, and back ticks \code{`}. The first two types of quotes can be used as delimiters of \code{character} constants.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlstr{"A"}
\hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlstr{'A'}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{vct1} \hlopt{==} \hlstd{vct2} \hlcom{# two variables holding character values, or named objects}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstr{"A"} \hlopt{==} \hlstr{'A'} \hlcom{# two constant character values, or anonymous objects}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
In many computer languages, vectors of characters are distinct from vectors of character strings. In these languages, character vectors store at each index position a single character, while vectors of character strings store at each index position strings of characters of various lengths, such as words or sentences. If you are familiar with \Clang or \Cpplang, you need to keep in mind that \Clang's \code{char} and \Rlang's \code{character} are not equivalent and that in \Rlang. In contrast to these other languages, in \Rlang there is no predefined class for vectors of individual characters and character constants enclosed in double or single quotes are not different.
\end{explainbox}

Concatenating character vectors of length one does not yield a longer character string, it yields instead a longer vector of character strings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct3} \hlkwb{<-} \hlstr{'ABC'}
\hlstd{vct4} \hlkwb{<-} \hlstr{"bcdefg"}
\hlstd{vct5} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"123"}\hlstd{,} \hlstr{"xyz"}\hlstd{)}
\hlkwd{c}\hlstd{(vct3, vct4, vct5)}
\end{alltt}
\begin{verbatim}
## [1] "ABC"    "bcdefg" "123"    "xyz"
\end{verbatim}
\end{kframe}
\end{knitrout}

Having two different delimiters available makes it possible to choose the type of quotation marks used as delimiters so that other quotation marks can be easily included in a string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstr{"He said 'hello' when he came in"}
\end{alltt}
\begin{verbatim}
## [1] "He said 'hello' when he came in"
\end{verbatim}
\begin{alltt}
\hlstr{'He said "hello" when he came in'}
\end{alltt}
\begin{verbatim}
## [1] "He said \"hello\" when he came in"
\end{verbatim}
\end{kframe}
\end{knitrout}

The\index{character string delimiters} outer quotes are not part of the string, they are ``delimiters'' used to mark the boundaries. As you can see when \code{b} is printed special characters can be represented using ``escape codes''. There are several of them, and here we will show just four, new line (\verb|\n|) and tab (\verb|\t|), \verb|\"| the escape code for a quotation mark within a string and \verb|\\| the escape code for a single backslash \verb|\|. I also show the different behaviour of \Rfunction{print()} and \Rfunction{cat()}, with \Rfunction{cat()} \emph{interpreting} the escape sequences and \Rfunction{print()} displaying them as entered.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct6} \hlkwb{<-} \hlstr{"abc\textbackslash{}ndef\textbackslash{}tx\textbackslash{}"yz\textbackslash{}"\textbackslash{}\textbackslash{}\textbackslash{}tm"}
\hlkwd{print}\hlstd{(vct6)}
\end{alltt}
\begin{verbatim}
## [1] "abc\ndef\tx\"yz\"\\\tm"
\end{verbatim}
\begin{alltt}
\hlkwd{cat}\hlstd{(vct6)}
\end{alltt}
\begin{verbatim}
## abc
## def	x"yz"\	m
\end{verbatim}
\end{kframe}
\end{knitrout}

The \textit{escape codes}\index{character escape codes} are expanded only in some contexts, such as when using \Rfunction{cat()} to display text output.

%\subsection{Character operations}\label{sec:calc:character:oper}

\begin{faqbox}{How to find the length of a character string?}
  While\index{character strings!number of characters} function \code{length()} returns the number of member \code{character} strings in a vector, function \Rfunction{nchar()} returns the number of characters in each string in the vector (see below for examples).
\end{faqbox}

In the example below, function \Rfunction{nchar()} returns the number of characters in each member string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{nchar}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"abracadabra"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 11
\end{verbatim}
\begin{alltt}
\hlkwd{nchar}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{,} \hlstr{""}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 11 10  0
\end{verbatim}
\end{kframe}
\end{knitrout}

To convert a \code{character} string into upper case or lower case we use functions \Rfunction{toupper()} and \Rfunction{tolower()}, respectively.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{toupper}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"aBcD"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ABCD"
\end{verbatim}
\begin{alltt}
\hlkwd{tolower}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"aBcD"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "abcd"
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{strtrim()} trims a string to a maximum number of characters or width.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{strtrim}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"abracadabra"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{6}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "abraca"
\end{verbatim}
\begin{alltt}
\hlkwd{strtrim}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"abra"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{6}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "abra"
\end{verbatim}
\begin{alltt}
\hlkwd{strtrim}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{),} \hlnum{6}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "abraca" "workah"
\end{verbatim}
\begin{alltt}
\hlkwd{strtrim}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{6}\hlstd{,} \hlnum{3}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "abraca" "wor"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{faqbox}{How to wrap long character strings?}
  Use \Rlang function \Rfunction{strwrap()} (see below for examples).
\end{faqbox}

Function \Rfunction{strwrap()} edits a string to a maximum number of characters or width, by splitting it into a vector of shorter character strings. It can additionally insert a character string at the start or end of each of these new shorter strings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{strwrap}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"This is a long sentence used to show how line wrapping works."}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "This is a long"   "sentence used to" "show how line"    "wrapping works."
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
  Function \Rfunction{cat()} prints a character vector respecting the embedded special characters such as new line (encoded as \verb|\n|) in \code{character} strings) and without issuing any additional new lines. Study the code below and the output it generates, consult the documentation of the two functions, and modify the example code until you are confident that you understand in detail how these two functions work.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wrapped_sentence} \hlkwb{<-}
  \hlkwd{strwrap}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"This is a very long sentence used to show how line wrapping works."}\hlstd{,}
          \hlkwc{width} \hlstd{=} \hlnum{10}\hlstd{,}
          \hlkwc{prefix} \hlstd{=} \hlstr{"\textbackslash{}n"}\hlstd{)}
\hlkwd{print}\hlstd{(wrapped_sentence)}
\hlkwd{cat}\hlstd{(wrapped_sentence,} \hlstr{"\textbackslash{}n"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{advplayground}

\begin{faqbox}{How to create a single character string from multiple shorter strings?}
  While function \code{c()} is used to concatenate \code{character} vectors into longer vectors, function \Rfunction{paste()} is used to concatenate character strings into a single longer string (see below for examples).
\end{faqbox}

Pasting together \code{character} strings has many uses, e.g., assembling informative messages to be printed, programmatically creating file names or file paths, etc. If we pass numbers, they are converted to \code{character} before pasting. The default separator is a space character, but this can be changed by passing a \code{character} string as an argument for parameter \code{sep}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{paste}\hlstd{(}\hlstr{"n ="}\hlstd{,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "n = 3"
\end{verbatim}
\begin{alltt}
\hlkwd{paste}\hlstd{(}\hlstr{"n"}\hlstd{,} \hlnum{3}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{" = "}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "n = 3"
\end{verbatim}
\end{kframe}
\end{knitrout}

Pasting constants, as shown above,  is of little practical use. In contrast, combining values stored in different variables is a very frequent operation when working with data. A simple use example follows. Assuming vector \code{friends} contains the names of friends and vector \code{fruits} the fruits they like to eat we can paste these values together into short sentences.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{friends} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"John "}\hlstd{,} \hlstr{"Yan "}\hlstd{,} \hlstr{"Juana "}\hlstd{,} \hlstr{"Mary "}\hlstd{)}
\hlstd{fruits} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"apples"}\hlstd{,} \hlstr{"lichees"}\hlstd{,} \hlstr{"oranges"}\hlstd{,} \hlstr{"strawberries"}\hlstd{)}
\hlkwd{paste}\hlstd{(friends,} \hlstr{"eats "}\hlstd{, fruits,} \hlstr{"."}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "John eats apples."       "Yan eats lichees."      
## [3] "Juana eats oranges."     "Mary eats strawberries."
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
 Why was necessary to pass \code{sep = ""} in the call to \Rfunction{paste()} in the example above? First try to predict what will happen and then remove \code{, sep = ""} from the statement above and run it to learn the answer. Try your own variations of the code until you understand the role of the separator string.
\end{playground}

We can pass an additional argument to tell that the vector resulting from the paste operation is to be collapsed into a single \code{character} string. The argument passed to collapse is used as the separator. I use here \code{cat()} so that the newline character is obeyed in the display of the single character string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cat}\hlstd{(}\hlkwd{paste}\hlstd{(friends,} \hlstr{"eats "}\hlstd{, fruits,} \hlkwc{collapse} \hlstd{=} \hlstr{".\textbackslash{}n"}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{))}
\end{alltt}
\begin{verbatim}
## John eats apples.
## Yan eats lichees.
## Juana eats oranges.
## Mary eats strawberries
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
When the vectors are of different length, as in the last example above, the shorter one is recycled as many times as needed, which is not always what we want. To void the recycling, we need to first collapse the members of the long vector \code{fruits} into a vector of length one. We can achieve this by nesting two calls to \Rfunction{paste()}, and passing an argument to \code{collapse} in the inner function call.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{collapsed_fruits} \hlkwb{<-} \hlkwd{paste}\hlstd{(fruits,} \hlkwc{collapse} \hlstd{=} \hlstr{", "}\hlstd{)}
\hlkwd{paste}\hlstd{(}\hlstr{"My friends eat"}\hlstd{, collapsed_fruits,} \hlstr{"and other fruits."}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "My friends eat apples, lichees, oranges, strawberries and other fruits."
\end{verbatim}
\end{kframe}
\end{knitrout}

The nesting of function calls is explained in section \ref{sec:script:pipes} on page \pageref{sec:script:pipes}. However, as the two statements above would in most cases be written as nested function calls, I add this example for reference.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{paste}\hlstd{(}\hlstr{"My friends eat"}\hlstd{,} \hlkwd{paste}\hlstd{(fruits,} \hlkwc{collapse} \hlstd{=} \hlstr{", "}\hlstd{),} \hlstr{"and other fruits."}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "My friends eat apples, lichees, oranges, strawberries and other fruits."
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

Function \Rfunction{strrep()} repeats and pastes \code{character} strings into a new longer \code{character string}, while function \Rfunction{rep()} repeats character strings without pasting them together, returning a longer vector with each repeat of the string as a separate member.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{rep}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"ABC"}\hlstd{,} \hlkwc{times} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ABC" "ABC" "ABC"
\end{verbatim}
\begin{alltt}
\hlkwd{strrep}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"ABC"}\hlstd{,} \hlkwc{times} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ABCABCABC"
\end{verbatim}
\begin{alltt}
\hlkwd{strrep}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"ABC"}\hlstd{,} \hlkwc{times} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{4}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "ABCABC"       "ABCABCABCABC"
\end{verbatim}
\begin{alltt}
\hlkwd{strrep}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"ABC"}\hlstd{,} \hlstr{"X"}\hlstd{),} \hlkwc{times} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ABCABC" "XX"
\end{verbatim}
\begin{alltt}
\hlkwd{strrep}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"ABC"}\hlstd{,} \hlstr{"X"}\hlstd{),} \hlkwc{times} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "ABCABC" "XXXXX"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{faqbox}{How to trim leading and/or trailing whitespace in character strings?}
Use function \Rfunction{trimws()} (see below for examples).
\end{faqbox}

Trimming\index{character strings!whitespace trimming} leading and trailing whitespace is a frequent operation. \Rlang function \Rfunction{trimws()} implements this operation as shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{trimws}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{" two words "}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "two words"
\end{verbatim}
\begin{alltt}
\hlkwd{trimws}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"  eight words and a newline at the end\textbackslash{}n"}\hlstd{,} \hlstr{" two words "}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "eight words and a newline at the end"
## [2] "two words"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Function \Rfunction{trimws()} has additional parameters that make it possible to select which end of the string is trimmed and which characters are considered whitespace. Use \code{help(trimws)} to access the help and study this documentation. Modify the example above so that only trailing whitespace is removed, and so that the newline character \verb!\n! is not considered whitespace, and thus not trimmed away.
\end{playground}

Within\index{character strings!position-based operations} \Rclass{character} strings, substrings can be extracted and replaced \emph{by position} using \Rfunction{substring()} or \Rfunction{substr()}.

For extraction, we can pass to \code{x} a constant as shown below or a variable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{substr}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"abracadabra"}\hlstd{,} \hlkwc{start} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{stop} \hlstd{=} \hlnum{9}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "cadab"
\end{verbatim}
\begin{alltt}
\hlkwd{substr}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{),} \hlkwc{start} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{stop} \hlstd{=} \hlnum{11}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "cadabra" "aholic"
\end{verbatim}
\end{kframe}
\end{knitrout}

Replacement is done \emph{in place}, by having function \code{substr()} on the left-hand side (lhs) of the assignment operator \code{<-}. Thus, the argument passed to parameter \code{x} of \code{substr()} must in this case be a variable rather than a constant. This is a substitution character by character, not insertion, so the number of characters in the string passed as the argument to \code{x} remains unchanged, i.e., the value returned by \code{nchar()} does not change.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct7} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{)}
\hlkwd{substr}\hlstd{(}\hlkwc{x} \hlstd{= vct7,} \hlkwc{start} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{stop} \hlstd{=} \hlnum{9}\hlstd{)} \hlkwb{<-} \hlstr{"xxx"}
\hlstd{vct7}
\end{alltt}
\begin{verbatim}
## [1] "abraxxxabra" "workxxxlic"
\end{verbatim}
\end{kframe}
\end{knitrout}

If we pass values to both \code{start} and \code{stop} then only part of the value on the \emph{rhs} of the assignment operator \code{<-} may be used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct8} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{)}
\hlkwd{substr}\hlstd{(}\hlkwc{x} \hlstd{= vct8,} \hlkwc{start} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{stop} \hlstd{=} \hlnum{6}\hlstd{)} \hlkwb{<-} \hlstr{"xxx"}
\hlstd{vct8}
\end{alltt}
\begin{verbatim}
## [1] "abraxxdabra" "workxxolic"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Frequently, a very effective way of learning how a function behaves, is to experiment. In the example below, we set \code{start} and \code{stop} delimiting more characters than those in \code{"xxx"}. In this case, is \code{"xxx"} extended,
or \code{start} or \code{stop} ignored? Run this ``toy example'' to find out the answer.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{VCT1} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"abracadabra"}\hlstd{,} \hlstr{"workaholic"}\hlstd{)}
\hlkwd{substr}\hlstd{(}\hlkwc{x} \hlstd{= VCT1,} \hlkwc{start} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{stop} \hlstd{=} \hlnum{11}\hlstd{)} \hlkwb{<-} \hlstr{"xxx"}
\hlstd{VCT1}
\hlkwd{remove}\hlstd{(VCT1)} \hlcom{# clean up}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

As\index{character strings!partial matching and substitution} in \Rlang each character value is a string comprised of zero to many characters, in addition to comparisons based on whole strings or values, partial matches among them are of interest.

To substitute part of a \code{character} string \emph{by matching a pattern}, we can use functions \Rfunction{sub()} or \Rfunction{gsub()}. The first example uses three \code{character} constants, but values stored in variables can also be passed as arguments.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"AB"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlstr{"about"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ABout"
\end{verbatim}
\end{kframe}
\end{knitrout}

The difference between \Rfunction{sub()} (substitution) and \Rfunction{gsub()} (global substitution) is that the first replaces only the first match found while the second replaces all matches.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"x"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlstr{"abracadabra"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "xracadabra"
\end{verbatim}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"x"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlstr{"abracadabra"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "xracadxra"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Functions \Rfunction{sub()} or \Rfunction{gsub()} accept character vectors as the argument for parameter \code{x}. Run the two statements below and study how the values returned differ.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"x"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"abra"}\hlstd{,} \hlstr{"cadabra"}\hlstd{))}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"x"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"abra"}\hlstd{,} \hlstr{"cadabra"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

Function \Rfunction{grep()} returns indices to the values in a vector matching a pattern, or alternatively, the matching values themselves.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{grep}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"C"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"R"}\hlstd{,} \hlstr{"C++"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"Perl"}\hlstd{,} \hlstr{"Pascal"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{grep}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"C"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"R"}\hlstd{,} \hlstr{"C++"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"Perl"}\hlstd{,} \hlstr{"Pascal"}\hlstd{),} \hlkwc{value} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "C++" "C"
\end{verbatim}
\begin{alltt}
\hlkwd{grep}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"C"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"R"}\hlstd{,} \hlstr{"C++"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"Perl"}\hlstd{,} \hlstr{"Pascal"}\hlstd{),} \hlkwc{ignore.case} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 2 3 5
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{grepl()} is a variation of \Rfunction{grep()} that returns a vector of \code{logical} values instead of numeric indices to the matching values in \code{x}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{grepl}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"C"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"R"}\hlstd{,} \hlstr{"C++"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"Perl"}\hlstd{,} \hlstr{"Pascal"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] FALSE  TRUE  TRUE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{grepl}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"C"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"R"}\hlstd{,} \hlstr{"C++"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"Perl"}\hlstd{,} \hlstr{"Pascal"}\hlstd{),} \hlkwc{ignore.case} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE  TRUE  TRUE FALSE  TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{regular expressions|(}%
In\label{sec:calc:regex} the examples above, the arguments for \code{pattern} strings matched exactly their targets. In \Rlang and other languages, \emph{regular expressions} are used to concisely describe more elaborate and conditional patterns. Regular expressions themselves are encoded as character strings, where some characters and character sequences have special meaning. This means that when a pattern should be interpreted literally rather than specially, \code{fixed = TRUE} should be passed in the call. This, in addition, ensures faster computation. In the examples above, the patterns used contained no characters with special meaning, thus, the returned value is not affect by passing \code{fixed = TRUE} as done here.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"AB"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlstr{"about"}\hlstd{,} \hlkwc{fixed} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "ABout"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
Regular expressions are used in Unix and Linux shell scripts and programs, and are part of \perllang, \Cpplang and other languages in addition to \Rlang. This means that variations exist on the same idea, with \Rlang supporting two variations of the syntax. A description of \Rlang regular expressions can be accessed with \code{help(regex)}. We here describe \Rlang's default syntax.
\end{warningbox}

Regular expressions are concise, terse, and extremely powerful. They are a language in themselves. However, the effort needed to learn their use more than pays back. I will show examples of the use, rather than systematically describe them. I will use \Rfunction{gsub()} for these examples, but several other \Rlang functions including \Rfunction{grep()} and \Rfunction{grepl()} accept regular expressions as patterns.

In a regular expression, \code{|} separates alternative matching patterns.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"ab|t"}\hlstd{,} \hlkwc{replacement} \hlstd{=} \hlstr{"123"}\hlstd{,} \hlkwc{x} \hlstd{=} \hlstr{"about"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "123ou123"
\end{verbatim}
\end{kframe}
\end{knitrout}

Within a regular expression, we can group characters within \code{[ ]} as alternative, e.g., \code{[0123456789]}, or \code{[0-9]} matches any digit.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"a[0123456789]"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{"ab"}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a1out"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3out"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "about" "about" "about"
\end{verbatim}
\end{kframe}
\end{knitrout}

Character \code{\textasciicircum} indicates that the match must be at the ``head'' of the string, and \code{\$} that the match should be at its ``tail''.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^a[0123456789]"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{"ab"}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a1out"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{" a3out"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "about"  "about"  " a3out"
\end{verbatim}
\end{kframe}
\end{knitrout}

The replacement can be an empty string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"out$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{""}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "ab"     "a9"     "a3outx"
\end{verbatim}
\end{kframe}
\end{knitrout}

A dot (\code{.}) matches any character. In this example, we replace the last character with \code{""}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{".$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{""}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "abou"  "a9ou"  "a3out"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  How would you modify the last code example above to edit \code{c("about", "axout", "a3outx")} into \code{c("about", "axout", "a3out")}? Think of different ways of doing this using regular expressions.
\end{playground}

The number of matching characters can be indicated with \code{+} (match 1 or more times), \code{?} (match 0 or 1 times), \code{*} (match 0 or more times) or even numerically. Matching is in most cases ``greedy''.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^.[0-9][a-z]*$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{"gone"}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "about" "gone"  "gone"
\end{verbatim}
\end{kframe}
\end{knitrout}

Several named classes of characters are predefined, for example \code{[:lower:]⁠} for lower case alphabetic characters according to the current locale (see page \pageref{box:calc:locale}). In the regular expression in the example below, \code{[:lower:]⁠} replaces only \code{a-z}, thus we need to keep the outer square brackets. While \code{a-z} includes only the unaccented letters, \code{[:lower:]⁠} does include additional characters such as \texttt{ä}, \texttt{ö}, or \texttt{é} if they are in use in the current locale. In the case of \code{[:digit:]} and \code{0-9}, they are equivalent.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^.([[:digit:]])[[:lower:]]*$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{"gone with \textbackslash{}\textbackslash{}1"}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "about"       "gone with 9" "gone with 3"
\end{verbatim}
\end{kframe}
\end{knitrout}

With parentheses we can isolate part of the matched string and reuse it in the replacement with a numeric back-reference. Up to a maximum of nine pairs of parentheses can be used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^.([0-9])[a-z]*$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{"gone with \textbackslash{}\textbackslash{}1"}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "about"       "gone with 9" "gone with 3"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Run the two statements below, study the returned values by creating variations of the patterns and explain why the returned values differ.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^.+$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{""}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\hlkwd{gsub}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"^.?$"}\hlstd{,}
     \hlkwc{replacement} \hlstd{=} \hlstr{""}\hlstd{,}
     \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"about"}\hlstd{,} \hlstr{"a9out"}\hlstd{,} \hlstr{"a3outx"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

Splitting\index{character strings!splitting of} of character strings based on pattern matching is a frequently used operation, e..g., treatment labels containing information about two different treatment factors need to be split into their components before data analysis. Function \Rfunction{strsplit()} has an interface consistent with \code{grep()}. In the examples we will split strings containing date and time of day information in different ways.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{strsplit}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"2023-07-29 10:30"}\hlstd{,} \hlkwc{split} \hlstd{=} \hlstr{" "}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [[1]]
## [1] "2023-07-29" "10:30"
\end{verbatim}
\end{kframe}
\end{knitrout}

Using a simple regular expression we can extract individual strings representing the numbers.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{strsplit}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"2023-07-29 10:30"}\hlstd{,} \hlkwc{split} \hlstd{=} \hlstr{" |-|:"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [[1]]
## [1] "2023" "07"   "29"   "10"   "30"
\end{verbatim}
\end{kframe}
\end{knitrout}

The argument to \code{split} is by default interpreted as a regular expression, but as discussed above we can pass \code{fixed = TRUE} to prevent this.

\begin{warningbox}
One needs to be aware that the part of the string matched by the regular expression is not included in the returned vectors. If the regular expression matches more than what we consider a separator, the returned values may be surprising.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{strsplit}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"2023-07-29"}\hlstd{,} \hlkwc{split} \hlstd{=} \hlstr{"-[0-9]+$"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [[1]]
## [1] "2023-07"
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{warningbox}

\begin{explainbox}
When the argument passed to \code{x} is a vector with multiple member strings, the returned value is a list of \code{character} vectors. This list contains as many character vectors as members had the vector passed as argument to \code{x}, each vector the result of splitting one character string in the input. (Lists are described in section \ref{sec:calc:lists} on page \pageref{sec:calc:lists}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{strsplit}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"2023-07-29 10:30"}\hlstd{,} \hlstr{"2023-07-29 19:17"}\hlstd{),} \hlkwc{split} \hlstd{=} \hlstr{" "}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [[1]]
## [1] "2023-07-29" "10:30"     
## 
## [[2]]
## [1] "2023-07-29" "19:17"
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}
\index{regular expressions|)}
\index{classes and modes!character|)}

\begin{warningbox}\label{box:calc:locale}
  The ASCII character set is the oldest and simplest in use. In contains only 128 characters including non-printable characters. These characters support the English language. Several different extended versions with 256 characters provided support for other languages, mostly by adding accented letters and some symbols. The 128 ASCII characters were for a long time the only consistently available across computers set up for different languages and countries (or \emph{locales}). Recently the use of much larger character sets like UTF8 has become common. Since \Rlang version 4.2.0 support for UTF8 is available under Windows 10. This makes it possible the processing of text data for many more languages than in the past. Even though now it is possible to use non-ASCII characters as part of object names, it is anyway safer to use only ASCII characters as this support is recent.

  The extended character sets include additional characters, that are distinct but may produce glyphs that look very similar to those in the ASCII set. One case are em-dash (---), en-dash (--), minus sign ($-$) and regular dash (-), which are all different characters, with only the last one recognised by \Rlang as the minus operator. For those copying and pasting text from a word-processor into \Rpgrm or \RStudio, a frequent difficulty is that even if one types in an ASCII quote character (\verb|"|), the opening and closing quotes in many languages are automatically replaced with non-ASCII ones (``and''), which \Rlang does not accept as character string delimiters. The best solution is to use a plain text editor instead of a word processor when writing scripts or editing text files containing data to be read as code statements or numerical data.

  A locale definition determines not only the language, and character set, but also date, time, and currency formats.
\end{warningbox}



\section{Logical Values and Boolean Algebra}\label{sec:calc:boolean}
\index{classes and modes!logical|(}\index{logical operators}\index{logical values and their algebra|(}\index{Boolean arithmetic}
What in Mathematics are usually called Boolean values, are called \Rclass{logical} values in \Rlang. They can have only two values \code{TRUE} and \code{FALSE}, in addition to \code{NA} (not available). Logical values \code{TRUE} and \code{FALSE} should not be confused with text strings, they are names for the two conditions that can be stored. Logical values are always vectors as all other atomic types in \Rlang (by \emph{atomic} we mean that each value is not composed of ``parts'').

Logical values are rarely used to store data from experiments or surveys. They are used mostly to keep track of binary conditions, like results from comparisons in a script and to operate on them. Most frequent uses of \code{logical} values do not involve their storage in user-created variables. Most comparisons or tests return a \code{logical} value and Boolean algebra makes it possible to combine the results from multiple tests or conditions into a single combined outcome or binary decision, i.e., TRUE or False, Yes or No. (See section \ref{sec:calc:comparison} on page \pageref{sec:calc:comparison} for examples.)

In mathematics, Boolean algebra provides the rules of the logic used to combine multiple logical values. Boolean operators like AND and OR take as operands logical values and return a logical value as a result. In \Rlang there are two ``families'' of Boolean operators, vectorised and not vectorised. Vectorised operators accept logical vectors of any length as operands, while non-vectorised ones accept only logical vectors of length one as operands. In the chunk below we use non-vectorised operators with two \Rclass{logical} vectors of length one, \code{a} and \code{b}, as operands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlnum{TRUE}
\hlkwd{mode}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] "logical"
\end{verbatim}
\begin{alltt}
\hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlopt{!}\hlnum{TRUE} \hlcom{# negation}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{FALSE} \hlcom{# logical AND}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{||} \hlnum{FALSE} \hlcom{# logical OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{xor}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlcom{# exclusive OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

%%%% index operators using verb!!
The availability of two kinds of logical operators can be troublesome for those new to \Rlang. Pairs of ``equivalent'' logical operators behave differently, use similar syntax and use similar symbols! The vectorised operators have single-character names, \Roperator{\&} and \Roperator{\textbar} (like the vectorised arithmetic operators, such as \code{+}), while the non-vectorised ones have double-character names, \Roperator{\&\&} and \Roperator{\textbar\textbar}. There is only one version of the negation operator \Roperator{!} that is vectorised. In recent versions of \Rlang, an error is triggered when a non-vectorised operator is used with a vector with length $> 1$, which helps prevent mistakes. In some situations, vectorised \code{logical} operators can replace non-vectorised ones, but it is important to use the ones that match the intention of the code, as this enables relevant checks for mistakes. Once the distinction is learnt, using the most appropriate operators also contributes to make code easier to read.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)} \hlcom{# vectorised AND}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)} \hlcom{# vectorised OR}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions \Rfunction{any()} and \Rfunction{all()} take zero or more logical vectors as their arguments, and return a single logical value ``summarising'' the logical values in the vectors. Function \Rfunction{all()} returns \code{TRUE} only if all values in the vectors passed as arguments are \code{TRUE}, and \Rfunction{any()} returns \code{TRUE} unless all values in the vectors are \code{FALSE}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{)}
\hlkwd{any}\hlstd{(vct2)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(vct2)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Another important thing to know about logical operators is that they ``short-cut'' evaluation. If the result is known from the first part of the statement, the rest of the statement is not evaluated. Try to understand what happens when you enter the following commands. Short-cut evaluation is useful, as the first condition can be used as a guard protecting a later condition from being evaluated when it would trigger an error.\label{par:calc:shortcut:eval}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{TRUE} \hlopt{||} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{||} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{FALSE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{TRUE} \hlopt{&&} \hlnum{TRUE} \hlopt{&&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  Investigate how swapping the order of the operands in the code chunk above affects the values returned, e.g.., the first statement becomes \code{NA || TRUE}.
\end{playground}

When using the vectorised operators on vectors of length greater than one, `short-cut' evaluation still applies for the result obtained at each index position.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)} \hlopt{&} \hlnum{NA}
\end{alltt}
\begin{verbatim}
## [1]    NA FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)} \hlopt{&} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]    NA FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{TRUE}\hlstd{)} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Based on the description of ``recycling'' presented on page \pageref{par:recycling:numeric} for \code{numeric} operators, explore how ``recycling'' works with vectorised logical operators. Create logical vectors of different lengths (including length one) and \emph{play} by writing several code statements with operations on them. To get you started, one example is given below. Execute this example, and then create and run your own, making sure that you understand why the values returned are what they are. Sometimes, you will need to devise several examples or test cases to tease out of \Rlang an understanding of how a certain feature of the language works, so do not give up early, and make use of your imagination!

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{NA}\hlstd{)} \hlopt{&} \hlnum{FALSE}
\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{NA}\hlstd{)} \hlopt{|} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{faqbox}{How to test if a vector contains no values other than \code{NA} (or \code{NaN}) values?}
A call to \Rfunction{is.na()} returns a \code{logical} vector that we can pass to \Rfunction{all()}. We can save the intermediate vector \code{temp} and pass it as argument to \Rfunction{is.na()}, or alternatively nest the function calls. The name \code{tmp}, for \emph{temporary}, is frequently used for variables whose value is retrieved only once.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{5}\hlstd{)} \hlcom{# toy data}
\hlstd{tmp} \hlkwb{<-} \hlkwd{is.na}\hlstd{(vct2)} \hlcom{# tmp for temporary}
\hlkwd{all}\hlstd{(tmp)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{all}\hlstd{(}\hlkwd{is.na}\hlstd{(vct2))} \hlcom{# nested call}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

\begin{faqbox}{How to test if a vector contains one or more \code{NA} (or \code{NaN}) values?}
See previous question. We only need to replace \code{all()} by \Rfunction{any()} to obtain the answer.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{NA}\hlstd{,} \hlnum{5}\hlstd{)}
\hlkwd{any}\hlstd{(}\hlkwd{is.na}\hlstd{(vct2))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

\index{logical values and their algebra|)}
\index{classes and modes!logical|)}



\section{Comparison Operators and Operations}\label{sec:calc:comparison}
\index{comparison operators|(}\index{operators!comparison|(}\qRoperator{>}\qRoperator{<}\qRoperator{>=}\qRoperator{<=}\qRoperator{==}\qRoperator{!=}
Comparison operators return vectors of \code{logical} values (see section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean}), with values \code{TRUE} or \code{FALSE} depending on the outcome.

Equality (\code{==}) and inequality (\code{!=}) operators are defined not only for \code{numeric} values but also for \code{character} and most other atomic and many other values. Be aware that operator \code{=} is an infrequently used synonym of the assignment operator \code{<-} rather than a comparison operator!

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# be aware that we use two = symbols}
\hlstr{"abc"} \hlopt{==} \hlstr{"ab"}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstr{"ABC"} \hlopt{==} \hlstr{"abc"}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstr{"abc"} \hlopt{!=} \hlstr{"ab"}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstr{"ABC"} \hlopt{!=} \hlstr{"abc"}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

In the case of \code{numeric} values additional comparisons are meaningful and additional operators are defined.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1.2} \hlopt{>} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{>=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{==} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{!=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{<=} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{1.2} \hlopt{<} \hlnum{1.0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

These operators can be used on vectors of any length, returning as a result a logical vector as long as the longest operand. In other words, they behave in the same way as the arithmetic operators described on page \pageref{par:vectorised:numeric}: their arguments are recycled when needed. Hint: if you do not know what value is stored in numeric vector \code{a}, use \code{print(a)} after the first code statement below to see its contents.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct3} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct3} \hlopt{>} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlstd{vct3} \hlopt{<} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{vct3} \hlopt{==} \hlnum{5}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(vct3} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(vct3} \hlopt{>} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{vct4} \hlkwb{<-} \hlstd{vct3} \hlopt{>} \hlnum{5}
\hlstd{vct4}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(vct4)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(vct4)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Individual comparisons can be useful, but their full role in data analysis and programming is realised when we combine multiple tests using the operations of the Boolean algebra described in section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean}.

For example, to test if members of a numeric vector are within a range, in our example, $-1$ to $+1$, we can combine the results from two comparisons using the vectorised logical \emph{AND} operator \Roperator{\&}, and use parentheses to override the default order of precedence of the operations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct5} \hlkwb{<-} \hlopt{-}\hlnum{2}\hlopt{:}\hlnum{3}
\hlstd{vct5} \hlopt{>= -}\hlnum{1} \hlopt{&} \hlstd{vct5} \hlopt{<=} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

If we want to find those values outside this same range, we can negate the test.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlopt{!}\hlstd{(vct5} \hlopt{>= -}\hlnum{1} \hlopt{&} \hlstd{vct5} \hlopt{<=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Or, we can combine another two comparisons using the vectorised logical \emph{OR} operator \Roperator{\textbar}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct5} \hlopt{< -}\hlnum{1} \hlopt{|} \hlstd{vct5} \hlopt{>} \hlnum{1}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

In some cases, an additional advantage is that \Rclass{logical} values require less space in memory for their storage than \code{numeric} values.

\begin{playground}
Use the statement below as a starting point in exploring how precedence works when logical and arithmetic operators are part of the same statement. \emph{Play} with the example by adding parentheses at different positions and based on the returned values, work out the default order of operator precedence used for the evaluation of the example given below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct6} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct6} \hlopt{>} \hlnum{3} \hlopt{|} \hlstd{vct6} \hlopt{+} \hlnum{2} \hlopt{<} \hlnum{3}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

It is important to be aware of the consequences of ``short-cut evaluation'' (described on page \pageref{par:calc:shortcut:eval}).
The behaviour of many of base-\Rlang's functions when \code{NA}s are present in their input arguments can be modified. If \code{TRUE} is passed as an argument to parameter \code{na.rm}, \code{NA} values are \emph{removed} from the input \textbf{before} the function is applied.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct7} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlkwd{all}\hlstd{(vct7} \hlopt{<} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(vct7} \hlopt{>} \hlnum{20}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(vct7} \hlopt{<} \hlnum{20}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{any}\hlstd{(vct7} \hlopt{>} \hlnum{20}\hlstd{,} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
\index{comparison of floating point numbers|(}\index{inequality and equality tests|(}\index{loss of numeric precision}In many situations, when writing programs one should avoid testing for equality of floating point numbers (`floats'). This is because of how numbers are stored in computers (see the box on page \pageref{box:floats} for an in-depth explanation). Here I show how to gracefully handle rounding errors when using comparison operators. As rounding errors may accumulate, in practice \code{.Machine\$double.eps} is frequently too small a value to safely use in tests for ``zero.''. Whenever possible according to the logic of the calculations, it is best to test for inequalities, for example using \verb|x <= 1.0| instead of \verb|x == 1.0|. If this is not possible, then equality tests should be done by replacing tests like \verb|x == 1.0| with \verb|abs(x - 1.0) < k|, where \verb|k| is a number larger than \code{eps}. Function \Rfunction{abs()} returns the absolute value, in simpler words, makes all values positive or zero, by changing the sign of negative values, or in mathematical notation $|x| = |-x|$.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)} \hlopt{==} \hlnum{0} \hlcom{# angle in radians, not degrees!}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi)} \hlopt{==} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(}\hlkwd{sin}\hlstd{(pi))} \hlopt{<} \hlnum{1e-15}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(}\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi))} \hlopt{<} \hlnum{1e-15}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(pi)}
\end{alltt}
\begin{verbatim}
## [1] 1.224606e-16
\end{verbatim}
\begin{alltt}
\hlkwd{sin}\hlstd{(}\hlnum{2} \hlopt{*} \hlstd{pi)}
\end{alltt}
\begin{verbatim}
## [1] -2.449213e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{comparison of floating point numbers|)}\index{inequality and equality tests|)}
\end{warningbox}

\index{comparison operators|)}\index{operators!comparison|)}



\section{Sets and Set Operations}
\index{sets|(}\index{algebra of sets}\index{operators!set|(}

The \Rlang language supports set operations on vectors. They can be useful in many different contexts when manipulating and comparing vectors of values. In Bioinformatics, it is usual, for example, to make use of character vectors of gene tags. Algebra sets is implemented with functions \code{union()}, \code{intersect()}, \code{setdiff()}, \code{setequal()}, \code{is.element()} and operator \code{\%in\%} (Figure \ref{fig:set:opers}). The first three operations return a vector of the same mode as their inputs, and the last three a \code{logical} vector. The action of the first three operations is most easily illustrated with Venn diagrams, where the returned value (or result of the operation) is depicted in darker grey.\vspace{1ex}

\begin{figure}
\begin{footnotesize}
\hfill%
\begin{tikzpicture}[thick,
    set/.style = {circle,
        minimum size = 3cm,
        fill=black!15}]

% Set A
\node[set,label={135:$A$}] (A) at (0,0) {};

% Set B
\node[set,label={45:$B$}] (B) at (1.8,0) {};

% Intersection
\begin{scope}
    \clip (0,0) circle(1.5cm);
    \clip (1.8,0) circle(1.5cm);
    \fill[black!15](0,0) circle(1.5cm);
\end{scope}

% Circles outline
\draw (0,0) circle(1.5cm);
\draw (1.8,0) circle(1.5cm);

% Set intersection label
\node at (0.9,0) {$A\cup B$};

\end{tikzpicture}%
\hfill%
\begin{tikzpicture}[thick,
    set/.style = {circle,
        minimum size = 3cm,
        fill = black!5}]

% Set A
\node[set,label={135:$A$}] (A) at (0,0) {};

% Set B
\node[set,label={45:$B$}] (B) at (1.8,0) {};

% Intersection
\begin{scope}
    \clip (0,0) circle(1.5cm);
    \clip (1.8,0) circle(1.5cm);
    \fill[black!15](0,0) circle(1.5cm);
\end{scope}
% Circles outline
\draw (0,0) circle(1.5cm);
\draw (1.8,0) circle(1.5cm);

% Set intersection label
\node at (0.9,0) {$A\cap B$};

\end{tikzpicture}%
\hfill%
\vspace{2ex}

\hfill%
\begin{tikzpicture}[thick,
    set/.style = {circle,
        minimum size = 3cm}]

% Set A
\node[set,label={135:$A$},fill=black!15] (A) at (0,0) {};

% Set B
\node[set,label={45:$B$},fill=black!5] (B) at (1.8,0) {};

% Circles outline
\draw (0,0) circle(1.5cm);
\draw (1.8,0) circle(1.5cm);

% Set intersection label
\node at (-0.4,0) {$A - B$};

\end{tikzpicture}%
\hfill%
\begin{tikzpicture}[thick,
    set/.style = {circle,
        minimum size = 3cm}]

% Set B
\node[set,label={45:$B$},fill=black!15] (B) at (1.8,0) {};

% Set A
\node[set,label={135:$A$},fill=black!5] (A) at (0,0) {};

% Circles outline
\draw (0,0) circle(1.5cm);
\draw (1.8,0) circle(1.5cm);

% Set intersection label
\node at (2.2,0) {$B - A$};

\end{tikzpicture}%
\hfill%
\end{footnotesize}
\vspace{1ex}
  \caption[Boolean algebra]{Boolean algebra. Venn diagrams for algebra of sets operations: \emph{union}, $\cup$, \code{union()}; \emph{intersection}, $\cap$, \code{intersect()}; \emph{difference (asymmetrical)}, $-$, \code{setdiff()}; \emph{equality test} \code{setequal()}; \emph{membership}, \code{is.element()} and operator \code{\%in\%}}\label{fig:set:opers}
\end{figure}

Set operations applied to vectors with values representing a mundane example, grocery shopping, demonstrate them.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fruits} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"apple"}\hlstd{,} \hlstr{"pear"}\hlstd{,} \hlstr{"orange"}\hlstd{,} \hlstr{"lemon"}\hlstd{,} \hlstr{"tangerine"}\hlstd{)}
\hlstd{bakery} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"bread"}\hlstd{,} \hlstr{"buns"}\hlstd{,} \hlstr{"cake"}\hlstd{,} \hlstr{"cookies"}\hlstd{)}
\hlstd{dairy} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"milk"}\hlstd{,} \hlstr{"butter"}\hlstd{,} \hlstr{"cheese"}\hlstd{)}
\hlstd{shopping} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"bread"}\hlstd{,} \hlstr{"butter"}\hlstd{,} \hlstr{"apple"}\hlstd{,} \hlstr{"cheese"}\hlstd{,} \hlstr{"orange"}\hlstd{)}
\hlkwd{intersect}\hlstd{(fruits, shopping)}
\end{alltt}
\begin{verbatim}
## [1] "apple"  "orange"
\end{verbatim}
\begin{alltt}
\hlkwd{intersect}\hlstd{(bakery, shopping)}
\end{alltt}
\begin{verbatim}
## [1] "bread"
\end{verbatim}
\begin{alltt}
\hlkwd{intersect}\hlstd{(dairy, shopping)}
\end{alltt}
\begin{verbatim}
## [1] "butter" "cheese"
\end{verbatim}
\begin{alltt}
\hlstr{"lemon"} \hlopt{%in%} \hlstd{dairy}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlstr{"lemon"} \hlopt{%in%} \hlstd{fruits}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{dairy} \hlopt{%in%} \hlstd{shopping}
\end{alltt}
\begin{verbatim}
## [1] FALSE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{union}\hlstd{(bakery, dairy)}
\end{alltt}
\begin{verbatim}
## [1] "bread"   "buns"    "cake"    "cookies" "milk"    "butter"  "cheese"
\end{verbatim}
\begin{alltt}
\hlkwd{setdiff}\hlstd{(}\hlkwd{union}\hlstd{(bakery, dairy), shopping)} \hlcom{# nested call}
\end{alltt}
\begin{verbatim}
## [1] "buns"    "cake"    "cookies" "milk"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
Sets describe membership as a binary property, thus when vectors are interpreted as sets, duplicate members are redundant. Duplicate members although accepted as input are always simplified in the returned values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{union}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{))} \hlcom{# set operation}
\end{alltt}
\begin{verbatim}
## [1] "a" "b"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setequal}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{))} \hlcom{# sets compared}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all.equal}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{))} \hlcom{# vectors compared}
\end{alltt}
\begin{verbatim}
## [1] "1 string mismatch"
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{))} \hlcom{# vectors compared}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

We construct and save a character vector to use in the next examples.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{,} \hlstr{"b"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

To test if a given value belongs to a set, we use operator \Roperator{\%in\%} or its function equivalent \Rfunction{is.element()}. In the algebra of sets notation, this is written $a \in A$, where $A$ is a set and $a$ a member. The second statement shows that the \code{\%in\%} operator is vectorised on its left-hand-side (lhs) operand, returning a logical vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.element}\hlstd{(}\hlstr{"a"}\hlstd{, vct1)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstr{"a"} \hlopt{%in%} \hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{)} \hlopt{%in%} \hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1]  TRUE  TRUE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Keep in mind that inclusion, implemented in operator \verb|%in%|, is an asymmetrical (not reflective) operation among a vector and a set. The right-hand-side (rhs) argument is interpreted as a set, while the left-hand-side (lhs) argument is interpreted as a vector of values to test for membership in the set. In other words, any duplicate member in the lhs operand is retained and tested while the rhs operand is interpreted as a set of unique values. The returned logical vector has the same length as the lhs operand.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlopt{%in%} \hlstr{"a"}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE FALSE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

The negation of inclusion is $a \not\in A$, and coded in \Rlang by applying the negation operator \Roperator{!} to the result of the test done with \Roperator{\%in\%} or function \Rfunction{is.element()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlopt{!}\hlkwd{is.element}\hlstd{(}\hlstr{"a"}\hlstd{, vct1)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlopt{!}\hlstr{"a"} \hlopt{%in%} \hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlopt{!}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{)} \hlopt{%in%} \hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] FALSE FALSE  TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Although inclusion is a set operation, it is also very useful for the simplification of \code{if () \ldots\ else} statements by replacing multiple tests for alternative constant values of the same \code{mode} chained by multiple \Roperator{|} operators. A useful property of \Roperator{\%in\%} and \Rfunction{is.element()} is that they never return \code{NA}.

\begin{explainbox}
Operator \Roperator{\%in\%} is equivalent to function \Rfunction{match()}, although the additional parameters of \Rfunction{match()} provide additional flexibility.

In some cases, such as when accepting partial character strings as input, the aim is not an exact match, but a partial match to target character strings. In this case, either \Rfunction{charmatch()} or \Rfunction{pmatch()} is the correct tool to use depending on the desired handling of partial, ambiguous and exact matches. Use \code{help()} to find the details if you need to use one of them.

\end{explainbox}

\begin{playground}
Use operator \Roperator{\%in\%} to write more concisely the following comparisons. Hint: see section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean} for the difference between \code{|} and \code{||} operators.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{)}
\hlstd{vct2} \hlopt{==} \hlstr{"a"} \hlopt{|} \hlstd{vct2} \hlopt{==} \hlstr{"b"} \hlopt{|} \hlstd{vct2} \hlopt{==} \hlstr{"c"} \hlopt{|} \hlstd{xvct2} \hlopt{==} \hlstr{"d"}
\end{alltt}
\end{kframe}
\end{knitrout}

Convert the \code{logical} vectors of length 3 into a vector of length one. Hint: see help for functions \code{all()} and \code{any()}.
\end{playground}

With \Rfunction{unique()} we convert a vector of possibly repeated values into a set of unique values. In the algebra of sets, a certain object belongs or not to a set. Consequently, in a set, multiple copies of the same object or value are meaningless.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{unique}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] "a" "b" "c"
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{unique()} is frequently useful, for example when we want determine the number of distinct values in a vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{unique}\hlstd{(vct1))}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  Do the values returned by these two statements differ?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{)} \hlopt{%in%} \hlstd{vct1}
\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{)} \hlopt{%in%} \hlkwd{unique}\hlstd{(vct1)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{explainbox}
Function \Rfunction{duplicated()} is the counterpart of \Rfunction{unique()}, returning a logical vector, indicating which values in a vector are duplicates of values already present at positions with a lower index.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{duplicated}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] FALSE FALSE FALSE  TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{anyDuplicated}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] 4
\end{verbatim}
\end{kframe}
\end{knitrout}

The \Rlang language includes many functions that simplify tasks related to data analysis. Some are well known like \code{unique()}, but others may need to be searched for in the documentation.
\end{explainbox}

\begin{playground}
What do you expect to be the difference between the values returned by the three statements in the code chunk below? Before running them, write down your expectations about the value each one will return. Only then run the code. Independently of whether your predictions were correct or not, write down an explanation of what each statement's operation is.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{union}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{), vct1)}
\hlkwd{c}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{), vct1)}
\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"z"}\hlstd{, vct1)}
\end{alltt}
\end{kframe}
\end{knitrout}

Are set union and concatenation of vectors equivalent operations? why or why not?

\end{playground}

\begin{explainbox}
All set algebra examples above use character vectors and character constants. This is just the most frequent use case. Sets operations are valid on vectors of any atomic class, including \code{integer}, and computed values can be part of statements. In the second and third statements in the next chunk, we need to use additional parentheses to alter the default order of precedence between arithmetic and set operators.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{9} \hlopt{%in%} \hlnum{2}\hlopt{:}\hlnum{4}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlnum{9} \hlopt{%in%} \hlstd{((}\hlnum{2}\hlopt{:}\hlnum{4}\hlstd{)} \hlopt{*} \hlstd{(}\hlnum{2}\hlopt{:}\hlnum{4}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{16}\hlstd{)} \hlopt{%in%} \hlstd{((}\hlnum{2}\hlopt{:}\hlnum{4}\hlstd{)} \hlopt{*} \hlstd{(}\hlnum{2}\hlopt{:}\hlnum{4}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] FALSE  TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\emph{Empty sets} are an important component of the algebra of sets, in \Rlang they are represented as vectors of zero length. These vectors do belong to a class such as \Rclass{numeric} or \Rclass{character} and must be compatible with other operands in an expression.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlstr{"ab"}\hlstd{,} \hlstr{"xy"}\hlstd{)} \hlopt{%in%} \hlkwd{character}\hlstd{()}
\end{alltt}
\begin{verbatim}
## [1] FALSE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{character}\hlstd{()} \hlopt{%in%} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## logical(0)
\end{verbatim}
\begin{alltt}
\hlkwd{union}\hlstd{(}\hlstr{"ab"}\hlstd{,} \hlkwd{character}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] "ab"
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{warningbox}
  Although set operators are defined for \Rclass{numeric} vectors, rounding errors in `floats' can result in unexpected results (see section \ref{box:floats} on page \pageref{box:floats}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlkwd{cos}\hlstd{(pi),} \hlkwd{sin}\hlstd{(pi))} \hlopt{%in%} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlkwd{cos}\hlstd{(pi),} \hlkwd{sin}\hlstd{(pi))}
\end{alltt}
\begin{verbatim}
## [1] -1.000000e+00  1.224606e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{warningbox}

\begin{advplayground}
In the algebra of sets notation $A \subseteq B$, where $A$ and $B$ are sets, indicates that $A$ is a subset or equal to $B$. For a true subset, the notation is $A \subset B$. The operators with the reverse direction are $\supseteq$ and $\supset$. Implement these four operations in four \Rlang statements, and test them on sets (represented by \Rlang vectors) with different ``overlap'' among set members.
\end{advplayground}
\index{operators!set|)}
\index{sets|)}



\section{The Mode and Class of Objects}\label{sec:rlang:mode}
\index{objects!mode}
Classes are abstractions, they determine the ``meaning'' and behaviour of objects belonging to them. New classes can be defined in user code as well as new methods, i.e., functions or operators tailored to fit them. The \emph{class} is like a ``tag'' that tells how the value in an object should be interpreted and operated upon.

Variables (names given to objects) have a \emph{class} that depends on the object stored in them. In contrast to some other languages in \Rlang assignment to a variable already in use to store an object belonging to a different class is allowed. There is a restriction that all elements in a vector, array or matrix, must be of the same mode (these are called atomic, as they contain homogeneous members). Lists and data frames can be heterogenous (to be described in chapter \ref{chap:R:collective}). In practice, this means that we can assign an object, such as a vector, with a different \code{class} to a name already in use, but we cannot use indexing to assign an object of a different mode to individual members of a vector, matrix or array.

Function \Rfunction{class()} is used to query the class of an object, and function \Rfunction{inherits()} is used to test if an object belongs to a specific class or not (including ``parent'' classes, to be later described).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{5}
\hlkwd{class}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] "integer"
\end{verbatim}
\begin{alltt}
\hlkwd{inherits}\hlstd{(vct1,} \hlstr{"character"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{inherits}\hlstd{(vct1,} \hlstr{"numeric"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions with names starting with \code{is.} are tests returning a logical value, \code{TRUE}, \code{FALSE} or \code{NA}.\qRfunction{is.character()}\qRfunction{is.numeric()}\qRfunction{is.logical()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(vct1)} \hlcom{# no distinction of integer or double}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.double}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.integer}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.logical}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.character}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Functions starting with \code{is.} have to be individually defined and are available only for some classes. Function \Rfunction{inherits()} takes as its second argument a character vector containing strings to be tested against the \code{class} attribute of the object passed as its first argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{inherits}\hlstd{(vct1,} \hlkwd{c}\hlstd{(}\hlstr{"numeric"}\hlstd{,} \hlstr{"character"}\hlstd{,} \hlstr{"logical"}\hlstd{),} \hlkwc{which} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{explainbox}
The \emph{mode} of an object is a fundamental property, and limited to those modes defined as part of the \Rlang language. In particular, different \Rlang objects of a given mode, such as \code{numeric}, can belong to different \code{class}es. Classes and the dispatch of methods are discussed in section \ref{sec:script:objects:classes:methods} on page \pageref{sec:script:objects:classes:methods}, together with object-oriented programming.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{))} \hlcom{# no distinction of integer or double}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{typeof}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "double"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1L}\hlstd{,} \hlnum{2L}\hlstd{,} \hlnum{3L}\hlstd{))} \hlcom{# no distinction of integer or double}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{typeof}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1L}\hlstd{,} \hlnum{2L}\hlstd{,} \hlnum{3L}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "integer"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1L}\hlstd{,} \hlnum{2L}\hlstd{,} \hlnum{3L}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "integer"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{)))} \hlcom{# no distinction of integer or double}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{typeof}\hlstd{(}\hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] "integer"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] "factor"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "character"
\end{verbatim}
\begin{alltt}
\hlkwd{typeof}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "character"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "logical"
\end{verbatim}
\begin{alltt}
\hlkwd{typeof}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "logical"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "logical"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}



\section{Type Conversions}\label{sec:calc:type:conversion}
\index{type conversion|(}
By type conversion we mean converting a value from one class into a value expressed in a different class. usually the meaning can be retained, at least in part. We can, for example, convert character strings into numeric values, but this conversion is possible only for character strings conformed by digits, like \code{"100"}. Most conversions, such as the conversion of \code{character} value \code{"100"} into \code{numeric} value \code{100} are obvious. Type conversions involving logical values are less intuitive. By convention, functions used to convert objects from one mode or class to a different one have names starting with \code{as.}\footnote{Except for some packages in the \pkgnameNI{tidyverse} that use names starting with \code{as\_} instead of \code{as.}.}.\qRfunction{as.character()}\qRfunction{as.numeric()}\qRfunction{as.logical()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{102}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "102"
\end{verbatim}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "TRUE"
\end{verbatim}
\begin{alltt}
\hlkwd{as.character}\hlstd{(}\hlnum{3.0e10}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "3e+10"
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"203"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 203
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlstr{"TRUE"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlnum{100}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{as.logical}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Some conversions takes place automatically in expressions involving both \code{numeric} and \code{logical} values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{TRUE} \hlopt{+} \hlnum{10}
\end{alltt}
\begin{verbatim}
## [1] 11
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{||} \hlnum{0}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlnum{FALSE} \hlopt{| -}\hlnum{2}\hlopt{:}\hlnum{2}
\end{alltt}
\begin{verbatim}
## [1]  TRUE  TRUE FALSE  TRUE  TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
There is flexibility in the conversion from character strings into \code{numeric} and \code{logical} values. Use the examples below plus your own variations to get an idea of what strings are acceptable and correctly converted and which are not. Do also pay attention at the conversion between \code{numeric} and \code{logical} values.\qRfunction{as.character()}\qRfunction{as.numeric()}\qRfunction{as.logical()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"5E+5"}\hlstd{)}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"50e+4"}\hlstd{)}
\hlkwd{as.numeric}\hlstd{(}\hlstr{".12"}\hlstd{)}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"0.12"}\hlstd{)}
\hlkwd{as.numeric}\hlstd{(}\hlstr{"A"}\hlstd{)}
\hlkwd{as.logical}\hlstd{(}\hlstr{"TRUE"}\hlstd{)}
\hlkwd{as.logical}\hlstd{(}\hlstr{"FALSE"}\hlstd{)}
\hlkwd{as.logical}\hlstd{(}\hlstr{"T"}\hlstd{)}
\hlkwd{as.logical}\hlstd{(}\hlstr{"t"}\hlstd{)}
\hlkwd{as.logical}\hlstd{(}\hlstr{"true"}\hlstd{)}
\hlkwd{as.logical}\hlstd{(}\hlstr{"NA"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{playground}
Conversion of fractional numbers into whole numbers can be achieved in different ways, by truncation of the fractional part or rounding it up or down. If we consider both negative and positive numbers, how each of them is handled creates additional possibilities. All these approaches, as defined in mathematics, are available through different \Rlang functions. These functions, are not conversion functions as they return a \code{numeric} value of class \code{double}. See page \pageref{par:calc:round}. In contrast, \Rfunction{as.integer()} is a conversion function for type \code{double} into type \code{integer}, both with mode \code{numeric}.

Compare the values returned by \Rfunction{trunc()} and \Rfunction{as.integer()} when applied to a floating point number, such as \code{12.34}. Check for the equality of values, and for the \emph{class} and \emph{type} of the returned objects.
\end{playground}

\begin{explainbox}
Using conversions, the difference between the length of a \code{character} vector and the number of characters composing each member ``string'' within a vector becomes clear.\qRfunction{length()}\qRfunction{as.numeric()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"1"}\hlstd{,} \hlstr{"2"}\hlstd{,} \hlstr{"3"}\hlstd{)}
\hlkwd{length}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlstr{"123.1"}
\hlkwd{length}\hlstd{(vct2)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(vct2)}
\end{alltt}
\begin{verbatim}
## [1] 123.1
\end{verbatim}
\begin{alltt}
\hlkwd{as.integer}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{as.integer}\hlstd{(vct2)}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\sloppy
Other\index{formatted character strings from numbers} functions relevant to the ``conversion'' of numbers and other values are \Rfunction{format()}, and \Rfunction{sprintf()}. This is sometimes informally called ``pretty printing''. These two functions return \Rclass{character} strings, instead of \code{numeric} or other values, and are useful for printed output. One could think of these functions as advanced conversion functions returning formatted, and possibly combined and annotated, character strings. However, they are usually not considered normal conversion functions, as they are very rarely used in a way that preserves the original precision of the input values. We show here the use of \Rfunction{format()} and \Rfunction{sprintf()} with \code{numeric} values, but they can also be used with values of other classes like \code{character}, \code{logical}, etc.

When using \Rfunction{format()}, the format used to display numbers is set by passing arguments to several different parameters. As \Rfunction{print()} calls \Rfunction{format()} to convert \code{numeric} values into \code{character} strings, it accepts the same options.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{=} \hlkwd{c}\hlstd{(}\hlnum{123.4567890}\hlstd{,} \hlnum{1.0}\hlstd{)}
\hlkwd{format}\hlstd{(vct2)} \hlcom{# using defaults}
\end{alltt}
\begin{verbatim}
## [1] "123.4568" "  1.0000"
\end{verbatim}
\begin{alltt}
\hlkwd{format}\hlstd{(}\hlnum{123.4567890}\hlstd{)} \hlcom{# using defaults}
\end{alltt}
\begin{verbatim}
## [1] "123.4568"
\end{verbatim}
\begin{alltt}
\hlkwd{format}\hlstd{(}\hlnum{1.0}\hlstd{)} \hlcom{# using defaults}
\end{alltt}
\begin{verbatim}
## [1] "1"
\end{verbatim}
\begin{alltt}
\hlkwd{format}\hlstd{(vct2,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{nsmall} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "123.5" "  1.0"
\end{verbatim}
\begin{alltt}
\hlkwd{format}\hlstd{(vct2,} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{scientific} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "1.23e+02" "1.00e+00"
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{sprintf()} is similar to \Clang's function of the same name. The user interface is rather unusual, but very powerful, once one learns the syntax. All the formatting is specified using a \code{character} string as template. In this template, placeholders for data and the formatting instructions are embedded using special codes. These codes start with a percent character. We show in the example below the use of some of these: \code{f} is used for \code{numeric} values to be formatted according to a ``fixed point'', while \code{g} is used when we set the number of significant digits and \code{e} for exponential or \emph{scientific} notation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{=} \hlkwd{c}\hlstd{(}\hlnum{123.4567890}\hlstd{,} \hlnum{1.0}\hlstd{)}
\hlkwd{sprintf}\hlstd{(}\hlstr{"The numbers are: %4.2f and %.0f"}\hlstd{, x[}\hlnum{1}\hlstd{], x[}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] "The numbers are: 123.46 and 1"
\end{verbatim}
\begin{alltt}
\hlkwd{sprintf}\hlstd{(}\hlstr{"The numbers are: %.4g and %.2g"}\hlstd{, x[}\hlnum{1}\hlstd{], x[}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] "The numbers are: 123.5 and 1"
\end{verbatim}
\begin{alltt}
\hlkwd{sprintf}\hlstd{(}\hlstr{"The numbers are: %4.2e and %.0e"}\hlstd{, x[}\hlnum{1}\hlstd{], x[}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] "The numbers are: 1.23e+02 and 1e+00"
\end{verbatim}
\end{kframe}
\end{knitrout}

In the template \code{"The numbers are: \%4.2f and \%.0f"}, there are two placeholders for \code{numeric} values, \code{\%4.2f} and \code{\%.0f}; so, in addition to the template, we pass two values extracted from the first two positions of vector \code{x}. These could have been two different vectors of length one, or even numeric constants. The template itself does not need to be a \code{character} constant as in these examples, as a variable can be also passed as argument.

\begin{playground}
Function \Rfunction{format()} may be easier to use, in some cases, but \Rfunction{sprintf()} is more flexible and powerful. Those with experience in the use of the \Clang language will already know about \Rfunction{sprintf()} and its use of templates for formatting output. Even if you are familiar with  \Clang, look up the help pages for both functions, and practice, by trying to create the same formatted output by means of the two functions. Do also play with these functions with other types of data like \code{integer} and \code{character}.
\end{playground}

\begin{explainbox}
I have described above \Rconst{NA} as a single value ignoring modes, but in reality \Rconst{NA} values come in various flavours: \Rconst{NA\_real\_}, \Rconst{NA\_character\_}, etc. and \Rconst{NA} defaults to an \Rconst{NA} of class \Rclass{logical}. \Rconst{NA} is normally converted on the fly to other modes when needed, so in general \Rconst{NA} is all we need to use. The examples below use the extraction operator to demonstrate automatic conversion on assignment. This operator is described in section \ref{sec:calc:indexing} below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct3} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlkwd{is.numeric}\hlstd{(vct3[}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.numeric}\hlstd{(}\hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct4} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"abc"}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlkwd{is.character}\hlstd{(vct4[}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlnum{NA_character_}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.character}\hlstd{(}\hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "logical"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct5} \hlkwb{<-} \hlnum{NA}
\hlkwd{c}\hlstd{(vct5,} \hlnum{2}\hlopt{:}\hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] NA  2  3
\end{verbatim}
\end{kframe}
\end{knitrout}

However, even the statement below works transparently.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct3[}\hlnum{3}\hlstd{]} \hlkwb{<-} \hlstd{vct4[}\hlnum{2}\hlstd{]}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

\index{type conversion|)}



\section{Vector Manipulation}\label{sec:vectors}\label{sec:calc:indexing}
\index{vectors!indexing|(}\index{vectors!member extraction}
If you have read earlier sections of this chapter, you already know how to create a vector. If not, see pages \pageref{par:numeric:vectors:start}--\pageref{par:numeric:vectors:end} before continuing.

In this section, we are going to see how to extract or retrieve, replace, and move elements such as $a_2$ from a vector $a_{i = 1\ldots n}$. Elements are extracted using an index enclosed in single square brackets. The index indicates the position in the vector, starting from one, following the usual mathematical tradition. While in maths notation $a_1$ represents the first, or leftmost, member of vector $a_{i = 1\ldots n}$, in \Rpgrm the equivalent notation is \code{a[1]} for the member and \code{a} for the vector.

We extract the first 10 elements of the vector \code{letters}, by passing an \code{integer} vector as argument to operator \Roperator{[ ]}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{vct1}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=red!20},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}},
row 1 column 2/.style={nodes={draw}}}]

\matrix[array] (array) {
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
``a''\strut & ``b''\strut & ``c''\strut & ``d''\strut & ``e''\strut & ``f''\strut & ``g''"\strut &``h''\strut & ``i''\strut & ``j''\strut \\};
\node[draw, minimum size=4mm] at (array-2-2) (box) {};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-10.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\code{\strut\ vct1\phantom{mm}}};
%\draw (array-1-2.north)--++(90:3mm) node [above] (first) {Index};
\draw (array-1-10.east)--++(0:3mm) node [right]{\code{integer} positional indices};
\draw (array-2-10.east)--++(0:3mm) node [right]{\code{character} values};
\node [align=center, anchor=south] at (array-2-2.south west|-first.south) (1) [below, yshift=-5mm]{\code{vct1[2]}};
\draw (1)--(box);
%
\end{tikzpicture}
\end{footnotesize}
\end{center}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1[}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "b"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Four constant vectors are available in base \Rlang: \Rconst{letters}, \Rconst{LETTERS}, \Rconst{month.name} and  \Rconst{month.abb}, of which I used \code{letters} in the example above. These vectors are always for English, irrespective of the locale.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{month.name}
\end{alltt}
\begin{verbatim}
##  [1] "January"   "February"  "March"     "April"     "May"       "June"     
##  [7] "July"      "August"    "September" "October"   "November"  "December"
\end{verbatim}
\begin{alltt}
\hlstd{month.name[}\hlnum{6}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "June"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{warningbox}
In \Rlang, indexes always start from one, while in some other programming languages such as \Clang and \Cpplang, indexes start from zero. It is important to be aware of this difference, as many computation algorithms are valid only under a given indexing convention.
\end{warningbox}

\begin{faqbox}{How to access the last value in a vector?}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{month.name[}\hlkwd{length}\hlstd{(month.name)]}
\end{alltt}
\begin{verbatim}
## [1] "December"
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

It is possible to extract a subset of the elements of a vector in a single operation, using a vector of indexes. The positions of the extracted elements in the result (``returned value'') are determined by the ordering of the members of the vector of indexes---easier to demonstrate than to explain.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "c" "b"
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlnum{10}\hlopt{:}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "j" "i" "h" "g" "f" "e" "d" "c" "b" "a"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
The length of the indexing vector is \emph{not} restricted by the length of the indexed vector. However, only numerical indexes that match positions present in the indexed vector can extract values. Those values in the indexing vector pointing to positions that are not present in the indexed vector, result in \code{NA} values. This is easier to learn by \emph{playing} with \Rlang, than from explanations. Play with \Rlang, using the following examples as a starting point.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{length}\hlstd{(vct1)}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{3}\hlstd{)]}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{10}\hlopt{:}\hlnum{1}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{)]}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{11}\hlstd{)]}
\hlstd{vct1[}\hlnum{11}\hlstd{]}
\end{alltt}
\end{kframe}
\end{knitrout}

Have you tried some of your own examples? If not yet, do \emph{play} with additional variations of your own before continuing.

\end{playground}

Negative indexes have a special meaning; they indicate the positions at which values should be excluded. Be aware that it is \emph{illegal} to mix positive and negative values in the same indexing operation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1[}\hlopt{-}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "a" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlopt{-}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{2}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlopt{-}\hlnum{3}\hlopt{:-}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "a" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Results from indexing with special values and zero may be surprising. Try to build a rule from the examples below, a rule that will help you remember what to expect next time you are confronted with similar statements using special values as ``subscripts'' instead of integers larger or equal to one---this is likely to happen sooner or later as these special values can be returned by different \Rlang expressions depending on the value of operands or function arguments, some of them described earlier in this chapter.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1[ ]}
\hlstd{vct1[}\hlnum{0}\hlstd{]}
\hlstd{vct1[}\hlkwd{numeric}\hlstd{(}\hlnum{0}\hlstd{)]}
\hlstd{vct1[}\hlnum{NA}\hlstd{]}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{NA}\hlstd{)]}
\hlstd{vct1[}\hlkwa{NULL}\hlstd{]}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlkwa{NULL}\hlstd{)]}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

Another way of indexing, which is very handy, but not available in most other programming languages, is indexing with a vector of \code{logical} values. The \code{logical} vector used for indexing is usually of the same length as the vector from which elements are going to be selected. However, this is not a requirement, because if the \code{logical} vector of indexes is shorter than the indexed vector, it is ``recycled'' as discussed on page \pageref{par:recycling:numeric} in relation to other operators.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1[}\hlnum{TRUE}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlnum{FALSE}\hlstd{]}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "a" "c" "e" "g" "i"
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## [1] "b" "d" "f" "h" "j"
\end{verbatim}
\begin{alltt}
\hlstd{vct1} \hlopt{>} \hlstr{"c"}
\end{alltt}
\begin{verbatim}
##  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlstd{vct1[vct1} \hlopt{>} \hlstr{"c"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

Indexing with logical vectors is very frequently used in \Rlang because comparison operators are vectorised. Comparison operators, when applied to a vector, return a \code{logical} vector, a vector that can be used to extract the elements for which the result of the comparison test was \code{TRUE}.

\begin{playground}
The examples in this text box demonstrate additional uses of logical vectors: 1) the logical vector returned by a vectorised comparison can be stored in a variable, and the variable used as a ``selector'' for extracting a subset of values from the same vector, or from a different vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{selector} \hlkwb{<-} \hlstd{vct1} \hlopt{>} \hlstr{"c"}
\hlstd{selector}
\hlstd{vct1[selector]}
\hlstd{vct2[selector]}
\end{alltt}
\end{kframe}
\end{knitrout}

Positional indexes can be obtained from a \code{logical} vector by means of function \code{which()} as it returns a \code{numeric} vector with the positions of the \code{TRUE} values in the \code{logical} vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{indexes} \hlkwb{<-} \hlkwd{which}\hlstd{(vct1} \hlopt{>} \hlstr{"c"}\hlstd{)}
\hlstd{indexes}
\hlstd{vct1[indexes]}
\end{alltt}
\end{kframe}
\end{knitrout}

Make sure to understand the examples above. These constructs are very widely used in \Rlang because they allow for concise code that is easy to understand once one is familiar with the indexing rules.
\end{playground}

\begin{explainbox}\label{par:calc:vector:map}
\index{vectors!named elements}
Above, \code{integer} or \code{logical} vectors were used as indices for extraction of anonymous elements, or members, from \code{character} vectors. In \Rlang, elements can be assigned names, and these names used in place of \code{numeric} indices to access them. One situation where this is very useful is the mapping of values between two representations. Let's assume we have a long vector encoding treatments using single letter codes and that we want to replace these codes with self-explanatory names.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{treat} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"H"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"H"}\hlstd{,} \hlstr{"W"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"H"}\hlstd{,} \hlstr{"H"}\hlstd{,} \hlstr{"W"}\hlstd{,} \hlstr{"W"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can create a named vector to \emph{map} the single letter codes onto full words. Above, we used function \Rfunction{c()} to concatenate several \code{character} strings, without assigning any names to them, thus they have to be extracted from the vector using \code{numeric} values, indexing by position. Below, we assign a name to each string. Using operator \Roperator{=} we assign the name on the left-hand side (\emph{lhs}) to the member of the vector on the right-hand-side (\emph{rhs}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{treat.map} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwc{H} \hlstd{=} \hlstr{"hot"}\hlstd{,} \hlkwc{C} \hlstd{=} \hlstr{"cold"}\hlstd{,} \hlkwc{W} \hlstd{=} \hlstr{"warm"}\hlstd{)}
\hlstd{treat.map}
\end{alltt}
\begin{verbatim}
##      H      C      W 
##  "hot" "cold" "warm"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(treat.map)}
\end{alltt}
\begin{verbatim}
## [1] "H" "C" "W"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily,
array/.style={matrix of nodes,nodes={draw, minimum size=7mm, fill=red!20},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}}]

\matrix[array] (array) {
1 & 2 & 3 \\
``hot''\strut & ``cold''\strut & ``warm''\strut \\};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-3.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\code{\strut treat.map}};
\draw (array-2-1.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-11.5mm, yshift=-2.7mm, above] (nameh) {\rotatebox{90}{H\strut}};
\draw (array-2-2.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-11.5mm, yshift=-2.7mm, above] (namec) {\rotatebox{90}{C\strut}};
\draw (array-2-3.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-11.5mm, yshift=-2.7mm, above] (namew) {\rotatebox{90}{W\strut}};
%\draw (array-1-2.north)--++(90:3mm) node [above] (first) {Index};
\draw (array-1-3.east)--++(0:6.5mm) node [right]{\code{integer} positional indices};
\draw (array-2-3.east)--++(0:3mm) node [right]{\code{character} values};
\draw (namew)--++(0:9mm) node [right]{\code{character} member names};
%
\end{tikzpicture}
\end{footnotesize}
\end{center}

As \code{treat.map} is a named vector, we can use the element names, in addition to \code{numeric} values, as indices for element extraction.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{treat.map[}\hlstr{"H"}\hlstd{]}
\end{alltt}
\begin{verbatim}
##     H 
## "hot"
\end{verbatim}
\end{kframe}
\end{knitrout}

The indexing vector can be of a different length than the indexed vector, and the returned value is a new vector of the same length as the indexing vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{treat.new} \hlkwb{<-} \hlstd{treat.map[treat]}
\hlstd{treat.new}
\end{alltt}
\begin{verbatim}
##      H      C      H      W      C      H      H      W      W 
##  "hot" "cold"  "hot" "warm" "cold"  "hot"  "hot" "warm" "warm"
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
where \code{treat.new} is a named vector, from which we will frequently want to remove the members' names.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{treat.new} \hlkwb{<-} \hlkwd{unname}\hlstd{(treat.new)}
\hlstd{treat.new}
\end{alltt}
\begin{verbatim}
## [1] "hot"  "cold" "hot"  "warm" "cold" "hot"  "hot"  "warm" "warm"
\end{verbatim}
\end{kframe}
\end{knitrout}

It is more common to use named members with lists than with vectors, but in \Rlang, in both cases it is possible to use both numeric positional indices and names.
\end{explainbox}

Indexing can be used on either side of an assignment expression. In the code chunk below, we use the extraction operator on the left-hand side of the assignments to replace values only at selected positions in the vector. This may look rather esoteric at first sight, but it is just a simple extension of the logic of indexing described above. It works, because the low precedence of the \Roperator{<-} operator results in both the left- and the right-hand side being fully evaluated before the assignment takes place. To make the changes to the vectors easier to compare, identical vectors are used in each of the examples below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlstd{vct2[}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{99}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
##  [1] 99  2  3  4  5  6  7  8  9 10
\end{verbatim}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct2[}\hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,}\hlnum{4}\hlstd{)]} \hlkwb{<-} \hlopt{-}\hlnum{99} \hlcom{# recycling}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
##  [1]   1 -99   3 -99   5   6   7   8   9  10
\end{verbatim}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct2[}\hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,}\hlnum{4}\hlstd{)]} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{99}\hlstd{,} \hlnum{99}\hlstd{)}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
##  [1]   1 -99   3  99   5   6   7   8   9  10
\end{verbatim}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct2[}\hlnum{TRUE}\hlstd{]} \hlkwb{<-} \hlnum{1} \hlcom{# recycling}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
##  [1] 1 1 1 1 1 1 1 1 1 1
\end{verbatim}
\begin{alltt}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{vct2} \hlkwb{<-} \hlnum{1}  \hlcom{# no recycling}
\hlstd{vct2}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

Indexing can be used simultaneously on both sides of the assignment operator, for example, to swap two elements.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct3} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{vct3[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{vct3[}\hlnum{2}\hlopt{:}\hlnum{1}\hlstd{]}
\hlstd{vct3}
\end{alltt}
\begin{verbatim}
##  [1] "b" "a" "c" "d" "e" "f" "g" "h" "i" "j"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Do play with subscripts to your heart's content, really grasping how they work and how they can be used, will be very useful in anything you do in the future with \Rlang. Even the contrived example below follows the same simple rules, just study it bit by bit. Hint: the second statement in the chunk below, modifies \code{VCT1}, so, when studying variations of this example, you will need to recreate \code{VCT1} by executing the first statement each time you run a variation of the second statement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{VCT1} \hlkwb{<-} \hlstd{letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{VCT1[}\hlnum{5}\hlopt{:}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{VCT1[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,}\hlnum{FALSE}\hlstd{)]}
\hlstd{VCT1}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{explainbox}\label{box:vec:sort}
In \Rlang, indexing with positional indexes can be done with \Rclass{integer} or \Rclass{numeric} values. Numeric values can be floats, but for indexing, only integer values are meaningful. Consequently, \Rclass{double} values are converted into \code{integer} values when used as indexes. The conversion is done invisibly, but it does slow down computations slightly. When working on big data sets, explicitly using \code{integer} values can improve performance.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct4} \hlkwb{<-} \hlstd{LETTERS[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{vct4}
\end{alltt}
\begin{verbatim}
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlnum{1.1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlnum{1.9999}\hlstd{]} \hlcom{# surprise!!}
\end{alltt}
\begin{verbatim}
## [1] "A"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "B"
\end{verbatim}
\end{kframe}
\end{knitrout}

From this experiment, we can learn that if positive indexes are not whole numbers, they are truncated to the next smaller integer.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct4} \hlkwb{<-} \hlstd{LETTERS[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{vct4}
\end{alltt}
\begin{verbatim}
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlopt{-}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "B" "C" "D" "E" "F" "G" "H" "I" "J"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlopt{-}\hlnum{1.1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "B" "C" "D" "E" "F" "G" "H" "I" "J"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlopt{-}\hlnum{1.9999}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "B" "C" "D" "E" "F" "G" "H" "I" "J"
\end{verbatim}
\begin{alltt}
\hlstd{vct4[}\hlopt{-}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "A" "C" "D" "E" "F" "G" "H" "I" "J"
\end{verbatim}
\end{kframe}
\end{knitrout}

From this experiment, we can learn that if negative indexes are not whole numbers, they are truncated to the next larger (less negative) integer. In conclusion, \code{double} index values behave as if they where sanitised using function \code{trunc()}.

This example also shows how one can tease out of \Rlang its rules through experimentation.

\end{explainbox}

A\index{vectors!sorting} frequent operation on vectors is sorting them into an increasing or decreasing order. The most direct approach is to use \Rfunction{sort()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct5} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{22}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{4}\hlstd{)}
\hlkwd{sort}\hlstd{(vct5)}
\end{alltt}
\begin{verbatim}
## [1]  1  4  4 10 22
\end{verbatim}
\begin{alltt}
\hlkwd{sort}\hlstd{(vct5,} \hlkwc{decreasing} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 22 10  4  4  1
\end{verbatim}
\end{kframe}
\end{knitrout}

An indirect way of sorting a vector, possibly based on a different vector, is to generate with \Rfunction{order()} a vector of numerical indexes that can be used to achieve the ordering.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{order}\hlstd{(vct5)}
\end{alltt}
\begin{verbatim}
## [1] 4 2 5 1 3
\end{verbatim}
\begin{alltt}
\hlstd{vct5[}\hlkwd{order}\hlstd{(vct5)]}
\end{alltt}
\begin{verbatim}
## [1]  1  4  4 10 22
\end{verbatim}
\begin{alltt}
\hlstd{vct6} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"ab"}\hlstd{,} \hlstr{"aa"}\hlstd{,} \hlstr{"c"}\hlstd{,} \hlstr{"zy"}\hlstd{,} \hlstr{"e"}\hlstd{)}
\hlstd{vct6[}\hlkwd{order}\hlstd{(vct5)]}
\end{alltt}
\begin{verbatim}
## [1] "zy" "aa" "e"  "ab" "c"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
A problem linked to sorting that we may face is counting how many copies of each value are present in a vector. We need to use two functions \Rfunction{sort()} and \Rfunction{rle()}\index{vector!run length encoding}. The second of these functions computes \emph{run length} as used in \emph{run length encoding} for which \emph{rle} is an abbreviation. A \emph{run} is a series of consecutive identical values. As the objective is to count the number of copies of each value present, we need first to sort the vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct7} \hlkwb{<-} \hlstd{letters[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{10}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{21}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{10}\hlstd{)]}
\hlstd{vct7}
\end{alltt}
\begin{verbatim}
## [1] "a" "e" "j" "c" "a" "d" "u" "a" "j"
\end{verbatim}
\begin{alltt}
\hlkwd{sort}\hlstd{(vct7)}
\end{alltt}
\begin{verbatim}
## [1] "a" "a" "a" "c" "d" "e" "j" "j" "u"
\end{verbatim}
\begin{alltt}
\hlkwd{rle}\hlstd{(}\hlkwd{sort}\hlstd{(vct7))}
\end{alltt}
\begin{verbatim}
## Run Length Encoding
##   lengths: int [1:6] 3 1 1 1 2 1
##   values : chr [1:6] "a" "c" "d" "e" "j" "u"
\end{verbatim}
\end{kframe}
\end{knitrout}

The second and third statements are only to demonstrate the effect of each step. The last statement uses nested function calls to compute the number of copies of each value in the vector.
\end{explainbox}
\index{vectors!indexing|)}



\section{Matrices and Multidimensional Arrays}\label{sec:matrix:array}
\index{matrices|(}\index{arrays|(}\qRclass{matrix}\qRclass{array}

Matrices have two dimensions, rows and columns, and like vectors all their members share the same mode, and are atomic, i.e., they are homogeneous (Figure \ref{fig:matrix:margins}). Most commonly, matrices are used to store \code{numeric}, \code{integer} or \code{logical} values. The number of rows and columns can differ, so matrices can be either square or rectangular in shape, but never ragged.

\begin{figure}
  \centering
\begin{footnotesize}
\begin{tikzpicture}[auto matrix/.style={matrix of nodes,
  draw,thick,inner sep=0pt,
  nodes in empty cells,column sep=-0.2pt,row sep=-0.2pt,
  cells={nodes={minimum width=3em,minimum height=3em,
   draw,very thin,anchor=center,fill=codeshadecolor,
   execute at begin node={%
   $\vphantom{a_|}\ifnum\the\pgfmatrixcurrentrow<4
     \ifnum\the\pgfmatrixcurrentcolumn<4
      {#1}_{\the\pgfmatrixcurrentrow,\the\pgfmatrixcurrentcolumn}
     \else
      \ifnum\the\pgfmatrixcurrentcolumn=5
       {#1}_{\the\pgfmatrixcurrentrow,n}
      \fi
     \fi
    \else
     \ifnum\the\pgfmatrixcurrentrow=5
      \ifnum\the\pgfmatrixcurrentcolumn<4
       {#1}_{m, \the\pgfmatrixcurrentcolumn}
      \else
       \ifnum\the\pgfmatrixcurrentcolumn=5
        {#1}_{m,n}
       \fi
      \fi
     \fi
    \fi
    \ifnum\the\pgfmatrixcurrentrow\the\pgfmatrixcurrentcolumn=14
     \cdots
    \fi
    \ifnum\the\pgfmatrixcurrentrow\the\pgfmatrixcurrentcolumn=41
     \vdots
    \fi
    \ifnum\the\pgfmatrixcurrentrow\the\pgfmatrixcurrentcolumn=44
     \ddots
    \fi$
    }
  }}}]
 \matrix[auto matrix=a](matx){
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
 };
 \draw[thick,-stealth] ([yshift=-2ex]matx.south west) --
  ([yshift=-2ex]matx.south east) node[midway,below] {Columns or margin 2: $j = 1$ to $j = n$};
 \draw[thick,-stealth] ([xshift=-2ex]matx.north west)
   -- ([xshift=-2ex]matx.south west) node[midway,above,rotate=90] {Rows or margin 1: $i = 1$ to $i = m$};
\end{tikzpicture}
\end{footnotesize}\vspace{-1ex}
  \caption[Diagram of an \Rlang matrix.]{Diagram of an \Rlang matrix showing indexing of members.}\label{fig:matrix:margins}
\end{figure}

In \Rlang, the first index always denotes rows and the second index always denotes columns. The diagram below depicts a matrix, $A$, with $m$ rows and $n$ columns and size equal to $m \times n$ ``cells'', with individual values denoted by $a_{i,j}$. Here we use a simpler representation than that used for vectors on page \pageref{par:calc:vectors:diag} above, but the same concepts apply.

\begin{warningbox}
  In \Rlang documentation, the individual dimensions of matrices and arrays are frequently called \emph{margins}, numbered in the same order as the indices are given. Thus, in a matrix the first margin corresponds to rows and the second one to columns.
\end{warningbox}

In mathematical notation the same generic matrix is represented as
\begin{equation*}
  A_{m\times n} =
  \begin{bmatrix}
    a_{1,1} & a_{1,2} & \cdots & a_{1,j} & \cdots & a_{1,n}\\
    a_{2,1} & a_{2,2} & \cdots & a_{2,j} & \cdots & a_{2,n}\\
    \vdots & \vdots & \ddots & \vdots &        & \vdots \\
   a_{i,1} & a_{i,2} & \cdots & a_{i,j} & \cdots & a_{i,n}\\
     \vdots & \vdots &      & \vdots &  \ddots & \vdots \\
   a_{m,1} & a_{m,2} & \cdots & a_{m,j} & \cdots & a_{m,n}
  \end{bmatrix}
\end{equation*}
where $A$ represents the whole matrix, $m \times n$ its dimensions, and $a_{i,j}$ its elements, with $i$ indexing rows and $j$ indexing columns. The lengths of the two dimensions of the matrix are given by $m$ and $n$, for rows and columns.

Vectors have a single dimension, and, as described on page \pageref{par:calc:vectors:diag}, we can query this dimension, their length, with function \Rfunction{length()}. Matrices have two dimensions, which can be queried individually with \Rfunction{ncol()} and \Rfunction{nrow()}, and jointly with \Rfunction{dim()}. As expected, \Rfunction{is.matrix()} can be used to query the class.

We can create a matrix using the \Rfunction{matrix()} or \Rfunction{as.matrix()} constructors. The first argument of \Rfunction{matrix()} must be a vector. Function \Rfunction{as.matrix()} is a conversion constructor, with specialisations accepting as argument objects belonging to a few other classes. The shape of the \code{matrix} is controlled by passing an argument to either \code{ncol} or \code{nrow}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{15}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    6   11
## [2,]    2    7   12
## [3,]    3    8   13
## [4,]    4    9   14
## [5,]    5   10   15
\end{verbatim}
\begin{alltt}
\hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{15}\hlstd{,} \hlkwc{nrow} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    4    7   10   13
## [2,]    2    5    8   11   14
## [3,]    3    6    9   12   15
\end{verbatim}
\end{kframe}
\end{knitrout}

When a \code{matrix} is printed at the \Rlang console, the row and column indexes are indicated on the left and top margins, in the same way as they would be used to extract whole rows and columns.

\begin{explainbox}
  Matrices are most useful for the storage of numeric values as matrix algebra plays an important role in statistical computations. This notwithstanding, it is possible to create matrices (and arrays) from atomic vectors of other classes such as \Rclass{logical} or \Rclass{character}. The only difference is the scarcity of meaningful operations other than retrieval of members using two indices.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{matrix}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{15}\hlstd{],} \hlkwc{nrow} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,] "a"  "d"  "g"  "j"  "m" 
## [2,] "b"  "e"  "h"  "k"  "n" 
## [3,] "c"  "f"  "i"  "l"  "o"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

When a vector is converted to a matrix, \Rlang's default is to allocate the values in the vector to the matrix starting from the leftmost column, and within the column, down from the top. Once the first column is filled, the process continues from the top of the next column, as can be seen above. This order can be changed as you will discover in the playground below.

\begin{playground}
Check in the help page for the \code{matrix}\qRfunction{matrix()} constructor how to use the \code{byrow} parameter to alter the default order in which the elements of the vector are allocated to columns and rows of the new matrix.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{help}\hlstd{(matrix)}
\end{alltt}
\end{kframe}
\end{knitrout}

While you are looking at the help page, also consider the default number of columns and rows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{15}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

And to start getting a sense of how to interpret error and warning messages, run the code below and make sure you understand which problem is being reported. Before executing the statement, analyse it and predict what the returned value will be. Afterwards, compare your prediction with the value actually returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{15}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

Subscripting of matrices and arrays is consistent with that used for vectors; we only need to supply an indexing vector, or leave a blank space, for each dimension. A matrix has two dimensions, so to access an element or group of elements, we use two indices. The first index value selects rows, and the second one, columns.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{20}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{4}\hlstd{)}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 6
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{2}\hlstd{,} \hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}

Remind yourself of how indexing of vectors works in \Rlang (see section \ref{sec:vectors} on page \pageref{sec:vectors}). We will now apply the same rules in two dimensions to extract and replace values. The first or leftmost indexing vector corresponds to rows and the second one to columns, so \Rlang uses a rows-first convention for indexing. Missing indexing vectors are interpreted as meaning \emph{extract all rows} and \emph{extract all columns}, respectively.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1[}\hlnum{1}\hlstd{, ]}
\end{alltt}
\begin{verbatim}
## [1]  1  6 11 16
\end{verbatim}
\begin{alltt}
\hlstd{mat1[ ,} \hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4 5
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{2}\hlopt{:}\hlnum{3}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##      [,1] [,2]
## [1,]    2   12
## [2,]    3   13
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{3}\hlstd{,} \hlnum{4}\hlstd{]} \hlkwb{<-} \hlnum{99}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   99
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{4}\hlopt{:}\hlnum{3}\hlstd{,} \hlnum{2}\hlopt{:}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlstd{mat1[}\hlnum{3}\hlopt{:}\hlnum{4}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    9    4   13   99
## [4,]    8    3   14   19
## [5,]    5   10   15   20
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Vectors are simpler than matrices, and by default when possible the ``slice'' extracted from a matrix is simplified into a vector by dropping one dimension. By passing \code{drop = FALSE}, we can prevent this.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.matrix}\hlstd{(mat1[}\hlnum{1}\hlstd{, ])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.matrix}\hlstd{(mat1[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(mat1[}\hlnum{1}\hlstd{, ])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(mat1[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.matrix}\hlstd{(mat1[}\hlnum{1}\hlstd{, ,} \hlkwc{drop} \hlstd{=} \hlnum{FALSE}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.matrix}\hlstd{(mat1[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlkwc{drop} \hlstd{=} \hlnum{FALSE}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

Matrices, like vectors, can be assigned names that function as ``nicknames'' for indices for assignment and extraction. Matrices can have row names and/or column names.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{colnames}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlkwd{rownames}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlkwd{colnames}\hlstd{(mat1)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"c"}\hlstd{,} \hlstr{"d"}\hlstd{)}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      a  b  c  d
## [1,] 1  6 11 16
## [2,] 2  7 12 17
## [3,] 9  4 13 99
## [4,] 8  3 14 19
## [5,] 5 10 15 20
\end{verbatim}
\begin{alltt}
\hlkwd{rownames}\hlstd{(mat1)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"D"}\hlstd{,} \hlstr{"E"}\hlstd{)}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##   a  b  c  d
## A 1  6 11 16
## B 2  7 12 17
## C 9  4 13 99
## D 8  3 14 19
## E 5 10 15 20
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlkwd{c}\hlstd{(}\hlstr{"E"}\hlstd{,} \hlstr{"A"}\hlstd{,} \hlstr{"D"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##    b a
## E 10 5
## A  6 1
## D  3 8
\end{verbatim}
\begin{alltt}
\hlkwd{colnames}\hlstd{(mat1)} \hlkwb{<-} \hlkwa{NULL}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##   [,1] [,2] [,3] [,4]
## A    1    6   11   16
## B    2    7   12   17
## C    9    4   13   99
## D    8    3   14   19
## E    5   10   15   20
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
Matrices can be indexed as vectors, without triggering an error or warning.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{20}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{4}\hlstd{)}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## [1] 5 4
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{10}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 10
\end{verbatim}
\begin{alltt}
\hlstd{mat1[}\hlnum{5}\hlstd{,} \hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 10
\end{verbatim}
\end{kframe}
\end{knitrout}

The next code example demonstrates that indexing as a vector with a single index, always works column-wise even if matrix \code{B} was created by assigning vector elements by row.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat2} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{20}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{byrow} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{mat2}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
## [4,]   13   14   15   16
## [5,]   17   18   19   20
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(mat2)}
\end{alltt}
\begin{verbatim}
## [1] 5 4
\end{verbatim}
\begin{alltt}
\hlstd{mat2[}\hlnum{10}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 18
\end{verbatim}
\begin{alltt}
\hlstd{mat2[}\hlnum{5}\hlstd{,} \hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 18
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

\begin{explainbox}
In \Rlang, a \Rclass{matrix} can have a single row, a single column, a single element, or no elements. However, in all cases, a \code{matrix} will have as \emph{dimensions} attribute an \code{integer} vector of length two.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{6}
\hlkwd{dim}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{one.col.matrix} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{1}\hlstd{)}
\hlkwd{dim}\hlstd{(one.col.matrix)}
\end{alltt}
\begin{verbatim}
## [1] 6 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{two.col.matrix} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{)}
\hlkwd{dim}\hlstd{(two.col.matrix)}
\end{alltt}
\begin{verbatim}
## [1] 3 2
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{one.elem.matrix} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{1}\hlstd{)}
\hlkwd{dim}\hlstd{(one.elem.matrix)}
\end{alltt}
\begin{verbatim}
## [1] 1 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{no.elem.matrix} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlkwd{numeric}\hlstd{(),} \hlkwc{ncol} \hlstd{=} \hlnum{0}\hlstd{)}
\hlkwd{dim}\hlstd{(no.elem.matrix)}
\end{alltt}
\begin{verbatim}
## [1] 0 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{figure}
  \centering
%\usetikzlibrary{matrix}
\newcounter{kmargincount}
\begin{footnotesize}
\begin{tikzpicture}[auto matrix/.style={matrix of nodes,
  draw,thick,inner sep=0pt,
  nodes in empty cells,column sep=-0.2pt,row sep=-0.2pt,
  cells={nodes={minimum width=3.5em,minimum height=3.5em,
   draw,very thin,anchor=center,fill=codeshadecolor,
   execute at begin node={%
   $\vphantom{a_|}\ifnum\the\pgfmatrixcurrentrow<4
     \ifnum\the\pgfmatrixcurrentcolumn<4
      {#1}_{\the\pgfmatrixcurrentrow,\the\pgfmatrixcurrentcolumn,\arabic{kmargincount}}
     \else
      \ifnum\the\pgfmatrixcurrentcolumn=5
       {#1}_{\the\pgfmatrixcurrentrow,m,\arabic{kmargincount}}
      \fi
     \fi
    \else
     \ifnum\the\pgfmatrixcurrentrow=5
      \ifnum\the\pgfmatrixcurrentcolumn<4
       {#1}_{l, \the\pgfmatrixcurrentcolumn,\arabic{kmargincount}}
      \else
       \ifnum\the\pgfmatrixcurrentcolumn=5
        {#1}_{l,m,\arabic{kmargincount}}
       \fi
      \fi
     \fi
    \fi
    \ifnum\the\pgfmatrixcurrentrow\the\pgfmatrixcurrentcolumn=14
     \cdots
    \fi
    \ifnum\the\pgfmatrixcurrentrow\the\pgfmatrixcurrentcolumn=41
     \vdots
    \fi
    \ifnum\the\pgfmatrixcurrentrow\the\pgfmatrixcurrentcolumn=44
     \ddots
    \fi$
    }
  }}}]
\setcounter{kmargincount}{4}
 \matrix[auto matrix=a,xshift=7.5em,yshift=7.5em](matback){
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
 };
\setcounter{kmargincount}{3}
 \matrix[auto matrix=a,xshift=5em,yshift=5em](matz){
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
 };
\setcounter{kmargincount}{2}
 \matrix[auto matrix=a,xshift=2.5em,yshift=2.5em](maty){
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
 };
\setcounter{kmargincount}{1}
 \matrix[auto matrix=a](matx){
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
  & & & & \\
 };
 \draw[thick,-stealth] ([xshift=2ex]matx.south east) -- ([xshift=2ex]matback.south east)
  node[midway,below,rotate=45] {Margin 3: $k = 1$ to $k = n$};
 \draw[thick,-stealth] ([yshift=-2ex]matx.south west) --
  ([yshift=-2ex]matx.south east) node[midway,below] {Margin 2: $j = 1$ to $j = m$};
 \draw[thick,-stealth] ([xshift=-2ex]matx.north west)
   -- ([xshift=-2ex]matx.south west) node[midway,above,rotate=90] {Margin 1: $i = 1$ to $i = l$};
\end{tikzpicture}
\end{footnotesize}\vspace{-1ex}
  \caption[Diagram of an \Rlang array.]{Diagram of an \Rlang array with three dimensions showing indexing of members.}\label{fig:array:margins}
\end{figure}

Arrays\index{matrix!dimensions}\index{arrays!dimensions} are similar to matrices, but can have one or more dimensions (Figure \ref{fig:array:margins}). The dimensions of an array can be queried with \Rfunction{dim()}, similarly as with matrices. Whether an \Rlang object is an array can be found out with \Rfunction{is.array()}. The diagram below depicts an array, $A$ with three dimensions giving a size equal to $l\times m \times n$, and individual values denoted by $a_{i,j,k}$.

When calling the constructor \Rfunction{array()}, dimensions are specified with the argument passed to parameter \code{dim}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{ary1} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{27}\hlstd{,} \hlkwc{dim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{3}\hlstd{))}
\hlstd{ary1}
\end{alltt}
\begin{verbatim}
## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]   10   13   16
## [2,]   11   14   17
## [3,]   12   15   18
## 
## , , 3
## 
##      [,1] [,2] [,3]
## [1,]   19   22   25
## [2,]   20   23   26
## [3,]   21   24   27
\end{verbatim}
\begin{alltt}
\hlstd{ary1[}\hlnum{2}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 14
\end{verbatim}
\end{kframe}
\end{knitrout}

In the chunk above, the length of the supplied vector is the product of the dimensions, $27 = 3 \times 3 \times 3 = 3^3$. Arrays are printed in slices, where slices across 3rd and higher dimensions are shown separately, with their corresponding indexes above each slice and the first two dimensions on the margins of the individual slices, similarly to how matrices are displayed.

\begin{playground}
  How do you use indexes to extract the second element of the original vector, in each of the following matrices and arrays?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{VCT2} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{MAT1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(VCT2,} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{)}
\hlstd{MAT2} \hlkwb{<-} \hlkwd{matrix}\hlstd{(VCT2,} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{byrow} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{MAT3} \hlkwb{<-} \hlkwd{matrix}\hlstd{(VCT2,} \hlkwc{nrow} \hlstd{=} \hlnum{2}\hlstd{)}
\hlstd{MAT4} \hlkwb{<-} \hlkwd{matrix}\hlstd{(VCT2,} \hlkwc{nrow} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{byrow} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{ARY1} \hlkwb{<-} \hlkwd{array}\hlstd{(VCT2,} \hlkwc{dim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,} \hlnum{2}\hlstd{))}
\hlstd{ARY2} \hlkwb{<-} \hlkwd{array}\hlstd{(VCT2,} \hlkwc{dim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,} \hlnum{2}\hlstd{),} \hlkwc{dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwa{NULL}\hlstd{,} \hlkwd{c}\hlstd{(}\hlstr{"c1"}\hlstd{,} \hlstr{"c2"}\hlstd{)))}
\hlstd{ARY3} \hlkwb{<-} \hlkwd{array}\hlstd{(VCT2,} \hlkwc{dim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Be aware that vectors and one-dimensional arrays are not the same thing, while two-dimensional arrays are matrices.
\begin{enumerate}
  \item Use the different constructors and query functions to explore this, and its consequences.
  \item Convert a matrix into a vector using \Rfunction{as.vector()} and compare the returned values to those in the matrix. Are values extracted by columns or by rows first?
\end{enumerate}
\end{playground}
\index{arrays|)}

\index{matrix!operators|(}
Operators and functions for matrix algebra are available in \Rlang as matrices are used in statistical algorithms. I describe below only some of these matrix-specific functions and operators. I also give examples of the use of some of the usual arithmetic operators together with objects of class \Rclass{matrix}.

Recycling applies to the usual arithmetic operators when applied to matrices. This is similar to their behaviour when all operands are vectors (see page \pageref{par:recycling:numeric}).\index{matrix!operations with vectors}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat3} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{20}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{4}\hlstd{)}
\hlstd{mat3} \hlopt{+} \hlnum{2}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    3    8   13   18
## [2,]    4    9   14   19
## [3,]    5   10   15   20
## [4,]    6   11   16   21
## [5,]    7   12   17   22
\end{verbatim}
\begin{alltt}
\hlstd{mat3} \hlopt{*} \hlnum{0}\hlopt{:}\hlnum{1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    0    6    0   16
## [2,]    2    0   12    0
## [3,]    0    8    0   18
## [4,]    4    0   14    0
## [5,]    0   10    0   20
\end{verbatim}
\begin{alltt}
\hlstd{mat3} \hlopt{*} \hlnum{1}\hlopt{:}\hlnum{0}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    0   11    0
## [2,]    0    7    0   17
## [3,]    3    0   13    0
## [4,]    0    9    0   19
## [5,]    5    0   15    0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  When a \code{matrix} and a \code{vector} are operands in an arithmetic operation, how the positions of the \code{vector} are mapped to positions in the \code{matrix} affects the result of the operation. Run the code below to find out. What is the logic behind?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{matrix}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{6}\hlstd{))} \hlopt{*} \hlnum{1}\hlopt{:}\hlnum{6}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

Function \Rfunction{t()} transposes\index{matrix!transpose} a matrix, by swapping columns and rows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat3}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}
\begin{alltt}
\hlkwd{t}\hlstd{(mat3)}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2    3    4    5
## [2,]    6    7    8    9   10
## [3,]   11   12   13   14   15
## [4,]   16   17   18   19   20
\end{verbatim}
\end{kframe}
\end{knitrout}

In the examples above with the usual multiplication operator \code{*}, the operation described is not a matrix product, but instead, the products between individual elements of the matrix and vectors. Operators and functions implementing the operations of matrix algebra are distinct. Matrix algebra gives the rules for operations where both operands are matrices. For example, matrix multiplication is indicated by the operator \Roperator{\%*\%}. \index{matrix!multiplication}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat4} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{16}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{4}\hlstd{)}
\hlstd{mat4} \hlopt{*} \hlstd{mat4}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1   25   81  169
## [2,]    4   36  100  196
## [3,]    9   49  121  225
## [4,]   16   64  144  256
\end{verbatim}
\begin{alltt}
\hlstd{mat4} \hlopt{%*%} \hlstd{mat4}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]   90  202  314  426
## [2,]  100  228  356  484
## [3,]  110  254  398  542
## [4,]  120  280  440  600
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{diag()} makes it possible to easily create a diagonal matrix.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat5} \hlkwb{<-} \hlkwd{diag}\hlstd{(}\hlnum{4}\hlstd{)}
\hlstd{mat5}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    1    0    0
## [3,]    0    0    1    0
## [4,]    0    0    0    1
\end{verbatim}
\begin{alltt}
\hlstd{mat4} \hlopt{%*%} \hlstd{mat5}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    5    9   13
## [2,]    2    6   10   14
## [3,]    3    7   11   15
## [4,]    4    8   12   16
\end{verbatim}
\end{kframe}
\end{knitrout}

The inverse of a matrix can be found by means of function \Rfunction{solve()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat6} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{0}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{7}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{4}\hlstd{),} \hlkwc{ncol} \hlstd{=} \hlnum{3}\hlstd{)}
\hlkwd{solve}\hlstd{(mat6)}
\end{alltt}
\begin{verbatim}
##             [,1]       [,2]       [,3]
## [1,]  0.18181818  0.2272727 -0.4318182
## [2,] -0.18181818  0.2727273  0.1818182
## [3,]  0.09090909 -0.1363636  0.1590909
\end{verbatim}
\end{kframe}
\end{knitrout}

Additional operators and functions for matrix algebra like cross-product (\code{crossprod()}) and Cholesky root (\code{chol()}) are available in base \Rlang. Packages, including \pkgname{matrixStats}, provide additional functions and operators for matrices.



\index{matrices|)}

\section{Factors}\label{sec:calc:factors}
\index{factors|(}
\index{categorical variables|see{factors}}\qRclass{factor}

In data analysis and Statistics, the distinction between values measured on continuous vs.\ discrete \emph{scales} is crucial. In a continuous scale, any values are in theory possible. In a discrete scale, the observations are values from a few categories.

In contrast to other statistical software in which a variable is set as continuous or discrete when defining a model to be fitted or when setting up a test, in \Rlang this distinction is based on whether the explanatory variable is \code{numeric} (continuous) or a \code{factor} (discrete). This approach makes sense because in most cases considering an explanatory variable as categorical or not, depends on the quantity stored and/or the design of the experiment or survey. In other words, being categorical is a property of the data. The order of the levels in an unordered \code{factor} does not affect simple calculations or the values plotted, but as we will see in chapters \ref{chap:R:statistics} and \ref{chap:R:plotting}, it can affect the contrasts used by some tests of significance, and the arrangement or positions of the levels along axes and keys in plots.

In an \Rlang \code{factor}, values indicate discrete unordered categories, most frequently the treatments in an experiment, or categories in a survey. Factor can be created either from numerical or character vectors. The different possible values are called \emph{levels}. Factors created with \Rfunction{factor()} are always unordered or categorical. \Rlang also supports \code{ordered} factors, created with function \Rfunction{ordered()} with identical user interface. The distinction, however, only affects how they are interpreted in statistical tests as discussed in chapter \ref{chap:R:statistics}.\index{factors!ordered}

When using \Rfunction{factor()} or \Rfunction{ordered()} we create a factor from a vector, but this vector can be created on-the-fly and anonymous as shown in this example. When the vector is \code{numeric} and no labels are supplied, level labels are character strings matching the numbers. The default ordering of the levels is alphanumerical.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 1 2 2 1 2 1 1
## Levels: 1 2
\end{verbatim}
\begin{alltt}
\hlkwd{ordered}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 1 2 2 1 2 1 1
## Levels: 1 < 2
\end{verbatim}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1}\hlstd{),} \hlkwc{ordered} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1 2 2 1 2 1 1
## Levels: 1 < 2
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
When the pattern of levels is regular, it is possible to use function \Rfunction{gl()}, \emph{generate levels}, to construct a factor. Nowadays, it is usual to read data into \Rlang from files in which the treatment codes are already available as character strings or numeric values, however, when we need to create a factor within \Rlang, \Rfunction{gl()} can save some typing. In this case, instead of passing a vector as argument, we pass a \emph{recipe} to create it: \code{n} is the number of levels, \code{k} the number of contiguous repeats (called ``replicates'' in \Rlang documentation), and \code{length} the length of the factor to be created.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gl}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{k} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1] A A A A A B B B B B
## Levels: A B
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{gl}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{k} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{length} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1] A B A B A B A B A B
## Levels: A B
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

It is always preferable to use meaningful labels for levels, even if \Rlang does not require it. Here the vector is stored in a variable named \code{my.vector}. In a real data analysis situation, in most cases, the vector would have been read from a file on disk and would be longer.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"treated"}\hlstd{)}
\hlkwd{factor}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: control treated
\end{verbatim}
\end{kframe}
\end{knitrout}

The ordering of levels is established at the time a factor is created and by default it is alphabetical. This default ordering of levels is frequently not the one needed. We can pass an argument to parameter \code{levels} of function \Rfunction{factor()} to set a different ordering of the levels.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{= vct1,} \hlkwc{levels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: treated control
\end{verbatim}
\end{kframe}
\end{knitrout}

The\index{factors!labels}\index{factors!levels} labels (``names'') of the levels can be set when calling \Rfunction{factor()}. Two vectors are passed as arguments to parameters \code{levels} and \code{labels} with levels and matching labels in the same position. The argument passed to \code{levels} determines the order of the levels based on their old names or values, and the argument passed to \code{labels} gives new names to the levels.\label{par:calc:factor:rename:levels}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{),} \hlkwc{levels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{),} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: treated control
\end{verbatim}
\end{kframe}
\end{knitrout}

The argument passed to \code{labels} can be a named vector that \emph{maps} new labels onto the values stored in the vector passed as the argument to \code{x} (see named vectors and mapping on page \pageref{par:calc:vector:map}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"b"}\hlstd{,} \hlstr{"a"}\hlstd{),} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{a} \hlstd{=} \hlstr{"treated"}\hlstd{,} \hlkwc{b} \hlstd{=} \hlstr{"control"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: treated control
\end{verbatim}
\end{kframe}
\end{knitrout}

In the examples above, we passed a numeric vector or a character vector as an argument for parameter \code{x} of function \Rfunction{factor()}. It is also possible to pass a \code{factor} as an argument to parameter \code{x}. This makes it possible to modify the ordering of levels or replace the labels in a factor.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct1} \hlkwb{<-} \hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{= vct1)}
\hlstd{fct1}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: control treated
\end{verbatim}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{= fct1,} \hlkwc{levels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: treated control
\end{verbatim}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{= fct1,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{control} \hlstd{=} \hlstr{"cooled"}\hlstd{,} \hlkwc{treated} \hlstd{=} \hlstr{"heated"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] heated heated cooled cooled cooled heated
## Levels: cooled heated
\end{verbatim}
\begin{alltt}
\hlkwd{factor}\hlstd{(}\hlkwc{x} \hlstd{= fct1,}
       \hlkwc{levels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{),}
       \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"heated"}\hlstd{,} \hlstr{"cooled"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] heated heated cooled cooled cooled heated
## Levels: heated cooled
\end{verbatim}
\end{kframe}
\end{knitrout}

\textbf{Merging factor levels.}\index{factors!merge levels} We use \Rfunction{factor()} as shown below, setting the same label for the levels we want to merge.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct2} \hlkwb{<-} \hlkwd{gl}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"F"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"Z"}\hlstd{))}
\hlstd{fct2}
\end{alltt}
\begin{verbatim}
##  [1] A A A F F F B B B Z Z Z
## Levels: A F B Z
\end{verbatim}
\begin{alltt}
\hlkwd{factor}\hlstd{(fct2,}
       \hlkwc{levels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"F"}\hlstd{,} \hlstr{"Z"}\hlstd{),}
       \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{,} \hlstr{"C"}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1] A A A C C C B B B C C C
## Levels: A B C
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  Edit the code in the chunk above to use only a named vector for \code{labels} instead of separate vectors passed to \code{levels} and \code{labels}.
\end{playground}

We can use indexing on factors in the same way as with vectors. In the next example, we use a test returning a logical vector to extract all ``controls''. We use function \Rfunction{levels()} to look at the levels of the factors, as with vectors, \code{lengtgh()} to query the number of values stored.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct1}
\end{alltt}
\begin{verbatim}
## [1] treated treated control control control treated
## Levels: control treated
\end{verbatim}
\begin{alltt}
\hlkwd{levels}\hlstd{(fct1)}
\end{alltt}
\begin{verbatim}
## [1] "control" "treated"
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(fct1)}
\end{alltt}
\begin{verbatim}
## [1] 6
\end{verbatim}
\begin{alltt}
\hlstd{fct1.control} \hlkwb{<-} \hlstd{fct1[fct1} \hlopt{==} \hlstr{"control"}\hlstd{]}
\hlstd{fct1.control}
\end{alltt}
\begin{verbatim}
## [1] control control control
## Levels: control treated
\end{verbatim}
\begin{alltt}
\hlkwd{levels}\hlstd{(fct1.control)} \hlcom{# same as in my.factor}
\end{alltt}
\begin{verbatim}
## [1] "control" "treated"
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(fct1.control)} \hlcom{# shorter than my.factor}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{faqbox}{How to drop unused levels in a factor?}
  It can be seen above that subsetting does not drop unused factor levels. Constructor function \code{factor()} can be used to explicitly drop the unused factor levels.\index{factors!drop unused levels}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct1.control} \hlkwb{<-} \hlkwd{factor}\hlstd{(fct1.control)}
\hlkwd{levels}\hlstd{(fct1.control)} \hlcom{# the unused level was dropped}
\end{alltt}
\begin{verbatim}
## [1] "control"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

\begin{faqbox}{How to convert a factor into a vector with matching values?}
This operation is not obvious, specially when the factor was created from a \code{numeric} vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct3} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{3}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{4}\hlstd{)}
\hlstd{vct3}
\end{alltt}
\begin{verbatim}
##  [1] 3 4 5 3 4 5 3 4 5 3 4 5
\end{verbatim}
\begin{alltt}
\hlstd{fct3} \hlkwb{<-} \hlkwd{factor}\hlstd{(vct3)}
\hlstd{fct3}
\end{alltt}
\begin{verbatim}
##  [1] 3 4 5 3 4 5 3 4 5 3 4 5
## Levels: 3 4 5
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(fct3)}
\end{alltt}
\begin{verbatim}
##  [1] 1 2 3 1 2 3 1 2 3 1 2 3
\end{verbatim}
\begin{alltt}
\hlkwd{as.numeric}\hlstd{(}\hlkwd{as.character}\hlstd{(fct3))}
\end{alltt}
\begin{verbatim}
##  [1] 3 4 5 3 4 5 3 4 5 3 4 5
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

\begin{explainbox}
\textbf{Why is a double conversion needed?}\index{factors!convert to numeric} Internally, factor values are stored as running integers starting from one, each distinct integer value corresponding to a level. These underlying integer values are returned by \Rfunction{as.numeric()} when applied to a factor. The labels of the factor levels are always stored as character strings, even when these characters are digits. In contrast to \Rfunction{as.numeric()}, \Rfunction{as.character()} returns the character labels of the levels for each of the values stored in the factor. If these character strings represent numbers, they can be converted, in a second step, using \Rfunction{as.numeric()} into the original numeric values. Use of \code{class} and \code{mode} is described on section \ref{sec:rlang:mode} on page \pageref{sec:rlang:mode}, and \code{str()} on page \pageref{par:calc:str}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(fct3)}
\end{alltt}
\begin{verbatim}
## [1] "factor"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(fct3)}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(fct3)}
\end{alltt}
\begin{verbatim}
##  Factor w/ 3 levels "3","4","5": 1 2 3 1 2 3 1 2 3 1 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{playground}
Create a factor with levels labelled with words. Create another factor with the levels labelled with the same words, but ordered differently. After this convert both factors to numeric vectors using \Rfunction{as.numeric()}. Explain why the two numeric vectors differ or not from each other.
\end{playground}

\begin{explainbox}
\textbf{Safely reordering and renaming factor levels.}\index{factors!reorder levels} The simplest approach is to use \Rfunction{factor()} and its \code{levels} parameter as shown on page \pageref{par:calc:factor:rename:levels}. In these more advanced examples, we use \Rfunction{levels()} to retrieve the names of the levels from the factor itself to protect from possible bugs due to typing mistakes, or for changes in the naming conventions used.

Reverse previous order using \Rfunction{rev()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct4} \hlkwb{<-} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"treated"}\hlstd{,} \hlstr{"treated"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"control"}\hlstd{,} \hlstr{"treated"}\hlstd{))}
\hlkwd{levels}\hlstd{(fct4)}
\end{alltt}
\begin{verbatim}
## [1] "control" "treated"
\end{verbatim}
\begin{alltt}
\hlstd{fct4} \hlkwb{<-} \hlkwd{factor}\hlstd{(fct4,} \hlkwc{levels} \hlstd{=} \hlkwd{rev}\hlstd{(}\hlkwd{levels}\hlstd{(fct4)))}
\hlkwd{levels}\hlstd{(fct4)}
\end{alltt}
\begin{verbatim}
## [1] "treated" "control"
\end{verbatim}
\end{kframe}
\end{knitrout}
\pagebreak

Sort in decreasing order, i.e., opposite to default.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct5} \hlkwb{<-} \hlkwd{factor}\hlstd{(fct4,}
               \hlkwc{levels} \hlstd{=} \hlkwd{sort}\hlstd{(}\hlkwd{levels}\hlstd{(fct4),} \hlkwc{decreasing} \hlstd{=} \hlnum{TRUE}\hlstd{))}
\hlkwd{levels}\hlstd{(fct5)}
\end{alltt}
\begin{verbatim}
## [1] "treated" "control"
\end{verbatim}
\end{kframe}
\end{knitrout}

Alter ordering using subscripting; especially useful with three or more levels.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct6} \hlkwb{<-} \hlkwd{factor}\hlstd{(fct4,} \hlkwc{levels} \hlstd{=} \hlkwd{levels}\hlstd{(fct4)[}\hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{1}\hlstd{)])}
\hlkwd{levels}\hlstd{(fct6)}
\end{alltt}
\begin{verbatim}
## [1] "control" "treated"
\end{verbatim}
\end{kframe}
\end{knitrout}

Reordering the levels of a factor based on summary quantities from data stored in a numeric vector is very useful, especially when plotting. Function \Rfunction{reorder()} can be used in this case. It defaults to using \code{mean()} for summaries, but other suitable summary functions, such as \code{median()} can be supplied in its place.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fct7} \hlkwb{<-} \hlkwd{gl}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\hlstd{vct4} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{5.6}\hlstd{,} \hlnum{7.3}\hlstd{,} \hlnum{3.1}\hlstd{,} \hlnum{8.7}\hlstd{,} \hlnum{6.9}\hlstd{,} \hlnum{2.4}\hlstd{,} \hlnum{4.5}\hlstd{,} \hlnum{2.1}\hlstd{,} \hlnum{1.4}\hlstd{,} \hlnum{2.0}\hlstd{)}
\hlstd{fct7}
\end{alltt}
\begin{verbatim}
##  [1] A A A A A B B B B B
## Levels: A B
\end{verbatim}
\begin{alltt}
\hlstd{fct7ord} \hlkwb{<-} \hlkwd{reorder}\hlstd{(fct7, vct4)}
\hlkwd{levels}\hlstd{(fct7ord)}
\end{alltt}
\begin{verbatim}
## [1] "B" "A"
\end{verbatim}
\begin{alltt}
\hlstd{fct7rev} \hlkwb{<-} \hlkwd{reorder}\hlstd{(fct7,} \hlopt{-}\hlstd{vct4)} \hlcom{# a simple trick: change sign}
\hlkwd{levels}\hlstd{(fct7rev)}
\end{alltt}
\begin{verbatim}
## [1] "A" "B"
\end{verbatim}
\end{kframe}
\end{knitrout}

In the last statement, using the unary negation operator, which is vectorised, allows us to easily reverse the ordering of the levels, while still using the default function, \code{mean()}, to summarise the data.

\end{explainbox}

\begin{advplayground}\label{calc:ADVPG:order:sort}
\textbf{Reordering factor values.}\index{factors!reorder values}\index{factors!arrange values} It is possible to arrange the values stored in a factor either alphabetically according to the labels of the levels or according to the order of the levels. (The use of \code{rep()} is explained on page \pageref{pg:seq:rep}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# gl() keeps order of levels}
\hlstd{FCT1} \hlkwb{<-} \hlkwd{gl}\hlstd{(}\hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"F"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"Z"}\hlstd{))}
\hlstd{FCT1}
\hlkwd{as.integer}\hlstd{(FCT1)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# factor() orders levels alphabetically}
\hlstd{FCT2} \hlkwb{<-} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"F"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"Z"}\hlstd{),} \hlkwc{times} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{3}\hlstd{,} \hlkwc{times} \hlstd{=} \hlnum{4}\hlstd{)))} \hlcom{# nested calls}
\hlstd{FCT2}
\hlkwd{as.integer}\hlstd{(FCT2)}
\hlkwd{levels}\hlstd{(FCT2)[}\hlkwd{as.integer}\hlstd{(FCT2)]}
\end{alltt}
\end{kframe}
\end{knitrout}

We see above that the integer values by which levels in a factor are stored, are equivalent to indices or ``subscripts'' referencing the vector of labels. Function \Rfunction{sort()} operates on the values' underlying integers and sorts according to the order of the levels while \Rfunction{order()} operates on the values' labels and returns a vector of indices that arrange the values alphabetically.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sort}\hlstd{(FCT2)}
\hlstd{FCT2[}\hlkwd{order}\hlstd{(FCT2)]}
\hlstd{FCT2[}\hlkwd{order}\hlstd{(}\hlkwd{as.integer}\hlstd{(FCT2))]}
\end{alltt}
\end{kframe}
\end{knitrout}

Run the examples in the chunk above and work out why the results differ.
\end{advplayground}

\begin{explainbox}
  Factors encode levels as \code{integer} values in a vector. In many cases, statistical computations, require the same information to be encoded as binary values using multiple \emph{dummy variables}. Factors are much friendlier for the user to manage. They are converted into the equivalent dummy variables when a model formula is translated into a \emph{model matrix}. This is handled transparently by most functions implementing fitting of statistical models to data (see sections \ref{sec:stat:mf} and \ref{sec:stat:formulas} on pages \pageref{sec:stat:mf} and \pageref{sec:stat:formulas}).
\end{explainbox}
\index{factors|)}


% !Rnw root = appendix.main.Rnw



\section{Further Reading}
For\index{further reading!using the R language} further reading on the aspects of \Rlang discussed in the current chapter, I suggest the book \citetitle{Matloff2011} \autocite{Matloff2011}.







% !Rnw root = appendix.main.Rnw



\chapter{Base \Rlang: ``Collective Nouns''}\label{chap:R:collective}

\begin{VF}
The information that is available to the computer consists of a selected set of \emph{data} about the real world, namely, that set which is considered relevant to the problem at hand, that set from which it is believed that the desired results can be derived. The data represent an abstraction of reality\ldots

\VA{Niklaus Wirth}{\emph{Algorithms $+$ Data Structures $=$ Programs}, 1976}\nocite{Wirth1976}
\end{VF}

\section{Aims of This Chapter}

Data set organisation and storage is one of the keys to efficient data analysis. How to keep together all the information that belongs together, say all measurements from an experiment and corresponding metadata such as treatments applied and/or dates. The title ``collective nouns'' is based on the idea that a data set is a collection of data objects.

In this chapter, you will familiarise with how data sets are usually managed in \Rlang. I use both abstract examples to emphasise the general properties of data sets and the \Rlang classes available for their storage and a few more specific examples to exemplify their use in a more concrete way. While in chapter \ref{chap:R:as:calc} the focus was on atomic data types and objects, like vectors, useful for the storage of collections of values of a given type, like numbers, in the present chapter the focus is on the storage within a single object of heterogeneous data, such as a combination of factors, and character and numeric vectors. Broadly speaking, heterogeneous \emph{data containers}.

To describe the structure of \Rlang objects I use diagrams similar to those in the previous chapter.

\index{data sets!their storage|(}

\section{Data from Surveys and Experiments}
\index{data sets!origin}\index{data sets!characteristics}
The data we plot, summarise, and analyse in \Rlang, in most cases, originate from measurements done as part of experiments or surveys. Data collected mechanically from user interactions with websites or by crawling through internet content originate from a statistical perspective from surveys. The value of any data comes from knowing their origin, say treatments applied to plants, or the country from where website users connect; sometimes several properties are of interest to describe the origin of the data and in other cases observations consist in the measurement of multiple properties on each subject under study. Consequently, all software designed for data analysis implements ways of dealing with data sets as a whole both during storage and when passing them as arguments to functions. A data set is a usually heterogeneous collection of data with related information.

In \Rlang, lists are the most flexible type of objects useful for storing whole data sets. In most cases, we do not need this much flexibility, so rectangular collections of observations are most frequently stored in a variation upon lists called data frames. These objects can have as their members the vectors and factors described in chapter \ref{chap:R:as:calc}.

Any \Rlang object can have attributes, allowing objects to carry along additional bits of information. Some like comments are part of \Rlang and aimed at storage of ancillary information or metadata by users. Other attributes are used internally by \Rlang and finally users can store arbitrary ancillary data using attributes created \emph{ad hoc}.

\section{Lists}\label{sec:calc:lists}
\index{lists|(}\qRclass{list}
In \Rlang, \Rclass{list} objects are in several respects similar the vectors described in chapter \ref{chap:R:as:calc} but differently to vectors, the members they contain can be heterogeneous, i.e., different members of the same list can belong to different classes. In addition, while the member elements of a vector must be \emph{atomic} values like numbers or character strings, any \Rlang object can be a list member including other lists.

In \Rlang, the members of a list can be considered as following a sequence, and accessible through numerical indexes, the same as the members of vectors. Members of a list as well as members of a vector can be named, and retrieved (indexed) through their names. In practice, named lists are more frequently used than named vectors. \Rlang lists are created, or constructed, with function \Rfunction{list()} similarly as vectors are constructed with function \Rfunction{c()}.

\begin{explainbox}
  \Rlang lists can have as members not only objects storing data on observations and categories, but also function definitions, model formulas, unevaluated expressions, matrices, arrays, and objects of user-defined classes.
\end{explainbox}

\begin{explainbox}
List and list-like objects are widely used in \Rlang because they make it possible to keep, for example, the data, instructions for operations, and results from operations together in a single \Rlang object that can be saved, copied, etc. as a unit. This avoids the proliferation of multiple disconnected objects with their interrelations being encoded only by their names, or even worse in separate notes or even in a person's memory---all approaches that are error-prone. Model fit functions described in chapter \ref{chap:R:statistics} are good examples of this approach. Objects used to store the instructions to build plots with multiple layers as described in chapter \ref{chap:R:plotting} are also good examples.
\end{explainbox}

Our first list has as its members three different vectors, each one belonging to a different class: \code{numeric}, \code{character} and \code{logical}. The three vectors also differ in their length: 6, 1, and 2, respectively.\qRfunction{list()}\qRfunction{names()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"ab"}\hlstd{,} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(lst1)}
\end{alltt}
\begin{verbatim}
## List of 3
##  $ x: int [1:3] 1 2 3
##  $ y: chr "ab"
##  $ z: logi [1:2] TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(lst1)}
\end{alltt}
\begin{verbatim}
## [1] "x" "y" "z"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily, my shape/.style={
  rectangle split, rectangle split parts=#1, draw, anchor=north, minimum size=12mm},
array/.style={matrix of nodes,nodes={draw, minimum size=1mm, fill=black},column sep=2pt, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=1mm}}}]

\matrix[array] (array) {
1 & 2 & 3 \\
\rule{10mm}{.1pt} & \rule{10mm}{.1pt} & \rule{10mm}{.1pt}\\};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-3.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\code{\strut lst1}};
\draw (array-2-1.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-11.5mm, yshift=-2.7mm, above] (nameh) {\rotatebox{90}{x\strut}};
\draw (array-2-2.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-11.5mm, yshift=-2.7mm, above] (namec) {\rotatebox{90}{y\strut}};
\draw (array-2-3.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-11.5mm, yshift=-2.7mm, above] (namew) {\rotatebox{90}{z\strut}};
%\draw (array-1-2.north)--++(90:3mm) node [above] (first) {Index};
\draw (array-1-3.east)--++(0:12.5mm) node [right]{\code{integer} positional indices};
\draw (array-2-3.east)--++(0:8mm) node [right]{\textsl{heterogeneous} class, \textsl{varying} length};
\draw (namew)--++(0:15mm) node [right]{\code{character} member names};
%
  \node [my shape=3, rectangle split, fill=blue!20] at (-1.3,-.25)
    {1\strut\nodepart{two}2\strut\nodepart{three}3\strut};
  \node [my shape=1, fill=red!20] at (0,-.25)
    {``ab''\strut};
  \node [my shape=2, fill=yellow!20] at (1.3,-.25)
    {TRUE\strut\nodepart{two}FALSE\strut};
%\draw (-0.6,+0.65) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\code{\strut lst1}};
\end{tikzpicture}
\end{footnotesize}
\end{center}

\begin{warningbox}
  It is best to use informative names for accessing \code{list} members, as their members are heterogenous, usually containing loosely related/connected data. Names make code easier to understand and mistakes more visible. Using names also makes code more robust to future changes in the position of list members in lists created upstream of our own \Rlang code. Below, we use both positional indices and names to highlight the similarities between lists and vectors.
\end{warningbox}

Lists can behave as vectors with heterogeneous elements as members, as we will describe next. Lists can also be nested, so tree-like structures are also possible (see section \ref{sec:calc:lists:nested} on page \pageref{sec:calc:lists:nested}).

%{ \tikzstyle{every node}=[draw=black,thick,anchor=west,fill=blue!10]
% \tikzstyle{root}=[dashed,fill=gray!50]
%\sffamily
%\centering
%\footnotesize
%\begin{tikzpicture}[%
%  grow via three points={one child at (0.5,-0.55) and
%  two children at (0.5,-0.55) and (0.5,-1.1)},
%  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
%  \node [root] {lst1}
%      child { node {\$ x: int [1:6] 1 2 3 4 5 6}}
%      child { node {\$ y: chr "a"}}
%      child { node {\$ z: logi [1:2] TRUE FALSE}};
%\end{tikzpicture}
%}

\begin{faqbox}{How to create an empty list?}
  In the same way as \code{numeric()} by default creates a \code{numeric} vector of length zero, \Rfunction{list()} by default creates a \code{list} object with no members.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{list}\hlstd{()}
\end{alltt}
\begin{verbatim}
## list()
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

\subsection{Member extraction, deletion and insertion}

In\index{lists!member extraction|(}\index{lists!member indexing|see{lists, member extraction}}\index{lists!deletion and addition of members|(} section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}, we saw that the extraction operator \Roperator{[ ]} applied to a vector, returns a vector, longer or shorter, possibly of length one, or even length zero. Similarly, applying operator \Roperator{[ ]} to a list returns a list, possibly of different length: \code{lst1["x"]} or \code{lst[1]} return a list containing only one member, the numeric vector stored at the first position of \code{lst1}. In the last statement in the chunk below, \code{lst1[c(1, 3)]} returns a list of length two as expected.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1[}\hlstr{"x"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlstd{lst1[}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlstd{lst1[}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{3}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

As with vectors negative positional indices remove members instead of extracting them. See page \pageref{par:calc:lists:rm} for a safer approach to the deletion of list members.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1[}\hlopt{-}\hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## $y
## [1] "ab"
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{lst1[}\hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{1}\hlstd{,} \hlopt{-}\hlnum{3}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## $y
## [1] "ab"
\end{verbatim}
\end{kframe}
\end{knitrout}

Using operator \Roperator{[[ ]]} (double square brackets) for indexing a list extracts the element stored in the list, in its original mode. In the example below, \code{lst1[["x"]]} and \code{lst1[[1]]} return a numeric vector. We might say that extraction operator \Roperator{[[ ]]} reaches ``deeper'' into the list than operator \Roperator{[ ]}. Operator \Roperator{\$}, used in the second statement below, provides a shorthand notation, equivalent to calling \Roperator{[[ ]]} with a single constant \code{character} value as argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1}\hlopt{$}\hlstd{x}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlstd{lst1[[}\hlstr{"x"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\begin{alltt}
\hlstd{lst1[[}\hlnum{1}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}\label{box:extraction:opers}
We mentioned above that indexing by name can be done either with double square brackets, \Roperator{[[ ]]}, or with \Roperator{\$}. Operators \Roperator{[ ]} and \Roperator{[[ ]]} work like normal \Rlang functions, accepting as arguments passed to them both constant values and variables for indexing. In contrast, \Roperator{\$} mainly intended for use when typing at the console, accepts only bare member names on its \emph{rhs}. With \Roperator{[[ ]]}, the name of the variable or column is given as a character string, enclosed in quotation marks, or as a variable with mode \code{character}. A number as a positional index is also accepted.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1a} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{abcd} \hlstd{=} \hlnum{123}\hlstd{,} \hlkwc{xyzw} \hlstd{=} \hlnum{789}\hlstd{)}
\hlstd{lst1a[[}\hlnum{1}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\begin{alltt}
\hlstd{lst1a[[}\hlstr{"abcd"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlstr{"abcd"}
\hlstd{lst1a[[vct1]]}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\end{kframe}
\end{knitrout}

When using \Roperator{\$}, the name is entered as a constant, without quotation marks, and cannot be a variable or a number.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1a}\hlopt{$}\hlstd{abcd}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\begin{alltt}
\hlstd{lst1a}\hlopt{$}\hlstd{ab}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\begin{alltt}
\hlstd{lst1a}\hlopt{$}\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\end{kframe}
\end{knitrout}

Both in the case of lists and data frames (see section \ref{sec:R:data:frames} on page \pageref{sec:R:data:frames}), when using double square brackets, by default an exact match is required between the name in the object and the name used for indexing. In contrast, with \Roperator{\$}, an unambiguous partial match is silently accepted. For interactive use, partial matching decreases the extent of the text typed at the console. However, in scripts, and especially \Rlang code in packages, it is best to avoid the use of \Roperator{\$} as partial matching to a wrong variable present at a later time, e.g., when someone else revises the script, misdirected partial matching can lead to difficult-to-diagnose errors.

In addition, as \Roperator{\$} is implemented by first attempting a match to the name and then calling \Roperator{[[ ]]}, using \Roperator{\$} for indexing can result in slightly slower performance compared to using \Roperator{[[ ]]}. It is possible to set \Rlang option \code{warnPartialMatchDollar} so that partial matching triggers a warning when using \Roperator{\$} to extract a member, which can be very useful when debugging.
\end{explainbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(lst1[}\hlnum{1}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.list}\hlstd{(lst1[}\hlnum{1}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(lst1[[}\hlnum{1}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.list}\hlstd{(lst1[[}\hlnum{1}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

The two extraction operators can be used together as shown below, with \code{lst1[[1]]} extracting the vector from \code{lst1} and \code{[3]} extracting the member at position 3 of the vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1[[}\hlnum{1}\hlstd{]][}\hlnum{3}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}

Extraction\label{par:calc:list:member:assign} operators can be used on the \emph{lhs} as well as on the \emph{rhs} of an assignment, and lists can be empty, i.e., be of length zero. The example below makes use of this to build a list step by step.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst2} \hlkwb{<-} \hlkwd{list}\hlstd{()}
\hlstd{lst2[[}\hlstr{"x"}\hlstd{]]} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{3}
\hlstd{lst2[[}\hlstr{"y"}\hlstd{]]} \hlkwb{<-} \hlstr{"ab"}
\hlstd{lst2[[}\hlstr{"z"}\hlstd{]]} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Compare \code{lst2} to \code{lst1}, used for the examples above. Then run the code below and compare them again. Try to understand why \code{lst2} has changed as it did. Pay also attention to possible changes to the members' names.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst2[[}\hlstr{"y"}\hlstd{]]} \hlkwb{<-} \hlstd{lst2[[}\hlstr{"x"}\hlstd{]]}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\begin{explainbox}
\emph{Lists}, as usually defined in languages like \Clang, are based on pointers to memory locations, with pointers stored at each node. These pointers chain or link the different member nodes (this allows, for example, sorting of lists in place by modifying the pointers). In such implementations, indexing by position is not possible, or at least requires ``walking'' down the list, node by node. \Rlang does not implement pointers to ``addresses'', or locations, in memory. In \Rlang, \code{list} members can be accessed through positional indexes or member names, similarly to vector members. Of course, as with vectors, insertions and deletions in the middle of a list, shift the position of members, and change which member is pointed at by indexes for positions past the modified location. The names, in contrast, remain valid.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{list}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{c} \hlstd{=} \hlnum{3}\hlstd{)[}\hlopt{-}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## $a
## [1] 1
## 
## $c
## [1] 3
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

Three frequent operations on lists are concatenation, insertions, and deletions.\index{lists!insert into}\index{lists!append to} The same functions as with vectors are used: \Rfunction{c()}, to concatenate, and \Rfunction{append()}, to append and insert. Lists can be combined only with other lists, otherwise, these operations work as with vectors (see pages \pageref{par:calc:concatenate}--\pageref{par:calc:append:end}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst3} \hlkwb{<-} \hlkwd{append}\hlstd{(lst1,} \hlkwd{list}\hlstd{(}\hlkwc{yy} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{zz} \hlstd{= letters[}\hlnum{5}\hlopt{:}\hlnum{1}\hlstd{]),} \hlkwc{after} \hlstd{=} \hlnum{2}\hlstd{)}
\hlstd{lst3}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3
## 
## $y
## [1] "ab"
## 
## $yy
##  [1]  1  2  3  4  5  6  7  8  9 10
## 
## $zz
## [1] "e" "d" "c" "b" "a"
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

To\label{par:calc:lists:rm} delete a member from a list, we assign \code{NULL} to it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1}\hlopt{$}\hlstd{y} \hlkwb{<-} \hlkwa{NULL}
\hlstd{lst1}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

To investigate the members contained in a list, function \Rfunction{str()} (\emph{structure}), used above, is convenient, especially when lists have many members. Structure formats lists more compactly than \code{print()} applied directly to a list.\label{par:calc:str}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(lst1)}
\end{alltt}
\begin{verbatim}
## $x
## [1] 1 2 3
## 
## $z
## [1]  TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(lst1)}
\end{alltt}
\begin{verbatim}
## List of 2
##  $ x: int [1:3] 1 2 3
##  $ z: logi [1:2] TRUE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{lists!deletion and addition of members|)}\index{lists!member extraction|)}

\subsection{Nested lists}\label{sec:calc:lists:nested}

Lists\index{lists!nested} can be nested, i.e., lists of lists can be constructed to an arbitrary depth. In the example below, \code{lst4} and \code{lst5} are members of \code{lst6}, i.e., \code{lst4} and \code{lst5} are nested within \code{lst6}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst4} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"aa"}\hlstd{,} \hlnum{10}\hlstd{)}
\hlstd{lst5} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlnum{TRUE}\hlstd{)}
\hlstd{lst6} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{A} \hlstd{= lst4,} \hlkwc{B} \hlstd{= lst5)} \hlcom{# nested}
\hlkwd{str}\hlstd{(lst6)}
\end{alltt}
\begin{verbatim}
## List of 2
##  $ A:List of 3
##   ..$ : chr "a"
##   ..$ : chr "aa"
##   ..$ : num 10
##  $ B:List of 2
##   ..$ : chr "b"
##   ..$ : logi TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

A nested\index{lists!nested} list can alternatively be constructed within a single statement in which several member lists are created. Here we combine the first three statements in the earlier chunk into a single one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst7} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{A} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"aa"}\hlstd{,} \hlnum{10}\hlstd{),} \hlkwc{B} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlnum{TRUE}\hlstd{))}
\hlkwd{str}\hlstd{(lst7)}
\end{alltt}
\begin{verbatim}
## List of 2
##  $ A:List of 3
##   ..$ : chr "a"
##   ..$ : chr "aa"
##   ..$ : num 10
##  $ B:List of 2
##   ..$ : chr "b"
##   ..$ : logi TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

A list can contain a combination of \code{list} and \code{vector} members.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst8} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{A} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"aa"}\hlstd{,} \hlnum{10}\hlstd{),}
             \hlkwc{B} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlnum{TRUE}\hlstd{),}
             \hlkwc{C} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{9}\hlstd{),}
             \hlkwc{D} \hlstd{=} \hlnum{4321}\hlstd{)}
\hlkwd{str}\hlstd{(lst8)}
\end{alltt}
\begin{verbatim}
## List of 4
##  $ A:List of 3
##   ..$ : chr "a"
##   ..$ : chr "aa"
##   ..$ : num 10
##  $ B:List of 2
##   ..$ : chr "b"
##   ..$ : logi TRUE
##  $ C: num [1:3] 1 3 9
##  $ D: num 4321
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
The logic behind the extraction of members of nested lists using indexing is the same as for simple lists, but applied recursively---e.g., \code{lst7[[2]]} extracts the second member of the outermost list, which is another list. As, this is a list, its members can be extracted using again the extraction operator: \code{lst7[[2]][[1]]}. It is important to remember that these concatenated extraction operations are written so that the leftmost operator is applied to the outermost list.

The example above uses the \Roperator{[[ ]]} operator, but the left-to-right precedence also applies to concatenated calls to \Roperator{[ ]} and to calls combining both operators.
\end{explainbox}

\begin{playground}
What\index{lists!nested} do you expect each of the statements below to return? \emph{Before running the code}, predict what value and of which mode each statement will return. You may use implicit or explicit calls to \Rfunction{print()}, or calls to \Rfunction{str()} to visualise the structure of the different objects.

% not handled correctly by knitr, works at console.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{LST9} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{A} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"aa"}\hlstd{,} \hlstr{"aaa"}\hlstd{),} \hlkwc{B} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"bb"}\hlstd{))}
\hlcom{# str(LST9)}
\hlstd{LST9[}\hlnum{2}\hlopt{:}\hlnum{1}\hlstd{]}
\hlstd{LST9[}\hlnum{1}\hlstd{]}
\hlstd{LST9[[}\hlnum{1}\hlstd{]][}\hlnum{2}\hlstd{]}
\hlstd{LST9[[}\hlnum{1}\hlstd{]][[}\hlnum{2}\hlstd{]]}
\hlstd{LST9[}\hlnum{2}\hlstd{]}
\hlstd{LST9[}\hlnum{2}\hlstd{][[}\hlnum{1}\hlstd{]]}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{explainbox}\index{lists!structure}
When dealing with deep lists, it is sometimes useful to limit the number of levels of nesting returned by \Rfunction{str()} by passing a \code{numeric} argument to parameter \code{max.levels}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(lst8,} \hlkwc{max.level} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## List of 4
##  $ A:List of 3
##  $ B:List of 2
##  $ C: num [1:3] 1 3 9
##  $ D: num 4321
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

Sometimes we need to flatten a list\index{lists!flattening}\index{lists!nested}, or a nested structure of lists within lists. Function \Rfunction{unlist()} is what should be normally used in such cases.

The list \code{lst10} is a nested system of lists, but all the ``terminal'' members are character strings. In other words, terminal nodes are all of the same \code{mode}, allowing the list to be ``flattened'' into a character vector.\qRfunction{is.list()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst10} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{A} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"aa"}\hlstd{,} \hlstr{"aaa"}\hlstd{),} \hlkwc{B} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlstr{"bb"}\hlstd{))}
\hlstd{vct1} \hlkwb{<-} \hlkwd{unlist}\hlstd{(lst10)}
\hlstd{vct1}
\end{alltt}
\begin{verbatim}
##    A1    A2    A3    B1    B2 
##   "a"  "aa" "aaa"   "b"  "bb"
\end{verbatim}
\begin{alltt}
\hlkwd{is.list}\hlstd{(lst10)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.list}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(lst10)}
\end{alltt}
\begin{verbatim}
## [1] "list"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] "character"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(lst10)}
\end{alltt}
\begin{verbatim}
## [1] "A" "B"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] "A1" "A2" "A3" "B1" "B2"
\end{verbatim}
\end{kframe}
\end{knitrout}

The returned value is a vector with named member elements. We use function \Rfunction{str()} to figure out how this vector relates to the original list. The names, always of mode character, are based on the names of list elements when available, while characters depicting positions as numbers are used for anonymous nodes. We can access the members of the vector either through numeric indexes or names.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
##  Named chr [1:5] "a" "aa" "aaa" "b" "bb"
##  - attr(*, "names")= chr [1:5] "A1" "A2" "A3" "B1" ...
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
##   A2 
## "aa"
\end{verbatim}
\begin{alltt}
\hlstd{vct1[}\hlstr{"A2"}\hlstd{]}
\end{alltt}
\begin{verbatim}
##   A2 
## "aa"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Function \Rfunction{unlist()}\index{lists!convert into vector} has two additional parameters, with default argument values, which we did not modify in the example above. These parameters are \code{recursive} and \code{use.names}, both of them expecting a \code{logical} value as an argument. Modify the statement \code{c.vec <- unlist(c.list)}, by passing \code{FALSE} as an argument to these two parameters, in turn, and in each case, study the value returned and how it differs with respect to the one obtained above.
\end{playground}

Function \Rfunction{unname()} can be used to remove names safely---i.e., without risk of altering the mode or class of the object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{unname}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
## [1] "a"   "aa"  "aaa" "b"   "bb"
\end{verbatim}
\begin{alltt}
\hlkwd{unname}\hlstd{(lst10)}
\end{alltt}
\begin{verbatim}
## [[1]]
## [[1]][[1]]
## [1] "a"
## 
## [[1]][[2]]
## [1] "aa"
## 
## [[1]][[3]]
## [1] "aaa"
## 
## 
## [[2]]
## [[2]][[1]]
## [1] "b"
## 
## [[2]][[2]]
## [1] "bb"
\end{verbatim}
\end{kframe}
\end{knitrout}
\index{lists|)}



\section{Data Frames}\label{sec:R:data:frames}
\index{data frames|(}\qRclass{data.frame}
\index{worksheet@`worksheet'|see{data frame}}
Data frames are a special type of list, in which all members have the same length, giving origin to a matrix-like object, in which columns can belong to different classes. Most commonly the member ``columns'' are vectors or factors, but they can also be matrices with the same number of rows as the enclosing data frame, or lists with the same number of members as rows in the enclosing data frame.

Data frames are central to most data manipulation and analysis procedures in \Rlang. They are commonly used to store observations, with \code{numeric} columns holding data for continuous variables and \code{factor} columns data for categorical variables. Binary variables can be stored in \code{logical} columns. Text data can be stored in \code{character} columns. Date and time can be stored in columns of specific classes, such as \code{POSIXct}. In the diagram below, column \code{treatment} is a factor with two levels encoding two conditions, \code{hot} and \code{cold}. Columns \code{height} and \code{weight} are numeric vectors containing measurements.

\begin{center}
\begin{footnotesize}
\begin{tikzpicture}[font=\sffamily, my shape/.style={
  rectangle split, rectangle split parts=#1, draw, anchor=north, minimum size=12mm},
array/.style={matrix of nodes,nodes={draw, minimum size=1mm, fill=black},column sep=2pt, row sep=0.5mm, nodes in empty cells,
row 1/.style={nodes={draw=none, fill=none, minimum size=1mm}}}]

\matrix[array] (array) {
1 & 2 & 3 \\
\rule{10mm}{.1pt} & \rule{10mm}{.1pt} & \rule{10mm}{.1pt}\\};

\begin{scope}[on background layer]
\fill[blue!10] (array-1-1.north west) rectangle (array-1-3.south east);
\end{scope}

\draw (array-2-1.west) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\code{\strut df1}};
\draw (array-2-1.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-17mm, yshift=-3mm, above] (nameh) {\rotatebox{180}{treatment\strut}};
\draw (array-2-2.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-14.4mm, yshift=-3mm, above] (namec) {\rotatebox{180}{height\strut}};
\draw (array-2-3.north) node [signal, draw, fill=codeshadecolor, minimum size=5mm, rotate=-90, xshift=-14.5mm, yshift=-3mm, above] (namew) {\rotatebox{180}{weight\strut}};
%\draw (array-1-2.north)--++(90:3mm) node [above] (first) {Index};
\draw (array-1-3.east)--++(0:12.5mm) node [right]{\code{integer} positional indices};
\draw (array-2-3.east)--++(0:8mm) node [right]{\textsl{heterogeneous} class, \textsl{same} length};
\draw (namew)--++(0:15mm) node [right]{\code{character} column names};
%
  \node [my shape=4, rectangle split, fill=green!20] at (-1.3,-.25)
    {hot\strut\nodepart{two}cold\strut\nodepart{three}hot\strut\nodepart{four}\ldots\strut};
  \node [my shape=4, fill=blue!20] at (0,-.25)
    {10.2\strut\nodepart{two}\phantom{1}8.3\strut\nodepart{three}12.0\strut\nodepart{four}\ldots\strut};
  \node [my shape=4, fill=blue!20] at (1.3,-.25)
    {2.2\strut\nodepart{two}3.3\strut\nodepart{three}2.5\strut\nodepart{four}\ldots\strut};
%\draw (-0.6,+0.65) node [signal, draw, fill=codeshadecolor, minimum size=6mm, line width=1.5pt, left] (first) {\code{\strut a.list}};
\end{tikzpicture}
\end{footnotesize}
\end{center}

Data frames are created with constructor function \Rfunction{data.frame()} with a syntax similar to that used for lists.\qRfunction{colnames()}\qRfunction{rownames()}\qRfunction{is.data.frame()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{treatment} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"hot"}\hlstd{,} \hlstr{"cold"}\hlstd{),} \hlnum{3}\hlstd{)),}
                  \hlkwc{height} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{10.2}\hlstd{,} \hlnum{8.3}\hlstd{,} \hlnum{12.0}\hlstd{,} \hlnum{9.0}\hlstd{,} \hlnum{11.2}\hlstd{,} \hlnum{8.7}\hlstd{),}
                  \hlkwc{weight} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2.2}\hlstd{,} \hlnum{3.3}\hlstd{,} \hlnum{2.5}\hlstd{,} \hlnum{2.8}\hlstd{,} \hlnum{2.4}\hlstd{,} \hlnum{3.0}\hlstd{))}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   treatment height weight
## 1       hot   10.2    2.2
## 2      cold    8.3    3.3
## 3       hot   12.0    2.5
## 4      cold    9.0    2.8
## 5       hot   11.2    2.4
## 6      cold    8.7    3.0
\end{verbatim}
\begin{alltt}
\hlkwd{colnames}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "treatment" "height"    "weight"
\end{verbatim}
\begin{alltt}
\hlkwd{rownames}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "1" "2" "3" "4" "5" "6"
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## 'data.frame':	6 obs. of  3 variables:
##  $ treatment: Factor w/ 2 levels "cold","hot": 2 1 2 1 2 1
##  $ height   : num  10.2 8.3 12 9 11.2 8.7
##  $ weight   : num  2.2 3.3 2.5 2.8 2.4 3
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "list"
\end{verbatim}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.list}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

We can see above that when printed each row of a \code{data.frame} is preceded by a row name. Row names are character strings, just like column names. The \Rfunction{data.frame()} constructor adds by default row names representing running numbers. Default row names are rarely of much use, except to track insertions and deletions of rows during debugging.

\begin{playground}
As the expectation is that all member variables (or ``columns'') have equal length, if vectors of different lengths are supplied as arguments, the shorter vector(s) is/are recycled, possibly several times, until the required full length is reached, as shown below for \code{treatment}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df2} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{treatment} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"hot"}\hlstd{,} \hlstr{"cold"}\hlstd{)),}
                  \hlkwc{height} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{10.2}\hlstd{,} \hlnum{8.3}\hlstd{,} \hlnum{12.0}\hlstd{,} \hlnum{9.0}\hlstd{,} \hlnum{11.2}\hlstd{,} \hlnum{8.7}\hlstd{),}
                  \hlkwc{weight} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2.2}\hlstd{,} \hlnum{3.3}\hlstd{,} \hlnum{2.5}\hlstd{,} \hlnum{2.8}\hlstd{,} \hlnum{2.4}\hlstd{,} \hlnum{3.0}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Are \code{df1} crated above and \code{df2} created here equal?

\end{playground}

With function \Rfunction{class()} we can query the class of an \Rlang object (see section \ref{sec:rlang:mode} on page \pageref{sec:rlang:mode}). As we saw in the previous chunk, \code{list} and \code{data.frame} objects belong to two different classes. However, their \code{mode} is the same. Consequently, data frames inherit the methods and characteristics of lists, as long as they have not been hidden by new ones defined for data frames (for an explanation of \emph{methods}, see section \ref{sec:methods} on page \pageref{sec:methods}).

Extraction of individual member variables or ``columns'' can be done like in a list with operators \Roperator{[[ ]]} and \Roperator{\$} (see call-out in \pageref{box:extraction:opers}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1}\hlopt{$}\hlstd{height}
\end{alltt}
\begin{verbatim}
## [1] 10.2  8.3 12.0  9.0 11.2  8.7
\end{verbatim}
\begin{alltt}
\hlstd{df1[[}\hlstr{"height"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 10.2  8.3 12.0  9.0 11.2  8.7
\end{verbatim}
\begin{alltt}
\hlstd{df1[[}\hlnum{2}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] 10.2  8.3 12.0  9.0 11.2  8.7
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(df1[[}\hlstr{"height"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\end{kframe}
\end{knitrout}

In the same way as with lists, we can add member variables to data frames. Recycling takes place if needed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1}\hlopt{$}\hlstd{x2} \hlkwb{<-} \hlnum{6}\hlopt{:}\hlnum{1}
\hlstd{df1[[}\hlstr{"x3"}\hlstd{]]} \hlkwb{<-} \hlstr{"b"}
\hlkwd{str}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## 'data.frame':	6 obs. of  5 variables:
##  $ treatment: Factor w/ 2 levels "cold","hot": 2 1 2 1 2 1
##  $ height   : num  10.2 8.3 12 9 11.2 8.7
##  $ weight   : num  2.2 3.3 2.5 2.8 2.4 3
##  $ x2       : int  6 5 4 3 2 1
##  $ x3       : chr  "b" "b" "b" "b" ...
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
We have added two columns to the data frame, and in the case of column \code{x3} recycling took place. This is where lists and data frames differ substantially in their behaviour. In a data frame, although class and mode can be different for different member variables (columns), they are required to be vectors or factors of the same length (or a matrix with the same number of rows, or a list with the same number of members). In the case of lists, there is no such requirement, and recycling never takes place when adding a member. Compare the values returned below for \code{LST1}, to those in the example above for \code{df1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{LST1} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"a"}\hlstd{,} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\hlkwd{str}\hlstd{(LST1)}
\end{alltt}
\begin{verbatim}
## List of 3
##  $ x: int [1:6] 1 2 3 4 5 6
##  $ y: chr "a"
##  $ z: logi [1:2] TRUE FALSE
\end{verbatim}
\begin{alltt}
\hlstd{LST1}\hlopt{$}\hlstd{x2} \hlkwb{<-} \hlnum{6}\hlopt{:}\hlnum{1}
\hlstd{LST1}\hlopt{$}\hlstd{x3} \hlkwb{<-} \hlstr{"b"}
\hlkwd{str}\hlstd{(LST1)}
\end{alltt}
\begin{verbatim}
## List of 5
##  $ x : int [1:6] 1 2 3 4 5 6
##  $ y : chr "a"
##  $ z : logi [1:2] TRUE FALSE
##  $ x2: int [1:6] 6 5 4 3 2 1
##  $ x3: chr "b"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{playground}

\begin{faqbox}{How to create an empty data frame?}
In the same way as \code{numeric()} creates a \code{numeric} vector of length zero, \Rfunction{data.frame()} by default creates a \code{data.frame} with zero rows and no columns.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{()}
\end{alltt}
\begin{verbatim}
## data frame with 0 columns and 0 rows
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

\begin{faqbox}{How to make a list of data frames?}
We create a list of data frames in the same way as we create a nested list of lists, or in fact of a list of any other \Rlang objects. See section \ref{sec:calc:lists:nested} on page \pageref{sec:calc:lists:nested}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{list}\hlstd{(df1, df2)}
\end{alltt}
\begin{verbatim}
## [[1]]
##   treatment height weight x2 x3
## 1       hot   10.2    2.2  6  b
## 2      cold    8.3    3.3  5  b
## 3       hot   12.0    2.5  4  b
## 4      cold    9.0    2.8  3  b
## 5       hot   11.2    2.4  2  b
## 6      cold    8.7    3.0  1  b
## 
## [[2]]
##   treatment height weight
## 1       hot   10.2    2.2
## 2      cold    8.3    3.3
## 3       hot   12.0    2.5
## 4      cold    9.0    2.8
## 5       hot   11.2    2.4
## 6      cold    8.7    3.0
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

\begin{faqbox}{How to add a new column to a data frame (to the front and end)?}
In the same way as we can assign a new member to a list using the extraction operator \Roperator{[[ ]]}, we can add a new column to a data frame (see page \pageref{par:calc:list:member:assign}). In this case, if the column name does not already exist, the assigned vector or factor is appended as the last column (no recycling applied to short vectors or factors unless of length one).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{DF1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{A} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{B} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlnum{5}\hlopt{:}\hlnum{1}\hlstd{))}
\hlstd{DF1[[}\hlstr{"C"}\hlstd{]]} \hlkwb{<-} \hlnum{11}\hlopt{:}\hlnum{15}
\hlstd{DF1}
\end{alltt}
\begin{verbatim}
##   A B  C
## 1 1 5 11
## 2 2 4 12
## 3 3 3 13
## 4 4 2 14
## 5 5 1 15
\end{verbatim}
\end{kframe}
\end{knitrout}

To add a column at the front, we can use function \Rfunction{cbind()} (column bind).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{DF2} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{A} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{B} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlnum{5}\hlopt{:}\hlnum{1}\hlstd{))}
\hlkwd{cbind}\hlstd{(}\hlkwc{C} \hlstd{=} \hlnum{11}\hlopt{:}\hlnum{15}\hlstd{, DF2)}
\end{alltt}
\begin{verbatim}
##    C A B
## 1 11 1 5
## 2 12 2 4
## 3 13 3 3
## 4 14 4 2
## 5 15 5 1
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

Being two-dimensional and rectangular in shape, data frames, in relation to indexing and dimensions, behave similarly to a matrix. They have two margins, rows, and columns, and, thus, two indices are used to indicate the location of a member ``cell''. We provide some examples here, but please consult section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing} and section \ref{sec:matrix:array} on page \pageref{sec:matrix:array} for additional details.

Matrix-like notation allows simultaneous extraction from multiple columns, which is not possible with lists. The value returned is in most cases a ``smaller'' data frame as in this example.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1[}\hlnum{2}\hlopt{:}\hlnum{3}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
##   treatment height
## 2      cold    8.3
## 3       hot   12.0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# first column, df1[[1]] preferred}
\hlstd{df1[ ,} \hlnum{1}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] hot  cold hot  cold hot  cold
## Levels: cold hot
\end{verbatim}
\begin{alltt}
\hlcom{# first column, df1[["x"]] or df1$x preferred}
\hlstd{df1[ ,} \hlstr{"treatment"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] hot  cold hot  cold hot  cold
## Levels: cold hot
\end{verbatim}
\begin{alltt}
\hlcom{# first row}
\hlstd{df1[}\hlnum{1}\hlstd{, ]}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot   10.2    2.2  6  b
\end{verbatim}
\begin{alltt}
\hlcom{# first two rows of the third and fourth columns}
\hlstd{df1[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##   weight x2
## 1    2.2  6
## 2    3.3  5
\end{verbatim}
\begin{alltt}
\hlcom{# the rows for which comparison is true}
\hlstd{df1[df1}\hlopt{$}\hlstd{treatment} \hlopt{==} \hlstr{"hot"} \hlstd{, ]}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot   10.2    2.2  6  b
## 3       hot   12.0    2.5  4  b
## 5       hot   11.2    2.4  2  b
\end{verbatim}
\begin{alltt}
\hlcom{# the heights > 8}
\hlstd{df1[df1}\hlopt{$}\hlstd{height} \hlopt{>} \hlnum{8}\hlstd{,} \hlstr{"height"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 10.2  8.3 12.0  9.0 11.2  8.7
\end{verbatim}
\end{kframe}
\end{knitrout}

As explained earlier for vectors (see section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}), indexing can be present both on the right- and left-hand sides of an assignment, allowing the replacement of both individual values and rectangular regions.

The next few examples do assignments to ``cells'' of \code{df1}, either to one whole column, or individual values. The last statement in the chunk below copies a number from one location to another by using indexing of the same data frame both on the right side and left side of the assignment.\qRoperator{[[ ]]}\qRoperator{[ ]}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1[}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{]} \hlkwb{<-} \hlnum{99}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot   99.0    2.2  6  b
## 2      cold    8.3    3.3  5  b
## 3       hot   12.0    2.5  4  b
## 4      cold    9.0    2.8  3  b
## 5       hot   11.2    2.4  2  b
## 6      cold    8.7    3.0  1  b
\end{verbatim}
\begin{alltt}
\hlstd{df1[ ,} \hlnum{2}\hlstd{]} \hlkwb{<-} \hlopt{-}\hlnum{99}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot    -99    2.2  6  b
## 2      cold    -99    3.3  5  b
## 3       hot    -99    2.5  4  b
## 4      cold    -99    2.8  3  b
## 5       hot    -99    2.4  2  b
## 6      cold    -99    3.0  1  b
\end{verbatim}
\begin{alltt}
\hlstd{df1[[}\hlstr{"height"}\hlstd{]]} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{12}\hlstd{)}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot     10    2.2  6  b
## 2      cold     12    3.3  5  b
## 3       hot     10    2.5  4  b
## 4      cold     12    2.8  3  b
## 5       hot     10    2.4  2  b
## 6      cold     12    3.0  1  b
\end{verbatim}
\begin{alltt}
\hlstd{df1[}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{df1[}\hlnum{6}\hlstd{,} \hlnum{3}\hlstd{]}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot      3    2.2  6  b
## 2      cold     12    3.3  5  b
## 3       hot     10    2.5  4  b
## 4      cold     12    2.8  3  b
## 5       hot     10    2.4  2  b
## 6      cold     12    3.0  1  b
\end{verbatim}
\begin{alltt}
\hlstd{df1[}\hlnum{3}\hlopt{:}\hlnum{6}\hlstd{,} \hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{df1[}\hlnum{6}\hlstd{,} \hlnum{3}\hlstd{]}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   treatment height weight x2 x3
## 1       hot      3    2.2  6  b
## 2      cold     12    3.3  5  b
## 3       hot      3    2.5  4  b
## 4      cold      3    2.8  3  b
## 5       hot      3    2.4  2  b
## 6      cold      3    3.0  1  b
\end{verbatim}
\end{kframe}
\end{knitrout}

Similarly as with matrices, if we extract a single column from a data frame using matrix-like indexing, it is by default simplified into a vector or factor, i.e., the column-dimension is dropped. By passing \code{drop = FALSE}, we can prevent this. Contrary to matrices, rows are not simplified in the case of data frames.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1[}\hlnum{1}\hlstd{, ])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1[ ,} \hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1[ ,} \hlstr{"treatment"}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlnum{2}\hlopt{:}\hlnum{3}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(df1[}\hlnum{1}\hlstd{, ])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(df1[ ,} \hlnum{2}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.factor}\hlstd{(df1[ ,} \hlstr{"treatment"}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.vector}\hlstd{(df1[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlnum{2}\hlopt{:}\hlnum{3}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1[ ,} \hlnum{1}\hlstd{,} \hlkwc{drop} \hlstd{=} \hlnum{FALSE}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.data.frame}\hlstd{(df1[ ,} \hlstr{"treatment"}\hlstd{,} \hlkwc{drop} \hlstd{=} \hlnum{FALSE}\hlstd{])}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
In contrast to matrices and data frames, the extraction operator \Roperator{[ ]} of tibbles---defined in package \pkgname{tibble}---never simplifies returned one-column tibbles into vectors (see section \ref{sec:data:tibble} on page \pageref{sec:data:tibble} for details on the differences between data frames and tibbles).
\end{warningbox}

Usually data frames are created from lists or by passing individual vectors and factors to the constructors. It is also possible to construct data frames starting from matrices, other data frames and named vectors, in which case, the identity function \Rfunction{I()} can be used to protect them from interpretation by the \Rfunction{data.frame()} constructor. In these cases, additional nuances become important. The details are well described in \code{help(data.frame)}.

With a named numeric vector, and a factor as arguments, the names are moved from the vector to the rows of the data frame!

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwc{one} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{two} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{three} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{four} \hlstd{=} \hlnum{4}\hlstd{)}
\hlstd{fct1} \hlkwb{<-} \hlkwd{as.factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{2}\hlstd{))}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(fct1, vct1)}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##       fct1 vct1
## one      1    1
## two      2    2
## three    3    3
## four     2    4
\end{verbatim}
\begin{alltt}
\hlstd{df1}\hlopt{$}\hlstd{vct1}
\end{alltt}
\begin{verbatim}
## [1] 1 2 3 4
\end{verbatim}
\end{kframe}
\end{knitrout}

If the vector is protected with \Rlang's identity function \Rfunction{I()} the names are not moved as can be seen by extracting the column \code{vct1} from data frame \code{df2}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df2} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(fct1,} \hlkwd{I}\hlstd{(vct1))}
\hlstd{df2}
\end{alltt}
\begin{verbatim}
##       fct1 vct1
## one      1    1
## two      2    2
## three    3    3
## four     2    4
\end{verbatim}
\begin{alltt}
\hlstd{df2}\hlopt{$}\hlstd{vct1}
\end{alltt}
\begin{verbatim}
##   one   two three  four 
##     1     2     3     4
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
With a matrix instead of a vector, the matrix is split into separate columns in the data frame. If the matrix has no column names, new ones are created.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{12}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{3}\hlstd{)}
\hlstd{df4} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(fct1, mat1)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df4}
\end{alltt}
\begin{verbatim}
##   fct1 X1 X2 X3
## 1    1  1  5  9
## 2    2  2  6 10
## 3    3  3  7 11
## 4    2  4  8 12
\end{verbatim}
\end{kframe}
\end{knitrout}

If the matrix is protected with function \Rfunction{I()}, it is not split, and the whole matrix becomes a column in the data frame.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df5} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(fct1,} \hlkwd{I}\hlstd{(mat1))}
\hlstd{df5}
\end{alltt}
\begin{verbatim}
##   fct1 mat1.1 mat1.2 mat1.3
## 1    1      1      5      9
## 2    2      2      6     10
## 3    3      3      7     11
## 4    2      4      8     12
\end{verbatim}
\begin{alltt}
\hlstd{df5}\hlopt{$}\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{explainbox}
With a list, whose member are vectors, each member of the list becomes a column in the data frame. In the case of too short members, recycling is applied.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{lst1} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{4}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwc{b} \hlstd{= letters[}\hlnum{4}\hlopt{:}\hlnum{1}\hlstd{],} \hlkwc{c} \hlstd{=} \hlstr{"n"}\hlstd{,} \hlkwc{d} \hlstd{=} \hlstr{"z"}\hlstd{)}
\hlstd{df6}\hlkwb{<-} \hlkwd{data.frame}\hlstd{(fct1, lst1)}
\hlstd{df6}
\end{alltt}
\begin{verbatim}
##   fct1 a b c d
## 1    1 4 d n z
## 2    2 3 c n z
## 3    3 2 b n z
## 4    2 1 a n z
\end{verbatim}
\end{kframe}
\end{knitrout}

If the list is protected with \Rfunction{I()}, the list is added in whole as a variable or column in the data frame. In this case, the length of the list must match the number of rows in the data frame, while the length and class of the individual members of the list can vary. The names of the list members are used to set the \code{rownames} of the data frame.
This is similar to the default behaviour of tibbles, while \Rlang data frames require explicit use of \Rfunction{I()} for lists not to be split (see chapter \ref{chap:R:data} on page \pageref{chap:R:data} for details about package \pkgname{tibble}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df7}\hlkwb{<-} \hlkwd{data.frame}\hlstd{(fct1,} \hlkwd{I}\hlstd{(lst1))}
\hlstd{df7}
\end{alltt}
\begin{verbatim}
##   fct1       lst1
## a    1 4, 3, 2, 1
## b    2 d, c, b, a
## c    3          n
## d    2          z
\end{verbatim}
\end{kframe}
\end{knitrout}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df7}\hlopt{$}\hlstd{lst1}
\end{alltt}
\begin{verbatim}
## $a
## [1] 4 3 2 1
## 
## $b
## [1] "d" "c" "b" "a"
## 
## $c
## [1] "n"
## 
## $d
## [1] "z"
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{advplayground}
What do we gain using \Rfunction{I()}? Check the documentation carefully and think of uses where the flexibility gained by the option to protect or not the arguments passed to the \Rfunction{data.frame()} constructor can be useful. In addition, write \Rlang statements to extract individual members of embedded matrices or lists using indexing. Finally, test if the behaviour of \Rfunction{I()} is the same when assigning new member variables (or ``columns'') to an existing data frame.
\end{advplayground}

\subsection{Sub-setting data frames}\label{sec:calc:df:subset}
When\index{data frames!subsetting}\index{data frames!``filtering rows''} the names of data frames are long, complex conditions become awkward to write using indexing---i.e., subscripts. In such cases, \Rfunction{subset()} is handy because it evaluates the condition with the data frame as the ``environment'', i.e., the names of the columns are recognised if entered directly when writing the condition. Function  \Rfunction{subset()} ``filters'' rows, usually corresponding to observations or experimental units. The condition is computed for each row, and if it returns \code{TRUE}, the row is included in the returned data frame, and excluded if \code{FALSE}.

We create a data frame with six rows and three columns. For column \code{y}, we rely on \Rlang automatically extending \code{"a"} by repeating it six times, while for column \code{z}, we rely on \Rlang automatically extending \code{c(TRUE, FALSE)} by repeating it three times.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df8} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{y} \hlstd{=} \hlstr{"a"}\hlstd{,} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{))}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   x y     z
## 4 4 a FALSE
## 5 5 a  TRUE
## 6 6 a FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
What is the behaviour of \code{subset()} when the condition is \code{NA}? Find the answer by writing code to test this, for a case where tests for different rows return \code{NA}, \code{TRUE} and \code{FALSE}.
\end{advplayground}

When calling functions that return a vector, data frame, or other structure, the extraction operators \Roperator{[ ]}, \Roperator{[[ ]]}, or \Roperator{\$} can be appended to the rightmost parenthesis of the function call, in the same way as to the name of a variable holding the same data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{)[ ,} \hlopt{-}\hlnum{3}\hlstd{]}
\end{alltt}
\begin{verbatim}
##   x y
## 4 4 a
## 5 5 a
## 6 6 a
\end{verbatim}
\begin{alltt}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{)[ ,} \hlstr{"x"}\hlstd{,} \hlkwc{drop} \hlstd{=} \hlnum{FALSE}\hlstd{]}
\end{alltt}
\begin{verbatim}
##   x
## 4 4
## 5 5
## 6 6
\end{verbatim}
\begin{alltt}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{)[ ,} \hlstr{"x"}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] 4 5 6
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
When do extraction operators applied to data frames return a vector or factor, and when do they return a data frame? Please, experiment with your own code examples to work out the answer.
\end{advplayground}

\begin{explainbox}
In the case of \Rfunction{subset()}, we can select columns directly as shown below, while for most other functions, extraction using operators \Roperator{[ ]}, \Roperator{[[ ]]}, or \Roperator{\$} is needed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{,} \hlkwc{select} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   y
## 4 a
## 5 a
## 6 a
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{,} \hlkwc{select} \hlstd{= x)}
\end{alltt}
\begin{verbatim}
##   x
## 4 4
## 5 5
## 6 6
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{subset}\hlstd{(df8, x} \hlopt{>} \hlnum{3}\hlstd{,} \hlkwc{select} \hlstd{=} \hlstr{"x"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   x
## 4 4
## 5 5
## 6 6
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

None of the examples in the last four code chunks alters the original data frame \code{df8}. We can store the returned value using a new name if we want to preserve \code{df8} unchanged, or we can assign the result to \code{df8}, deleting in the process, the previously stored value.

\begin{warningbox}
In the examples above, the names in the expression passed as the second argument to \code{subset()} were searched within \code{df8} and found. However, if not found in the data frame, objects with matching names are searched for in the global environment (outside the data frame, and visible in the user's workspace or enclosing environment). With no variable \code{A} present in data frame \code{df8}, vector \code{A} from the environment is silently used in the chunk below resulting in a returned data frame with no rows as \code{A > 3} returns \code{FALSE}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlnum{1}
\hlkwd{subset}\hlstd{(df8, A} \hlopt{>} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] x y z
## <0 rows> (or 0-length row.names)
\end{verbatim}
\end{kframe}
\end{knitrout}

This also applies to the expression passed as argument to parameter \code{select}, here shown as a way of selecting columns based on names stored in a character vector.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{columns} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"x"}\hlstd{,} \hlstr{"z"}\hlstd{)}
\hlkwd{subset}\hlstd{(df8,} \hlkwc{select} \hlstd{= columns)}
\end{alltt}
\begin{verbatim}
##   x     z
## 1 1  TRUE
## 2 2 FALSE
## 3 3  TRUE
## 4 4 FALSE
## 5 5  TRUE
## 6 6 FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

The use of \Rfunction{subset()} is convenient, but more prone to bugs compared to directly using the extraction operator \code{[ ]}. This same ``cost'' to achieving convenience applies to functions like \Rfunction{attach()} and \Rfunction{with()} described below. The longer time that a script is expected to be used, adapted, and reused, the more careful we should be when using any of these functions. An alternative way of avoiding excessive verbosity is to keep the names of data frames short.
\end{warningbox}

A frequently used way of deleting a column by name from a data frame is to assign \code{NULL} to it---i.e., in the same way as members are usually deleted from \code{list}s. This approach modifies \code{df9} in place, rather than returning a modified copy of \code{df9}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df9} \hlkwb{<-} \hlstd{df8}
\hlkwd{head}\hlstd{(df9)}
\end{alltt}
\begin{verbatim}
##   x y     z
## 1 1 a  TRUE
## 2 2 a FALSE
## 3 3 a  TRUE
## 4 4 a FALSE
## 5 5 a  TRUE
## 6 6 a FALSE
\end{verbatim}
\begin{alltt}
\hlstd{df9[[}\hlstr{"y"}\hlstd{]]} \hlkwb{<-} \hlkwa{NULL}
\hlkwd{head}\hlstd{(df9)}
\end{alltt}
\begin{verbatim}
##   x     z
## 1 1  TRUE
## 2 2 FALSE
## 3 3  TRUE
## 4 4 FALSE
## 5 5  TRUE
## 6 6 FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Alternatively, negative indexing can be used to remove columns from a copy of a data frame. In this example, a single column is removed. As base \Rlang does not support negative indexing by name with the extraction operator, the numerical index of the column to delete needs to be obtained first. (See the examples above using \code{subset()} with bare names to delete columns.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df8[ ,} \hlopt{-}\hlkwd{which}\hlstd{(}\hlkwd{colnames}\hlstd{(df8)} \hlopt{==} \hlstr{"y"}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##   x     z
## 1 1  TRUE
## 2 2 FALSE
## 3 3  TRUE
## 4 4 FALSE
## 5 5  TRUE
## 6 6 FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}
\pagebreak

Instead of using the equality test, we can use the operator \code{\%in\%} or function \code{grepl()} to create a \code{logical} vector useful for deleting or selecting multiple columns in a single statement.

\begin{playground}
In the previous code chunk, we deleted the last column of the data frame \code{df8}, but using the extraction operator, we modified only the returned copy of \code{df8}, leaving \code{df8} unchanged. Thus we reuse it here for a surprising trick. You should first untangle how it changes the positions of columns and rows, and afterwards think how and why indexing with the extraction operator \Roperator{[ ]} on both sides of the assignment operator \Roperator{<-} can be useful when working with data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df8[}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{)]} \hlkwb{<-} \hlstd{df8[}\hlnum{6}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,}\hlnum{1}\hlstd{)]}
\hlstd{df8}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\begin{warningbox}
Although in this last example we used numeric indexes to make it more interesting, in practice, especially in scripts or other code that will be reused, do use column or member names instead of positional indexes whenever possible. This makes code much more reliable, as changes elsewhere in the script could alter the order of columns and \emph{invalidate} numerical indexes. In addition, using meaningful names makes programmers' intentions easier to understand.
\end{warningbox}

\subsection{Summarising and splitting data frames}\label{sec:calc:df:split}\label{sec:calc:df:aggregate}
Function\index{data frames!summarizing} \Rfunction{summary()} can be used to obtain a summary from objects of most \Rlang classes, including data frames. It is also possible to use \Rloop{sapply()}, \Rloop{lapply()} or \Rloop{vapply()} to apply any suitable function to data by columns (see section \ref{sec:data:apply} on page \pageref{sec:data:apply} for a description of these functions and their use).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(df8)}
\end{alltt}
\begin{verbatim}
##        x             y                 z          
##  Min.   :1.00   Length:6           Mode :logical  
##  1st Qu.:2.25   Class :character   FALSE:3        
##  Median :3.50   Mode  :character   TRUE :3        
##  Mean   :3.50                                     
##  3rd Qu.:4.75                                     
##  Max.   :6.00
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{data frames!splitting}
\Rlang function \Rfunction{split()} makes it possible to split a data frame into a list of data frames, based on the levels of a factor, even if the rows are not ordered according to factor levels.

We create a data frame with six rows and three columns. In the case of column \code{z}, we rely on \Rlang to automatically extend \code{c("a", "b")} by repeating it three times so as to fill the six rows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df10} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x1} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{x2} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{3}\hlstd{),} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{split}\hlstd{(df10, df10}\hlopt{$}\hlstd{z)}
\end{alltt}
\begin{verbatim}
## $a
##   x1 x2 z
## 1  1  1 a
## 3  3  4 a
## 5  5  6 a
## 
## $b
##   x1 x2 z
## 2  2  5 b
## 4  4  2 b
## 6  6  3 b
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
The same operation can be specified using a one-sided formula \code{\textasciitilde z} to indicate the grouping.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{split}\hlstd{(df10,} \hlopt{~} \hlstd{z)}
\end{alltt}
\begin{verbatim}
## $a
##   x1 x2 z
## 1  1  1 a
## 3  3  4 a
## 5  5  6 a
## 
## $b
##   x1 x2 z
## 2  2  5 b
## 4  4  2 b
## 6  6  3 b
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

Function \Rfunction{unsplit()} can be used to reverse splitting done by \Rfunction{split()}.

\begin{explainbox}
\Rfunction{split()} is sometimes used in combination with apply functions (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}) to compute group or treatment summaries. However, in most cases it is simpler to use \Rfunction{aggregate()} for computing such summaries.
\end{explainbox}

Related to splitting a data frame is the calculation of summaries based on a subset of cases, or more commonly summaries for all observations but after grouping them based on the values in a column or the levels of a factor.

\begin{faqbox}{How to summarise one variable from a data frame by group?}
To summarise a single variable by group, we can use \Rfunction{aggregate()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{aggregate}\hlstd{(}\hlkwc{x} \hlstd{= iris}\hlopt{$}\hlstd{Petal.Length,}
          \hlkwc{by} \hlstd{=} \hlkwd{list}\hlstd{(iris}\hlopt{$}\hlstd{Species),} \hlkwc{FUN} \hlstd{= mean)}
\end{alltt}
\begin{verbatim}
##      Group.1     x
## 1     setosa 1.462
## 2 versicolor 4.260
## 3  virginica 5.552
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

\begin{faqbox}{How to summarise numeric variables from a data frame by group?}
To summarise variables, we can use \Rfunction{aggregate()} (see section \ref{sec:dplyr:group:wise} on page \pageref{sec:dplyr:group:wise} for an alternative approach using package \pkgnameNI{dplyr}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{aggregate}\hlstd{(}\hlkwc{x} \hlstd{= iris[ ,} \hlkwd{sapply}\hlstd{(iris, is.numeric)],}
          \hlkwc{by} \hlstd{=} \hlkwd{list}\hlstd{(iris}\hlopt{$}\hlstd{Species),} \hlkwc{FUN} \hlstd{= mean)}
\end{alltt}
\begin{verbatim}
##      Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1     setosa        5.006       3.428        1.462       0.246
## 2 versicolor        5.936       2.770        4.260       1.326
## 3  virginica        6.588       2.974        5.552       2.026
\end{verbatim}
\end{kframe}
\end{knitrout}

For these data, as the only non-numeric variable is \code{Species}, we could have also used formula notation as shown below.
\end{faqbox}

\begin{explainbox}
There\index{data frames!summarizing} is also a formula-based \Rfunction{aggregate()} method (or ``variant'') available (\Rlang \emph{formulas} are described in depth in section \ref{sec:stat:formulas} on page \pageref{sec:stat:formulas}). In \Rfunction{aggregate()}, the left-hand side (\emph{lhs}) of the formula indicates the variable to summarise and its right-hand side (\emph{rhs}) the factor used to split or group the data before summarising them.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{aggregate}\hlstd{(x1} \hlopt{~} \hlstd{z,} \hlkwc{FUN} \hlstd{= mean,} \hlkwc{data} \hlstd{= df10)}
\end{alltt}
\begin{verbatim}
##   z x1
## 1 a  3
## 2 b  4
\end{verbatim}
\end{kframe}
\end{knitrout}

We can summarise more than one column at a time.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{aggregate}\hlstd{(}\hlkwd{cbind}\hlstd{(x1, x2)} \hlopt{~} \hlstd{z,} \hlkwc{FUN} \hlstd{= mean,} \hlkwc{data} \hlstd{= df10)}
\end{alltt}
\begin{verbatim}
##   z x1       x2
## 1 a  3 3.666667
## 2 b  4 3.333333
\end{verbatim}
\end{kframe}
\end{knitrout}

If all the columns not used for grouping are valid input to the function passed as the argument to \code{FUN} the formula can be simplified using a point (\code{.}) with meaning ``all columns except those on the \emph{rhs} of the formula''.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{aggregate}\hlstd{(.} \hlopt{~} \hlstd{z,} \hlkwc{FUN} \hlstd{= mean,} \hlkwc{data} \hlstd{= df10)}
\end{alltt}
\begin{verbatim}
##   z x1       x2
## 1 a  3 3.666667
## 2 b  4 3.333333
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

Function \Rfunction{aggregate()} can be also used to aggregate time series data based on time intervals (see \code{help(aggregate)}).

\subsection{Re-arranging columns and rows}
\index{data frames!ordering rows}\index{data frames!ordering columns}
As with members of vectors and lists, to change the position of columns or rows in a data frame we use the extraction operator and indexing by name or position. In a matrix-like object, such as a data frame, the first index corresponds to rows and the second to columns.

The most direct way of changing the order of columns and/or rows in data frames (as for matrices and arrays) is to use subscripting. Once we know the original position and target position we can use column names or positions as indexes on the right-hand side, listing all columns to be retained, even those remaining at their original position.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df11} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{A} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{B} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{C} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\hlkwd{head}\hlstd{(df11,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B C
## 1 1 3 A
## 2 2 3 B
\end{verbatim}
\begin{alltt}
\hlstd{df11} \hlkwb{<-} \hlstd{df11[ ,} \hlkwd{c}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlstr{"A"}\hlstd{,} \hlstr{"C"}\hlstd{)]}
\hlkwd{head}\hlstd{(df11,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   B A C
## 1 3 1 A
## 2 3 2 B
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
When using the extraction operator \Roperator{[ ]} on both the left- and right-hand-sides, with a \code{numeric} vector as an argument to swap two columns, the vectors or factors are swapped, while the names of the columns are not!
To retain the correspondence between column naming and column contents after swapping or rearranging the columns \emph{using numeric indices}, we need to separately move the names of the columns. This may seem counter-intuitive, unless we think in terms of positions being named rather than the contents of the columns being linked to the names.\qRfunction{colnames()}\qRfunction{colnames()<-}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df11} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{A} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{B} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{C} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\hlkwd{head}\hlstd{(df11,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B C
## 1 1 3 A
## 2 2 3 B
\end{verbatim}
\begin{alltt}
\hlstd{df11[ ,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{df11[ ,} \hlnum{2}\hlopt{:}\hlnum{1}\hlstd{]}
\hlkwd{head}\hlstd{(df11,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B C
## 1 3 1 A
## 2 3 2 B
\end{verbatim}
\begin{alltt}
\hlkwd{colnames}\hlstd{(df11)[}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlkwd{colnames}\hlstd{(df11)[}\hlnum{2}\hlopt{:}\hlnum{1}\hlstd{]}
\hlkwd{head}\hlstd{(df11,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   B A C
## 1 3 1 A
## 2 3 2 B
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{warningbox}

Taking into account that \Rfunction{order()} returns the indexes needed to sort a vector (see page \pageref{box:vec:sort}), we can use \Rfunction{order()} to generate the indexes needed to sort the rows of a data frame. In this case, the argument to \Rfunction{order()} is usually a column of the data frame being arranged. However, any vector of suitable length, including the result of applying a function to one or more columns, can be passed as an argument to \Rfunction{order()}. Function \Rfunction{order()} is not useful for sorting columns of data frames \emph{based on data from the columns} as it requires a vector across columns as input, which is possible only when all columns are of the same class. (In the case of \Rclass{matrix} and \Rclass{array} this approach can be applied to any of their dimensions as all their elements homogenously belong to one class.)

\begin{faqbox}{How to order columns or rows in a data frame?}
We use column names or numeric indexes with the extraction operator \Roperator{[ ]} only on the \emph{rhs} of the assignment. For example, to arrange the columns of data set \code{iris} in decreasing alphabetical order, we use \Rfunction{sort()} as shown, or \Rfunction{order()} (see page \pageref{box:vec:sort}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sorted_cols_iris} \hlkwb{<-} \hlstd{iris[ ,} \hlkwd{sort}\hlstd{(}\hlkwd{colnames}\hlstd{(iris),} \hlkwc{decreasing} \hlstd{=} \hlnum{TRUE}\hlstd{)]}
\hlkwd{head}\hlstd{(sorted_cols_iris,} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   Species Sepal.Width Sepal.Length Petal.Width Petal.Length
## 1  setosa         3.5          5.1         0.2          1.4
## 2  setosa         3.0          4.9         0.2          1.4
## 3  setosa         3.2          4.7         0.2          1.3
## 4  setosa         3.1          4.6         0.2          1.5
## 5  setosa         3.6          5.0         0.2          1.4
\end{verbatim}
\end{kframe}
\end{knitrout}

Similarly, we can use values in a column as argument to \Rfunction{order()} to obtain the \code{numeric} indices to sort rows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sorted_rows_iris} \hlkwb{<-} \hlstd{iris[}\hlkwd{order}\hlstd{(iris}\hlopt{$}\hlstd{Petal.Length), ]}
\hlkwd{head}\hlstd{(sorted_rows_iris,} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 23          4.6         3.6          1.0         0.2  setosa
## 14          4.3         3.0          1.1         0.1  setosa
## 15          5.8         4.0          1.2         0.2  setosa
## 36          5.0         3.2          1.2         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

\begin{advplayground}\index{data frames!ordering rows}
Create a new data frame containing three numeric columns with three different haphazard sequences of values and a factor with two levels. Call these columns \code{A}, \code{B}, \code{C} and \code{F}. 1) Sort the rows of the data frame so that the values in \code{A} are in decreasing order. 2) Sort the rows of the data frame according to increasing values of the sum of \code{A} and \code{B} without adding a new column to the data frame or storing the vector of sums in a variable. In other words, do the sorting based on sums calculated on-the-fly. 1) Sort the rows by level of factor \code{F}, and 2) by level of factor \code{F} and by values in \code{B} within each factor level. Hint: revisit the exercise on page \pageref{calc:ADVPG:order:sort} were the use of \Rfunction{order()} on factors is described.
\end{advplayground}

\subsection{Re-encoding or adding variables}

It is common that some variables need to be added to an existing data frame based on existing variables, either as a computed value or based on mapping, for example, treatments to sample codes already in a data frame. In the second case, named\index{named vectors!mapping with} vectors can be used to replace values in a variable or to add a variable to a data frame.

Mapping is possible because the length of the value returned by the extraction operator \Roperator{[ ]} is given by the length of the indexing vector (see section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}). Although we show toy-like examples, this approach is most useful with data frames containing many rows.

If the existing variable is a character vector or factor, we need to create a named vector with the new values as data and the existing values as names.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df12} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{genotype} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"WT"}\hlstd{,} \hlstr{"mutant1"}\hlstd{,} \hlstr{"mutant2"}\hlstd{),} \hlnum{2}\hlstd{),}
             \hlkwc{value} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1.5}\hlstd{,} \hlnum{3.2}\hlstd{,} \hlnum{4.5}\hlstd{,} \hlnum{8.2}\hlstd{,} \hlnum{7.4}\hlstd{,} \hlnum{6.2}\hlstd{))}
\hlstd{mutant} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwc{WT} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{mutant1} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{mutant2} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{df12}\hlopt{$}\hlstd{mutant} \hlkwb{<-} \hlstd{mutant[df12}\hlopt{$}\hlstd{genotype]}
\hlstd{df12}
\end{alltt}
\begin{verbatim}
##   genotype value mutant
## 1       WT   1.5  FALSE
## 2  mutant1   3.2   TRUE
## 3  mutant2   4.5   TRUE
## 4       WT   8.2  FALSE
## 5  mutant1   7.4   TRUE
## 6  mutant2   6.2   TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

If the existing variable is an \code{integer} vector, we can use a vector without names, being careful that the positions in the \emph{mapping} vector match the values of the existing variable

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df13} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{individual} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{,} \hlnum{2}\hlstd{),}
                   \hlkwc{value} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1.5}\hlstd{,} \hlnum{3.2}\hlstd{,} \hlnum{4.5}\hlstd{,} \hlnum{8.2}\hlstd{,} \hlnum{7.4}\hlstd{,} \hlnum{6.2}\hlstd{))}
\hlstd{genotype} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"WT"}\hlstd{,} \hlstr{"mutant1"}\hlstd{,} \hlstr{"mutant2"}\hlstd{)}
\hlstd{df13}\hlopt{$}\hlstd{genotype} \hlkwb{<-} \hlstd{genotype[df13}\hlopt{$}\hlstd{individual]}
\hlstd{df13}
\end{alltt}
\begin{verbatim}
##   individual value genotype
## 1          1   1.5       WT
## 2          2   3.2  mutant1
## 3          3   4.5  mutant2
## 4          1   8.2       WT
## 5          2   7.4  mutant1
## 6          3   6.2  mutant2
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Add a variable named \code{genotype} to the data frame below so that for individual \code{4} its value is \code{"WT"}, for individual \code{1} its value is \code{"mutant1"}, and for individual \code{2} its value is \code{"mutant2"}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{DF1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{individual} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{1}\hlstd{),} \hlnum{2}\hlstd{),}
                  \hlkwc{value} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1.5}\hlstd{,} \hlnum{3.2}\hlstd{,} \hlnum{4.5}\hlstd{,} \hlnum{8.2}\hlstd{,} \hlnum{7.4}\hlstd{,} \hlnum{6.2}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

\subsection{Operating within data frames}\label{sec:calc:df:with}

In the case of computing new values from existing variables, named vectors are of limited use. Instead, variables in a data frame can be added or modified with \Rlang functions \Rscoping{transform()}, \Rscoping{with()} and \Rscoping{within()}. These functions can be thought as convenience functions as the same computations can be done using the extraction operators to access individual variables, in the lhs, rhs, or both lhs and rhs (see section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}).

In the case of \Rscoping{with()}, only one, possibly compound code statement is affected and this statement is passed as an argument. As before, we need to fully specify the left-hand side of the assignment. The value returned is the one returned by the statement passed as an argument, in the case of compound statements, the value returned by the last contained simple code statement to be executed. Consequently, if the intent is to modify the container, assignment to an individual member variable (column in this case) is required.

In this example, column \code{A} of \code{df14} takes precedence, and the returned value is the expected one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df14} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{A} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{B} \hlstd{=} \hlnum{3}\hlstd{)}
\hlstd{df14}\hlopt{$}\hlstd{C} \hlkwb{<-} \hlkwd{with}\hlstd{(df14, (A} \hlopt{+} \hlstd{B)} \hlopt{/} \hlstd{A)} \hlcom{# add column}
\hlkwd{head}\hlstd{(df14,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B   C
## 1 1 3 4.0
## 2 2 3 2.5
## 3 3 3 2.0
\end{verbatim}
\end{kframe}
\end{knitrout}

In the case of \Rscoping{within()}, assignments in the argument to its second parameter affect the object returned, which is a copy of the container (in this case, a whole data frame), which still needs to be saved through assignment. Here the intention is to modify it, so we assign it back to the same name, but it could have been assigned to a different name so as not to overwrite the original data frame.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df14}\hlopt{$}\hlstd{C} \hlkwb{<-} \hlkwa{NULL}
\hlstd{df15} \hlkwb{<-} \hlkwd{within}\hlstd{(df14,  C} \hlkwb{<-} \hlstd{(A} \hlopt{+} \hlstd{B)} \hlopt{/} \hlstd{A)} \hlcom{# midified copy}
\hlkwd{head}\hlstd{(df15,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B   C
## 1 1 3 4.0
## 2 2 3 2.5
## 3 3 3 2.0
\end{verbatim}
\end{kframe}
\end{knitrout}

In the example above, using \code{within()} instead of \Rscoping{with()} makes little difference to the amount of typing or clarity of the code, but with multiple member variables being operated upon, as shown below, using \Rscoping{within()} results in more concise and easier to understand code.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df16} \hlkwb{<-} \hlkwd{within}\hlstd{(df14,}
               \hlstd{\{C} \hlkwb{<-} \hlstd{(A} \hlopt{+} \hlstd{B)} \hlopt{/} \hlstd{A}
                \hlstd{D} \hlkwb{<-} \hlstd{A} \hlopt{*} \hlstd{B}
                \hlstd{E} \hlkwb{<-} \hlstd{A} \hlopt{/} \hlstd{B} \hlopt{+} \hlnum{1}\hlstd{\}}
               \hlstd{)}
\hlkwd{head}\hlstd{(df16,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B        E D   C
## 1 1 3 1.333333 3 4.0
## 2 2 3 1.666667 6 2.5
## 3 3 3 2.000000 9 2.0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Repeatedly pre-pending the name of a \emph{container}, such as a list or data frame, to the name of each member variable being accessed can make \Rlang code verbose and difficult to understand. Functions \Rscoping{attach()} and its matching \Rscoping{detach()} allow us to change where \Rlang first looks for the names of objects mentioned in a code statement. When using a long name for a data frame, entering a simple calculation can easily result in a difficult-to-read statement. Here even with a very short name for the data frame, the verbosity compared to the last chunk above is clear.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df14}\hlopt{$}\hlstd{C} \hlkwb{<-} \hlstd{(df14}\hlopt{$}\hlstd{A} \hlopt{+} \hlstd{df14}\hlopt{$}\hlstd{B)} \hlopt{/} \hlstd{df14}\hlopt{$}\hlstd{A}
\hlstd{df14}\hlopt{$}\hlstd{D} \hlkwb{<-} \hlstd{df14}\hlopt{$}\hlstd{A} \hlopt{*} \hlstd{df14}\hlopt{$}\hlstd{B}
\hlstd{df14}\hlopt{$}\hlstd{D} \hlkwb{<-} \hlstd{df14}\hlopt{$}\hlstd{A} \hlopt{/} \hlstd{df14}\hlopt{$}\hlstd{B} \hlopt{+} \hlnum{1}
\hlkwd{head}\hlstd{(df14,} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B   C        D
## 1 1 3 4.0 1.333333
## 2 2 3 2.5 1.666667
## 3 3 3 2.0 2.000000
\end{verbatim}
\end{kframe}
\end{knitrout}

Using\index{data frames!attaching}\label{par:calc:attach} \Rscoping{attach()} we can alter where \Rlang looks up names and consequently simplify the statement. With \Rscoping{detach()} we can restore the original state. It is important to remember that here we can only simplify the right-hand side of the assignment, while the ``destination'' of the result of the computation still needs to be fully specified on the left-hand side of the assignment operator. We include below only one statement between \Rscoping{attach()} and \Rscoping{detach()} but multiple statements are allowed. Furthermore, if variables with the same name as the columns exist in the search path, these will take precedence, something that can result in bugs or crashes, or as seen below, a message warns that variable \code{A} from the global environment will be used instead of column \code{A} of the attached \code{df17}. The returned value is, of course, not the desired one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df17} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{A} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{B} \hlstd{=} \hlnum{3}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{attach}\hlstd{(df17)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# The following object is masked \_by\_ .GlobalEnv:\\\#\# \\\#\# \ \ \ \ A}}\begin{alltt}
\hlstd{A}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{detach}\hlstd{(df17)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attach}\hlstd{(df17)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# The following object is masked \_by\_ .GlobalEnv:\\\#\# \\\#\# \ \ \ \ A}}\begin{alltt}
\hlstd{df17}\hlopt{$}\hlstd{C} \hlkwb{<-} \hlstd{(A} \hlopt{+} \hlstd{B)} \hlopt{/} \hlstd{A}
\hlkwd{detach}\hlstd{(df17)}
\hlkwd{head}\hlstd{(df17,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   A B C
## 1 1 3 4
## 2 2 3 4
\end{verbatim}
\end{kframe}
\end{knitrout}

Use of \Rscoping{attach()} and \Rscoping{detach()}, which work as a pair of ON and OFF switches, can result in an undesired after-effect on name lookup if the script terminates after \Rscoping{attach()} is executed but before \Rscoping{detach()} is called, as the attached object is not detached. In contrast, \Rscoping{with()} and \Rscoping{within()}, being self-contained, guarantee that cleanup takes place. Consequently, the usual recommendation is to give preference to the use of \Rscoping{with()} and \Rscoping{within()} over \Rscoping{attach()} and \Rscoping{detach()}.
\end{explainbox}



\section{Reshaping and Editing Data Frames}\label{sec:calc:reshape}
\index{data frames!long vs.\ wide shape}

As mentioned above, in most cases, in \Rlang data rows represent measurement events or observations possibly on multiple response variables and factors describing groupings, i.e., a ``long'' shape. However, when measurements are repeated in time, columns rather frequently represent observations of the same response variable at different times, i.e., a ``wide'' shape. Other cases exist where reshaping is needed. Function \Rfunction{reshape()} can convert wide data frames into long data frames and vice versa. See section \ref{sec:data:reshape} on page \pageref{sec:data:reshape} on package \pkgnameNI{tidyr} for an alternative approach to reshaping data with a friendlier user interface.

We start by creating a data frame of hypothetical data measured on two occasions. With these data, for example, if we wish to compute the growth of each subject by computing the difference in \code{weight} and \code{height} between the two time points, one approach is to reshape the data frame into a wider shape and subsequently subtract the columns.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# artifical data}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{id} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{,} \hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,}\hlnum{4}\hlstd{)),}
                  \hlkwc{Time} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"Before"}\hlstd{,}\hlstr{"After"}\hlstd{),} \hlnum{4}\hlstd{)),}
                  \hlkwc{Weight} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{20.1}\hlstd{,} \hlnum{30.8}\hlstd{)),}
                  \hlkwc{Height} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{9.5}\hlstd{,} \hlnum{14.2}\hlstd{)))}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   id   Time   Weight    Height
## 1  1 Before 20.28759 10.080444
## 2  1  After 30.08700 14.804013
## 3  2 Before 19.69200  8.322311
## 4  2  After 30.27411 11.941568
## 5  3 Before 20.28759 10.080444
## 6  3  After 30.08700 14.804013
## 7  4 Before 19.69200  8.322311
## 8  4  After 30.27411 11.941568
\end{verbatim}
\begin{alltt}
\hlcom{# make it wider}
\hlstd{df2} \hlkwb{<-} \hlkwd{reshape}\hlstd{(df1,} \hlkwc{timevar} \hlstd{=} \hlstr{"Time"}\hlstd{,} \hlkwc{idvar} \hlstd{=} \hlstr{"id"}\hlstd{,} \hlkwc{direction} \hlstd{=} \hlstr{"wide"}\hlstd{)}
\hlstd{df2}
\end{alltt}
\begin{verbatim}
##   id Weight.Before Height.Before Weight.After Height.After
## 1  1      20.28759     10.080444     30.08700     14.80401
## 3  2      19.69200      8.322311     30.27411     11.94157
## 5  3      20.28759     10.080444     30.08700     14.80401
## 7  4      19.69200      8.322311     30.27411     11.94157
\end{verbatim}
\begin{alltt}
\hlcom{# possible further calculation}
\hlkwd{within}\hlstd{(df2,}
       \hlstd{\{}
        \hlstd{Height.growth} \hlkwb{<-} \hlstd{Height.After} \hlopt{-} \hlstd{Height.Before}
        \hlstd{Weight.growth} \hlkwb{<-} \hlstd{Weight.After} \hlopt{-} \hlstd{Weight.Before}
       \hlstd{\})}
\end{alltt}
\begin{verbatim}
##   id Weight.Before Height.Before Weight.After Height.After Weight.growth
## 1  1      20.28759     10.080444     30.08700     14.80401       9.79941
## 3  2      19.69200      8.322311     30.27411     11.94157      10.58211
## 5  3      20.28759     10.080444     30.08700     14.80401       9.79941
## 7  4      19.69200      8.322311     30.27411     11.94157      10.58211
##   Height.growth
## 1      4.723569
## 3      3.619258
## 5      4.723569
## 7      3.619258
\end{verbatim}
\end{kframe}
\end{knitrout}

Alternatively, we may want to convert \code{df1} into a longer shape, with a single column with measurements, and a new column indicating whether the measured variable was \code{height} or \code{weight}. For this operation to succeed, we need to add a column with a unique value for each row in \code{df1}, and one easy way is to copy row names into a column. The names of the parameters of function \Rfunction{reshape()} are meaningful only when dealing with time series. Thus, reading the code below becomes rather difficult. It is also to be noted that the user is responsible of passing the values to \code{times} in the correct order.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1}\hlopt{$}\hlstd{ID} \hlkwb{<-} \hlkwd{rownames}\hlstd{(df1)} \hlcom{# unique ID for each row}
\hlcom{# make it longer}
\hlkwd{reshape}\hlstd{(df1,}
        \hlkwc{idvar} \hlstd{=} \hlstr{"ID"}\hlstd{,}
        \hlkwc{timevar} \hlstd{=} \hlstr{"Quantity"}\hlstd{,}
        \hlkwc{times} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"Weight"}\hlstd{,} \hlstr{"Height"}\hlstd{),}
        \hlkwc{v.names} \hlstd{=} \hlstr{"Value"}\hlstd{,}
        \hlkwc{direction} \hlstd{=} \hlstr{"long"}\hlstd{,}
        \hlkwc{varying} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"Weight"}\hlstd{,} \hlstr{"Height"}\hlstd{))}
\end{alltt}
\begin{verbatim}
##          id   Time ID Quantity     Value
## 1.Weight  1 Before  1   Weight 20.287592
## 2.Weight  1  After  2   Weight 30.087002
## 3.Weight  2 Before  3   Weight 19.692002
## 4.Weight  2  After  4   Weight 30.274112
## 5.Weight  3 Before  5   Weight 20.287592
## 6.Weight  3  After  6   Weight 30.087002
## 7.Weight  4 Before  7   Weight 19.692002
## 8.Weight  4  After  8   Weight 30.274112
## 1.Height  1 Before  1   Height 10.080444
## 2.Height  1  After  2   Height 14.804013
## 3.Height  2 Before  3   Height  8.322311
## 4.Height  2  After  4   Height 11.941568
## 5.Height  3 Before  5   Height 10.080444
## 6.Height  3  After  6   Height 14.804013
## 7.Height  4 Before  7   Height  8.322311
## 8.Height  4  After  8   Height 11.941568
\end{verbatim}
\end{kframe}
\end{knitrout}

To edit a data frame programmatically, one can use the approaches already discussed, using the extraction operators \Roperator{[ ]} or \Roperator{[[ ]]} on the \emph{lhs} of \Roperator{<-} to replace member elements. This in combination with functions like \Rfunction{gsub()} makes it possible to ``edit'' the contents of data frames.

Methods \Rfunction{View()}, \Rfunction{edit()} and \Rfunction{fix()} can be used interactively to display and edit \Rlang objects. When using \Rpgrm from within IDEs like \RStudio, calling these functions with a data frame as argument opens in most cases the IDE's own worksheet-like data editors, and for other types of objects a text editor pane. Output is not included for this chunk, as the use of these functions requires user interaction. Please, run these examples in \Rpgrm and in an IDE like \RStudio.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{View}\hlstd{(cars)}
\hlkwd{edit}\hlstd{(cars)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{explainbox}
These functions can be used at the \Rlang console also when \Rpgrm is used on its own, but the editors activated are different ones. In any case, the use of scripts has made the interactive use of \Rpgrm at the console less frequent and the need to edit \Rlang objects previously saved in the user's current workspace nearly disappear. \Rfunction{View()}, \Rfunction{edit()} and \Rfunction{fix()} are unusual in that their definitions are dependent on system variables that at least when using \Rpgrm on its own, can be modified by the user.
\end{explainbox}

\index{data frames|)}



\section{Attributes of \Rlang Objects}\label{sec:calc:attributes}
\index{attributes|(}

\Rlang objects can have attributes. Attributes are named \emph{slots} normally used to store ancillary data such as object properties functioning as additional fields where to store additional information in any \Rlang object. There are no restrictions on the class of what is assigned to an attribute. They can be used to store metadata accompanying the data stored in an object, which is important for reproducible research and data sharing. They can be set and read by user code and they are also used internally by \Rlang among other things to store the class an object belongs to, column and row names in data frames and matrices and the labels of levels in factors. Although most \Rlang objects have attributes, they are rarely displayed explicitly when an object is printed, while the structure of objects as displayed by function \Rfunction{str()} includes them.

Although we rarely need to set or extract values stored in attributes explicitly, many of the features of \Rlang that we take for granted are implemented using attributes: columns names in data frames are stored in an attribute. Matrices are vectors with additional attributes.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{),} \hlkwc{z} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{NA}\hlstd{))}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   x y     z
## 1 1 a  TRUE
## 2 2 b FALSE
## 3 3 a    NA
## 4 4 b  TRUE
## 5 5 a FALSE
## 6 6 b    NA
\end{verbatim}
\begin{alltt}
\hlkwd{attributes}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## $names
## [1] "x" "y" "z"
## 
## $class
## [1] "data.frame"
## 
## $row.names
## [1] 1 2 3 4 5 6
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## 'data.frame':	6 obs. of  3 variables:
##  $ x: int  1 2 3 4 5 6
##  $ y: chr  "a" "b" "a" "b" ...
##  $ z: logi  TRUE FALSE NA TRUE FALSE NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Attribute \code{"comment"} is meant to be set by users to store a character string---e.g., to store metadata as text together with data. As comments are frequently used, \Rlang has functions for accessing and setting comments. \qRfunction{comment()}\qRfunction{comment()<-}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{comment}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlkwd{comment}\hlstd{(df1)} \hlkwb{<-} \hlstr{"this is stored as a comment"}
\hlkwd{comment}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "this is stored as a comment"
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions like \Rfunction{names()}, \Rfunction{dim()} or \Rfunction{levels()} return values retrieved from attributes stored in \Rlang objects, whereas \Rfunction{names()<-}, \Rfunction{dim()<-} or \Rfunction{levels()<-} set (or unset with \code{NULL}) the value of the respective attributes. Dedicated query and set functions do not exist for all attributes. Functions \Rfunction{attr()}, \Rfunction{attr()<-} and \Rfunction{attributes()} can be used with any attribute. With \Rfunction{attr()} we query, and with  \Rfunction{attr()<-} we set individual attributes by name. With \Rfunction{attributes()} we retrieve all attributes of an object as a named \code{list}. In addition, method \Rfunction{str()} displays the structure of an \Rlang object with all its components, including their attributes.

Continuing with the previous example, we can retrieve and set the value stored in the \code{"comment"}  attribute using these functions. In the second statement, we delete the value stored in the attribute by assigning \code{NULL} to it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(df1,} \hlstr{"comment"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "this is stored as a comment"
\end{verbatim}
\begin{alltt}
\hlkwd{attr}\hlstd{(df1,} \hlstr{"comment"}\hlstd{)} \hlkwb{<-} \hlkwa{NULL}
\hlkwd{attr}\hlstd{(df1,} \hlstr{"comment"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlkwd{comment}\hlstd{(df1)} \hlcom{# same as previous line}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

The \code{"names"} attribute of \code{df1} was set by the \code{data.frame()} constructor when it was created above. In the next example, in the first statement we retrieve the names and implicitly print them. In the second statement, read from right to left, we retrieve the names, convert them to upper case, and save them back to the same attribute. \qRfunction{colnames()}\qRfunction{colnames()<-}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{names}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "x" "y" "z"
\end{verbatim}
\begin{alltt}
\hlkwd{colnames}\hlstd{(df1)} \hlcom{# same as names()}
\end{alltt}
\begin{verbatim}
## [1] "x" "y" "z"
\end{verbatim}
\begin{alltt}
\hlkwd{colnames}\hlstd{(df1)} \hlkwb{<-} \hlkwd{toupper}\hlstd{(}\hlkwd{colnames}\hlstd{(df1))}
\hlkwd{colnames}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## [1] "X" "Y" "Z"
\end{verbatim}
\begin{alltt}
\hlkwd{attr}\hlstd{(df1,} \hlstr{"names"}\hlstd{)} \hlcom{# same as previous line}
\end{alltt}
\begin{verbatim}
## [1] "X" "Y" "Z"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
  In general, \Rlang objects do not have by default names assigned to members. As seen on page \pageref{par:calc:vector:map}, we can give names to vector members during construction with a call to \Rfunction{c()} or we can assign names (set attribute \code{names}) with function \Rfunction{names()<-} to existing vectors. Lists behave almost the same as vectors, although members of nested objects can also be named. Data frames have attributes \code{names} and \code{row.names}, that can be accessed with functions \Rfunction{names()} or \Rfunction{colnames()}, and function \Rfunction{rownames()}, respectively. The attributes can be set with functions \Rfunction{names()<-} or \Rfunction{colnames()<-}, and \Rfunction{rownames()<-}. The \Rfunction{data.frame()} constructor sets (column) names and row names by default. The \Rfunction{matrix()} constructor by default does not set \code{dimnames} or \code{names} attributes. When names are assigned to a \code{matrix} with \Rfunction{names()<-}, the matrix behaves like a vector, and the names are assigned to individual members. Functions \Rfunction{dimnames()<-}, \Rfunction{colnames()<-}, and \Rfunction{rownames()<-} are used to assign names to columns and rows. The matching functions \Rfunction{dimnames()}, \Rfunction{colnames()} and \Rfunction{rownames()} are used to access these values.

  When no names have been set, \Rfunction{names()}, \Rfunction{colnames()}, \Rfunction{rownames()}, and \Rfunction{dimnames()} return \code{NULL}. In contrast, \Rfunction{labels()}, intended to be used for printing, returns made-up names based on positions.

  Run the examples below and write similar examples for a \code{list} and a \code{data.frame}. For \code{matrix}, write an additional statement that uses \Rfunction{dimnames()<-} to set row and column names simultaneously.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{VCT1} \hlkwb{<-} \hlnum{5}\hlopt{:}\hlnum{10}
\hlkwd{names}\hlstd{(VCT1)}
\hlkwd{labels}\hlstd{(VCT1)}
\hlkwd{names}\hlstd{(VCT1)} \hlkwb{<-} \hlstd{letters[}\hlnum{5}\hlopt{:}\hlnum{10}\hlstd{]}
\hlkwd{names}\hlstd{(VCT1)}
\hlkwd{labels}\hlstd{(VCT1)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{MAT1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{)}
\hlkwd{dimnames}\hlstd{(MAT1)}
\hlkwd{labels}\hlstd{(MAT1)}
\hlkwd{colnames}\hlstd{(MAT1)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlstr{"b"}\hlstd{)}
\hlkwd{colnames}\hlstd{(MAT1)}
\hlkwd{dimnames}\hlstd{(MAT1)}
\hlkwd{labels}\hlstd{(MAT1)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

We can add a new attribute, under our own control, as long as its name does not clash with those of existing attributes.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(df1,} \hlstr{"my.attribute"}\hlstd{)} \hlkwb{<-} \hlstr{"this is stored in my attribute"}
\hlkwd{attributes}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## $names
## [1] "X" "Y" "Z"
## 
## $class
## [1] "data.frame"
## 
## $row.names
## [1] 1 2 3 4 5 6
## 
## $my.attribute
## [1] "this is stored in my attribute"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
The attributes used internally by \Rlang can be directly modified by user code. In most cases, this is unnecessary as \Rlang provides pairs of functions to query and set the relevant attributes. This is true for the attributes \code{dim}, \code{names} and \code{levels}. In the example below, we read the attributes from a matrix.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{)}
\hlkwd{attributes}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## $dim
## [1] 5 2
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## [1] 5 2
\end{verbatim}
\begin{alltt}
\hlkwd{dimnames}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{labels}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
## [[1]]
## [1] "1" "2" "3" "4" "5"
## 
## [[2]]
## [1] "1" "2"
\end{verbatim}
\begin{alltt}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2]
## [1,]    1    6
## [2,]    2    7
## [3,]    3    8
## [4,]    4    9
## [5,]    5   10
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(mat1,} \hlstr{"dim"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 5 2
\end{verbatim}
\begin{alltt}
\hlkwd{attr}\hlstd{(mat1,} \hlstr{"dim"}\hlstd{)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{)}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(mat1,} \hlstr{"dim"}\hlstd{)} \hlkwb{<-} \hlkwa{NULL}
\hlkwd{is.vector}\hlstd{(mat1 )}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}
\end{kframe}
\end{knitrout}

In this case we can also use \Rfunction{dim()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dim}\hlstd{(mat1)} \hlkwb{<-} \hlkwa{NULL}
\hlkwd{is.vector}\hlstd{(mat1 )}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{warningbox}
There is no restriction to the creation, setting, resetting, and reading of attributes, but not all functions and operators that can be used to modify objects will preserve non-standard attributes. This can be a problem when using some \Rlang packages, such as the \pkgname{tidyverse}. So, using private attributes is a double-edged sword that usually is worthwhile considering only when designing a new class together with the corresponding methods for it. The values returned by model fitting functions like \Rfunction{lm()} are good examples of the extensive use of class-specific attributes (see section \ref{sec:stat:LM} on page \pageref{sec:stat:LM}).
\end{warningbox}



\index{attributes|)}

\section{Saving and Loading Data}

\subsection{Data sets in \Rlang and packages}
\index{data!loading data sets|(}\index{data!saving data sets|(}
To be able to present more meaningful examples, we need some real data. Here we use \code{cars}, one of the many data sets included in base \Rpgrm. Function \Rfunction{data()} is used to load data objects that are included in \Rlang or contained in packages (whether a call to \Rfunction{data()} is needed or not depends on how the package where the data objects are defined was configured). It is also possible to import data saved in files with \textit{foreign} formats, defined by other software or commonly used for data exchange. Package \pkgname{foreign}, included in the \Rlang distribution, as well as contributed packages make available functions capable of reading and decoding various foreign formats. How to read or import `foreign' data is discussed in the \Rlang documentation, in the manual \emph{R Data Import/Export}, and in this book, in chapter \ref{chap:R:data:io} on page \pageref{chap:R:data:io}. It is also good to keep in mind that in \Rlang, URLs (Uniform Resource Locators) are accepted as arguments to the \code{file} or \code{path} parameter of many functions (see section \ref{sec:files:remote} on page \pageref{sec:files:remote}).

In the next example, we load data available in \Rlang package \pkgname{datasets} as \Rlang objects by calling function \Rfunction{data()}. The loaded \Rlang object \code{cars} is a data frame. (Package \pkgname{datasets} is part of the \Rpgrm distribution and is always available).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(cars)}
\end{alltt}
\end{kframe}
\end{knitrout}

%Once we have a data set available, the first step is usually to explore it, and we will do this with \code{cars} in section \ref{sec:calc:looking:at:data} on page \pageref{sec:calc:looking:at:data}.
%\index{data!loading data sets|)}

\subsection{.rda files}\label{sec:data:rda}

By\index{file formats!RDA ``R data, multiple objects''} default, at the end of a session, the current workspace containing the results of one's work is saved into a file called \code{.RData}. In addition to saving the whole workspace, it is possible to save one or more \Rlang objects present in the workspace to disk using the same file format (with file name tag \code{.rda} or \code{.Rda}). One or more objects, belonging to any mode or class can be saved into a single file using function \Rfunction{save()}. Reading the file restores all the saved objects into the current workspace with their original names. These files are portable across most \Rlang versions---i.e., old formats can be read and written by newer versions of \Rpgrm, although the newer, default format may be not readable with earlier \Rpgrm versions. Whether compression is used, and whether the ``binary'' data are encoded into ASCII characters, allowing maximum portability at the expense of increased size can be controlled by passing suitable arguments to \Rfunction{save()}.

We create a data frame object and then save it to a file. The file name used can be any valid one in the operating system, however to ensure compatibility with multiple operating systems, it is good to use only ASCII characters. Although not enforced, using the name tag \code{.rda} or \code{.Rda} is recommended.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{5}\hlopt{:}\hlnum{1}\hlstd{)}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   x y
## 1 1 5
## 2 2 4
## 3 3 3
## 4 4 2
## 5 5 1
\end{verbatim}
\begin{alltt}
\hlkwd{save}\hlstd{(df1,} \hlkwc{file} \hlstd{=} \hlstr{"df1.rda"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We delete the data frame object and confirm that it is no longer present in the workspace (see page \pageref{par:calc:remove} for details about \Rfunction{remove()} and \Rfunction{objects()}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{remove}\hlstd{(df1)}
\hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"df1"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## character(0)
\end{verbatim}
\end{kframe}
\end{knitrout}

We read the file we earlier saved to restore the object.\qRfunction{load()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{load}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"df1.rda"}\hlstd{)}
\hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"df1"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "df1"
\end{verbatim}
\begin{alltt}
\hlstd{df1}
\end{alltt}
\begin{verbatim}
##   x y
## 1 1 5
## 2 2 4
## 3 3 3
## 4 4 2
## 5 5 1
\end{verbatim}
\end{kframe}
\end{knitrout}

The default format used is binary and compressed, which results in smaller files.

\begin{playground}
In the example above, only one object was saved, but one can simply give the bare names of additional objects as arguments separated by commas ahead of \code{file}. Just try saving more than one data frame to the same file. Then the data frames plus a few vectors. After creating each file, clear the workspace and then restore from the file the objects you saved.
\end{playground}

Sometimes it is easier to supply the names of the objects to be saved as a vector of \code{character} strings passed as an argument to parameter \code{list} (in spite of the name the argument passed must be a \code{vector}, not a \code{list}). One use case is saving a group of objects based on their names. In this case, one can use \Rfunction{objects()} (also available as \Rfunction{ls()}) to obtain a vector of \code{character} strings with the names of objects matching a simple \code{pattern} or a complex \emph{regular expression} (see section \ref{sec:calc:regex} on page \pageref{sec:calc:regex}). The example below uses this approach in two steps, first saving in variable \code{dfs} a \code{character} \code{vector} with the names of the objects matching a pattern, and then using this saved vector as an argument to parameter \code{list} in the call to \Rfunction{save()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{dfs} \hlkwb{<-} \hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"*.df"}\hlstd{)}
\hlkwd{save}\hlstd{(}\hlkwc{list} \hlstd{= dfs,} \hlkwc{file} \hlstd{=} \hlstr{"my-dfs.rda"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

The two statements above can be combined into a single statement by nesting the function calls.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{save}\hlstd{(}\hlkwc{list} \hlstd{=} \hlkwd{objects}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"*.df"}\hlstd{),} \hlkwc{file} \hlstd{=} \hlstr{"my-dfs.rda"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Practice using different patterns with \Rfunction{objects()}. You do not need to save the objects to a file. Just have a look at the list of object names returned.
\end{playground}

As a coda, I show how to clean up by deleting the two files we created. Function \Rfunction{file.remove()} can be used to delete files stored in the operating system file system, usually on a hard disk drive or a solid state drive, as long as the user has enough rights. No confirmation is requested, so care not to delete valuable files is required. Function \Rfunction{unlink()}, is not an exact equivalent, as it can also delete folders and supports recursion through nested folders. The name \emph{unlink} is borrowed from that of the equivalent function in \osnameNI{Unix} and \osnameNI{Linux}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{file.remove}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"my-dfs.rda"}\hlstd{,} \hlstr{"df1.rda"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] TRUE TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{.rds files}\label{sec:data:rds}

The\index{file formats!RDS ``R data, single object''} RDS format can be used to save individual objects instead of multiple objects (usually using file name tag \code{.rds}). They are read and saved with functions \Rfunction{readRDS()} and \Rfunction{saveRDS()}, respectively. The value returned by a call to  \Rfunction{readRDS()} is the object read from the file on disk. When RDS files are read, different from when RDA files are loaded, assigning the object read to a name is frequently the first step. This name can be any valid \Rlang name. Of course, it is also possible to use the object returned by \Rfunction{readRDS()} as an argument to a function by nesting the function calls.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{saveRDS}\hlstd{(df1,} \hlstr{"df1.rds"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

If we read the file at the \Rpgrm console, by default the read \Rlang object will be printed at the console.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{readRDS}\hlstd{(}\hlstr{"df1.rds"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   x y
## 1 1 5
## 2 2 4
## 3 3 3
## 4 4 2
## 5 5 1
\end{verbatim}
\end{kframe}
\end{knitrout}

If we assign the read object to a different name, it is possible to check if the object read is identical to the one saved.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df2} \hlkwb{<-} \hlkwd{readRDS}\hlstd{(}\hlstr{"df1.rds"}\hlstd{)}
\hlkwd{identical}\hlstd{(df1, df2)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

As above, we clean up by deleting the file.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{file.remove}\hlstd{(}\hlstr{"df1.rds"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{\code{dput()}}

In\index{file formats!R data ``deparsed object''} general, the use of \code{.rda} and {.rds} files is preferred. Function \Rfunction{dput()} is sometimes used to share data as part of a code chunk at StackOverflow, mostly as a convenient way of converting a data frame or list into plain text that can be pasted into the code chunk listing to reconstruct the object. If no argument is passed to parameter \code{file}, the result of deparsing an object is printed at the \Rlang console.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dput}\hlstd{(df1)}
\end{alltt}
\begin{verbatim}
## structure(list(x = 1:5, y = 5:1), class = "data.frame", row.names = c(NA, 
## -5L))
\end{verbatim}
\end{kframe}
\end{knitrout}

There exists a companion function \Rfunction{dget()} to recreate the object.
\index{data!saving data sets|)}\index{data!loading data sets|)}

\begin{warningbox}
  Output to, and input from, text-based file formats as well as to and from various binary formats \emph{foreign} to \Rlang is described in chapter \ref{chap:R:data:io} on page \pageref{chap:R:data:io}.
\end{warningbox}



\section{Plotting}
\index{plots!base R graphics}
In most cases, the most effective way of obtaining an overview of a data set is by plotting it using multiple approaches. The base-\Rlang generic method \Rfunction{plot()} can be used to plot different data. It is a generic method that has specialisations suitable for different kinds of objects (see section \ref{sec:script:objects:classes:methods} on page \pageref{sec:script:objects:classes:methods} for a brief introduction to objects, classes and methods). In this section, I very briefly demonstrate the use of the most common base-\Rlang graphics functions. They are well described in the book \citebooktitle{Murrell2019} \autocite{Murrell2019}. I describe in detail the use of the \emph{layered grammar of graphics} and plotting with package \ggplot in chapter \ref{chap:R:plotting} on page \pageref{chap:R:plotting}.

\subsection{Plotting data}
It is possible to pass two vectors (here columns from a data frame) directly as arguments to the \code{x} and \code{y} parameters of function \Rfunction{plot()}. (The plot is shown farther down, as the three approaches create identical plots.)



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist)}
\end{alltt}
\end{kframe}
\end{knitrout}

It is also possible to use \Rfunction{with()} or \Rfunction{attach()} as described in section \ref{sec:calc:df:with} on page \pageref{sec:calc:df:with}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{with}\hlstd{(cars,} \hlkwd{plot}\hlstd{(}\hlkwc{x} \hlstd{= speed,} \hlkwc{y} \hlstd{= dist))}
\end{alltt}
\end{kframe}
\end{knitrout}

However, it is better to use a \emph{formula} to specify the variables to be plotted on the $x$ and $y$ axes, passing as an argument to parameter \code{data} a data frame containing these variables as columns. The formula \code{dist \textasciitilde\ speed}, is read as \code{dist} explained by \code{speed}---i.e., \code{dist} is mapped to the $y$-axis as the dependent variable and \code{speed} to the $x$-axis as the independent variable. The names used in the formula, are those of columns in the \code{data.frame}. As described in section \ref{sec:stat:mf} on page \pageref{sec:stat:mf}, the same syntax is used to describe models to be fitted to observations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data} \hlstd{= cars)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-plot-1c-1} 

}


\end{knitrout}

Within \Rlang there exist different specialisations, or ``flavours'', of method \Rfunction{plot()} that become active depending on the class of the variables passed as arguments: passing two numerical variables results in a scatter plot as seen above. In contrast, passing one factor and one numeric variable to \code{plot()} results in a box-and-whiskers plot being produced. Use \code{help("chickwts")} to learn more about this data set, also included in \Rpgrm .

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(weight} \hlopt{~} \hlstd{feed,} \hlkwc{data} \hlstd{= chickwts)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-plot-3-1} 

}


\end{knitrout}

\subsection{Graphical output}
Graphical\index{file formats!PDF}\index{file formats!PNG} output, such as produced by \Rfunction{plot()}, is rendered by \emph{graphical output devices}.
When \Rlang is used interactively, a software device is opened automatically to output the graphical output to a physical device, usually the computer screen. The name of the \Rlang software device used may depend on the operating system (e.g., \osname{MS-Windows} or \osname{Linux}), or on the IDE (e.g., \RStudio).

In \Rlang, software graphical devices not necessarily generate output on a physical device like a printer, as several of these devices translate the plotting commands into a file format and save it to disk. Graphical devices in \Rlang differ in the kind of output they produce: raster or bitmap files (e.g., TIFF, PNG, and JPEG formats), vector graphics files (e.g., SVG, EPS, and PDF), or output to a physical device like the screen of a computer. Additional devices are available through contributed \Rlang packages.

\RStudio makes it possible to export plots into graphic files through a menu-based interface in the \emph{Plots} viewer tab. This interface uses some of the some graphic devices that are available at the console and through scripts. For reproducibility, it is preferable to include the \Rlang commands used to export plots in the scripts used for data analysis.

Devices follow the paradigm of ON and OFF switches, opening and closing a destination for \code{print()}, \code{plot()} and related functions. Some devices producing a file as output, save their output one plot at a time to single-page graphic files, while others write the file only when the device is closed, possibly as a multi-page file.

When opening a device the user supplies additional information. For the PDF and SVG devices that produce output in a vector-graphics format, width and height of the output are specified in \emph{inches}. A default file name is used unless we pass a \code{character} string as an argument to parameter \code{file}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{pdf}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"output/my-file.pdf"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{6}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{onefile} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{plot}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data} \hlstd{= cars)}
\hlkwd{plot}\hlstd{(weight} \hlopt{~} \hlstd{feed,} \hlkwc{data} \hlstd{= chickwts)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\begin{verbatim}
## cairo_pdf 
##         2
\end{verbatim}
\end{kframe}
\end{knitrout}

Raster devices return bitmaps and \code{width} and \code{height} are specified in most cases in \emph{pixels}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{png}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"output/my-file.png"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{600}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{500}\hlstd{)}
\hlkwd{plot}\hlstd{(weight} \hlopt{~} \hlstd{feed,} \hlkwc{data} \hlstd{= chickwts)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\begin{verbatim}
## cairo_pdf 
##         2
\end{verbatim}
\end{kframe}
\end{knitrout}

The approach of direct output to a software device is used in base \Rlang by \Rfunction{plot()} and its companions \Rfunction{text()}, \Rfunction{lines()}, and \Rfunction{points()}. \Rfunction{plot()} outputs a graph, and the other three functions can add elements to it. The addition of plot components, as shown below, is done directly to the output device, i.e., when output is to the computer screen the partial plot is visible at each step.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{png}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"output/my-file.png"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{600}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{500}\hlstd{)}
\hlkwd{plot}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data} \hlstd{= cars)}
\hlkwd{text}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{110}\hlstd{,} \hlkwc{labels} \hlstd{=} \hlstr{"some texts to be added"}\hlstd{)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\begin{verbatim}
## cairo_pdf 
##         2
\end{verbatim}
\end{kframe}
\end{knitrout}
\pagebreak

This is not the only approach available in \Rpgrm for building complex plots. As we will see in chapter \ref{chap:R:plotting} on page \pageref{chap:R:plotting}, an alternative approach is to build a \emph{plot object} as a list of member components, that can be saved as any other \Rlang object. This object functions as a ``recipe'' that is later rendered as a whole on a graphical device by calling \code{print()} to display it.

\index{data!exploration at the R console|)}
\index{data sets!their storage|)}

\section{Further Reading}
For\index{further reading!using the R language} further reading on the aspects of \Rlang discussed in the current chapter, I suggest  the book \citetitle{Matloff2011} \autocite{Matloff2011}, with emphasis on the \Rlang language and programming. The new, open-source, book \citetitle{Gagolewski2023} \autocite{Gagolewski2023} provides a free alternative. This book also covers base \Rlang plotting giving more advanced examples than \textit{Learn R: As a Language}. An in-depth description of plotting and graphic devices in \Rlang is available in the book \citetitle{Murrell2019} \autocite{Murrell2019}.






% !Rnw root = appendix.main.Rnw



\chapter{Base \Rlang: ``Paragraphs'' and ``Essays''}\label{chap:R:scripts}
\index{scripts}

\begin{VF}
An \Rlang script is simply a text file containing (almost) the same commands that you would enter on the command line of \Rlang.

\VA{Jim Lemon}{\emph{Kickstarting R}}\nocite{LemonND}
\end{VF}

%\dictum[\href{https://cran.r-project.org/doc/contrib/Lemon-kickstart/}{Kickstarting R}]{An R script is simply a text file containing (almost) the same commands that you would enter on the command line of R.}\vskip2ex

\section{Aims of This Chapter}

For those who have mainly used graphical user interfaces, understanding why and when scripts can help in communicating a certain data analysis protocol can be revelatory. As soon as a data analysis stops being trivial, describing the steps followed through a system of menus and dialogue boxes becomes extremely tedious.

Moreover, graphical user interfaces tend to be difficult to extend or improve in a way that keeps step-by-step instructions valid across program versions and operating systems.

Many times, exactly the same sequence of commands needs to be applied to different data sets, and scripts make both implementation and validation of such a requirement easy.

In this chapter, I will walk you through the use of \Rpgrm scripts, starting from an extremely simple script.

\section{Writing Scripts}

In \Rlang language, the closest match to a natural language essay is a script. A script is built from multiple interconnected code statements needed to complete a given task. Simple statements, equivalent to sentences, can be combined into compound statements, equivalent to natural language paragraphs. Frequently, we combine simple sequences of statements into a sequence of actions necessary to complete a task. The sequence is not necessarily linear, as branching and repetition are also available.

Scripts can vary from simple scripts containing only a few code statements, to complex scripts containing hundreds of code statements. In the rest of the present section I discuss how to write readable and reliable scripts and how to use them.

\subsection{What is a script?}\label{sec:script:what:is}
\index{scripts!definition}
A \textit{script} is a text file that contains (almost) the same commands that you would type at the \Rlang console prompt. A true script is not, for example, an MS-Word file where you have pasted or typed some \Rlang commands.

When typing commands/statements at the \Rlang console, we ``feed'' one line of text at a time. When we end the line by typing the enter key, the line of text is interpreted and evaluated. We then type the next line of text, which gets in turn interpreted and evaluated, and so on. In a script we write nearly the same text in an editor and save multiple lines containing commands into a text file. Interpretation takes place only later, when we \emph{source} the file as a whole into \Rlang.

A script file has the following characteristics.
\begin{itemize}
  \item The script is a plain text file, i.e., a file containing bytes that represent alphanumeric characters in a standardised character set like UTF8 or ASCII.
  \item The text in the file contains valid \Rlang statements (including comments) and nothing else.
  \item Comments start at a \code{\#} and end at the end of the line.
  \item The \Rlang statements are in the file in the order that they must be executed, and respecting the line continuation rules of \Rlang.
  \item \Rlang scripts customarily have file names ending in \texttt{.r} or \texttt{.R}.
\end{itemize}

\begin{figure}
\centering
\begin{small}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop, color = blue, fill = blue!15] {\textsl{Top (start)}};
\node (stat2) [process, color = blue, fill = blue!15, below of=start] {\code{<statement A>}};
\node (stat3) [process, color = blue, fill = blue!15, below of=stat2] {\code{<statement B>}};
\node (continue) [startstop, color = blue, fill = blue!15, below of=stat3] {$\cdots$};
\node (stop) [startstop, color = blue, fill = blue!15, below of=continue] {\textsl{Bottom (end)}};
\draw [arrow, color = blue] (start) -- (stat2);
\draw [arrow, color = blue] (stat2) -- (stat3);
\draw [arrow, color = blue] (stat3) -- (continue);
\draw [arrow, color = blue] (continue) -- (stop);
\end{tikzpicture}
\end{small}
  \caption[Code statements in a script.]{Diagram of script showing sequentially evaluated code statements; \textcolor{blue}{$\cdots$} represent additional statements in the script.}\label{fig:script}
\end{figure}

The statements in the text file, are read, interpreted, and evaluated sequentially, from the start to the end of the file, as represented in the diagram (Figure \ref{fig:script}).

As we will see later in the chapter, code statements can be combined into larger statements and evaluated conditionally and/or repeatedly, which allows us to control the realised sequence of evaluated statements.

In addition to being valid, it is important that scripts are also understandable to humans. Consequently, a clear writing style and consistent adherence to it are important.

It is good practice to write scripts so that they are self-contained. To make a script self-contained, one must include code to load the packages used, load or import data from files, perform the data analysis, and display and/or save the results of the analysis. Such scripts can be used to apply the same analysis algorithm to other data by reading data from a different file and/or to reproduce the same analysis at a later time using the same data. Such scripts document all steps used for the analysis.



\subsection{How do we use a script?}\label{sec:script:using}
\index{scripts!sourcing}

A script can be ``sourced'' using function \Rfunction{source()}. If a text file called \texttt{my.first.script.r} contains the text
\begin{shaded}
\footnotesize
\begin{verbatim}
# this is my first R script
print(3 + 4)
\end{verbatim}
\end{shaded}

it can be sourced by typing at \Rpgrm console

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{source}\hlstd{(}\hlstr{"my.first.script.r"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 7
\end{verbatim}
\end{kframe}
\end{knitrout}

Execution of the statements in the file makes \Rlang display \code{[1] 7} at the console, below the command we typed in. The commands themselves are not shown (by default the sourced file is not \emph{echoed} to the console) and the results of computations are not printed unless one includes explicit \Rfunction{print()} commands in the script.

Scripts can be run both by sourcing them into an open \Rlang session, or at the operating system command prompt (see section \ref{sec:intro:using:R} on page \pageref{sec:intro:using:R}). In \RStudio, the script in the currently active editor tab can be sourced using the ``source'' button.  The drop-down menu of this button has three entries: ``Source'' , quietly to the \Rlang console; ``Source with echo'' showing the code as it is run; and ``Source as local job'', using a new instance of \Rlang in the background. In the last case, the \Rlang console remains free for other uses while the script is running.

When a script is \emph{sourced}, the output can be saved to a text file instead of being shown in the console. It is also easy to call \Rpgrm with the \Rlang script file as an argument directly at the operating system shell or command-interpreter prompt---and obviously also from shell scripts. The next two chunks show commands entered at the OS shell command prompt rather than at the \Rlang command prompt.

\begin{shaded}
\footnotesize
\begin{verbatim}
RScript my.first.script.r
\end{verbatim}
\end{shaded}

You can open an operating system's \emph{shell} from the Tools menu in \RStudio, to run this command. The output will be printed to the shell console. If you would like to save the output to a file, use output redirection using the operating system's syntax.

\begin{shaded}
\footnotesize
\begin{verbatim}
RScript my.first.script.r > my.output.txt
\end{verbatim}
\end{shaded}

While developing or debugging a script, one usually wants to run (or \emph{execute}) one or a few statements at a time. This can be done in \RStudio using the ``run'' button after either positioning the cursor in the line to be executed, or selecting the text to be run (the selected text can be part of a line, a whole line, or a group of lines, as long as it is syntactically valid). The key-shortcut Ctrl-Enter is equivalent to pressing the ``run'' button.

\subsection{How to write a script}\label{sec:script:writing}
\index{scripts!writing}

As with any type of writing, different approaches may be preferred by different \Rlang users. In general, the approach used, or mix of approaches, will also depend on how confident one is that the statements will work as expected---one already knows the best approach vs.\ one is exploring different alternatives.

Three approaches are listed below. They all can result in equally good code, but as work in progress, they differ. In the first approach, the script as a whole is likely to contain some bugs until being thoroughly tested. In the middle approach, only the most recently added statements are likely to contain bugs. In the last one, the script contains at all times only valid \Rlang code, even if incomplete. This third approach also has the advantage that code remains in the \Rpgrm console \emph{History} and can be retrieved with a delay, e.g., after comparison against an alternative statement.
\begin{description}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
\item[If one is very familiar with similar problems,] one can create a new text file and write the whole script in the editor, testing it only afterwards. Use of this approach is uncommon.
\item[If one is moderately familiar with the problem,] one can write a script as above, but testing it, step by step, while writing it, i.e., running parts of the script before continuing with the writing. This is the approach I use most frequently.
\item[If one is mostly playing around,] one can type statements at the console prompt to try them. As every statement ran at the console is saved to the ``History'',  these previously entered statement(s) can be copied and pasted into the script. In this way one can build a script from statements already known to work correctly.
\end{description}

\begin{playground}
By now you should be familiar enough with \Rlang to be able to write your own script.%
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item Create a new \Rpgrm script (in \RStudio, from the File menu, leftmost ``+'' icon, or by typing ``Ctrl + Shift + N'').
  \item Save the file as \texttt{my.second.script.r}.
  \item Use the editor pane in \RStudio to type some \Rpgrm commands and comments.
  \item \emph{Run} individual commands.
  \item \emph{Source} the whole file.
\end{enumerate}
\end{playground}

\subsection{The need to be understandable to people}\label{sec:script:readability}
\index{scripts!readability}

It is not enough for program code to be understood by a computer and that it returns the correct answer. Both large programs and small scripts have to be readable to humans, and the intention of the code understandable. In most cases, \Rlang code will be maintained, reused, and modified over time. In many cases, this code also serves to document a given computation and to make it possible to reproduce it.

When one writes a script, it is either because one wants to document what has been done or because one plans to use it again in the future. In the first case, other persons will read it, and in the second case, one rarely remembers all the details. Thus, spending time and effort on the writing style, paying special attention to the following recommendations, is important.
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item Avoid the unusual. People using a certain programming language tend to use some implicit or explicit rules of style---style includes \textit{indentation} of statements, \textit{capitalisation} of variable and function names. As a minimum try to be consistent with yourself.
  \item Use meaningful names for variables, and any other object. What is meaningful depends on the context. Depending on common use, a single letter may be more meaningful than a long word. However self-explanatory names are usually better: e.g.,  using \code{n.rows} and \code{n.cols} is much clearer than using \code{n1} and \code{n2} when dealing with a matrix of data. Probably \code{number.of.rows} and \code{number.of.columns} would make the script verbose, and take longer to type without gaining anything in return. Sometimes, short textual explanations in comments (ignored by \Rlang) are needed to achieve readability for humans.
  \item How to make the words visible in names: traditionally in \Rlang one would use dots to separate the words and use only lower case. Some years ago, it became possible to use underscores. The use of underscores is common nowadays because it is ``safer'', as in some situations a dot may have a special meaning. Names like \code{NumCols}, using ``camel case'', are only infrequently used in \Rlang programming but are frequently used in other languages like \pascallang.
\end{itemize}

The \emph{Tidyverse style guide} for writing \Rlang code (\url{https://style.tidyverse.org/}) provides more detailed ``rules''. However, more important than strictly following a published guideline is to be consistent in the style one, a team of programmers or data analysts, or even members of an organisation use. In the current book, I have not followed this guide in all respects, instead following in some cases the style used in \Rlang documentation. However, I have attempted to be consistent.

\begin{playground}
Here is an example of bad style in a script. Edit the code in the chunk below so that it becomes easier to read.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2} \hlcom{# height}
\hlstd{b} \hlkwb{<-} \hlnum{4} \hlcom{# length}
\hlstd{C} \hlkwb{<-}
    \hlstd{a} \hlopt{*}
\hlstd{b}
\hlstd{C} \hlkwb{->} \hlstd{variable}
      \hlkwd{print}\hlstd{(}
\hlstr{"area: "}\hlstd{, variable}
\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

The points discussed above already help a lot. However, one can go further in achieving the goal of human readability by interspersing explanations and code ``chunks'' and using all the facilities of typesetting, even of formatted maths formulas and equations, within the listing of the script. Furthermore, by including the results of the calculations and the code itself in a typeset report built automatically one ensures that they match each other. This greatly contributes to data analysis reproducibility, which is becoming a widespread requirement both in academia and in industry.

This approach is called literate programming\index{literate programming} and was first proposed by \citeauthor{Knuth1984a} (\citeyear{Knuth1984a}) through his \pgrmname{WEB} system. In the case of \Rpgrm programming, the first support of literate programming was in \pkgname{Sweave}, which has been superseded by \pkgname{knitr} \autocite{Xie2013}. This package supports the use of \Markdown or \Latex\ \autocite{Lamport1994} as the markup language for the textual contents and also formats and applies syntax highlighting to code. \Rmarkdown is an extension to \Markdown that makes it easier to include \Rlang code in documents (see \url{http://rmarkdown.rstudio.com/}). It is the basis of \Rlang packages that support typesetting large and complex documents (\pkgname{bookdown}), web sites (\pkgname{blogdown}), package vignettes (\pkgname{pkgdown}), and slides for presentations \autocite{Xie2016,Xie2018}. \Quarto, which provides an enhanced version of \Rmarkdown, is implemented in \Rlang package \pkgname{quarto} together with the \Quarto program as a separate executable. The use of \pkgname{knitr} and \pkgname{quarto} is very well integrated into the \RStudio IDE.
The generation of typeset reports is outside the scope of the book, but it is an important skill to learn. It is well described in the books and web sites cited.

\subsection{Debugging scripts}\label{sec:script:debug}
\index{scripts!debugging}

The use of the word \emph{bug} to describe a problem in computer hardware and software started in 1946 when a real bug, more precisely a moth, got between the contacts of a relay in an electromechanical computer causing it to malfunction and Grace Hooper described the first computer \emph{bug}. The use of the term bug in engineering predates the use in computer science, and consequently, the use of the word bug in computing caught on easily.

A suitable quotation from a letter written by Thomas Alva Edison in 1878 \autocite[as given by][]{Hughes2004}:
\begin{quotation}
  It has been just so in all of my inventions. The first step is an intuition, and comes with a burst, then difficulties arise--this thing gives out and [it is] then that ``Bugs''---as such little faults and difficulties are called---show themselves and months of intense watching, study and labour are requisite before commercial success or failure is certainly reached.
\end{quotation}

The quoted paragraph above makes clear that only very exceptionally does any new design fully succeed. The same applies to \Rlang scripts as well as any other non-trivial piece of computer code. From this it logically follows that testing and de-bugging are fundamental steps in the development of \Rlang scripts and packages. Debugging, as an activity, is outside the scope of this book. However, clear programming style and good documentation are indispensable for efficient testing and reuse.

Even for scripts used for analysing a single data set, we need to be confident that the algorithms and their implementation are valid, and able to return correct results. This is true both for scientific reports, expert reports, and any data analysis related to assessment of compliance with legislation or regulations. Of course, even in cases when we are not required to demonstrate validity, say for decision making purely internal to a private organisation, we will still want to avoid costly mistakes.

The first step in producing reliable computer code is to accept that any code that we write needs to be tested and, if possible, validated. Another important step is to make sure that input is validated within the script and a suitable error produced for bad input (including valid input values falling outside the range that can be reliably handled by the script).

If during testing, or during normal use, a wrong value or no value is returned by a calculation (e.g.,  the script crashes or triggers a fatal error), debugging consists in finding the cause of the problem. The cause can be either a mistake in the implementation of an algorithm or in the algorithm itself. However, many apparent \emph{bugs} are caused by bad, or missing, code for handling of special cases, such as invalid input values, rounding errors, and division by zero, making a function or script crash instead of elegantly issuing a helpful message.

Diagnosing the source of bugs is, in most cases, like detective work. One uses hunches based on common sense and experience to try to locate the lines of code causing the problem. One follows different \emph{leads} until the case is solved. In most cases, at the very bottom, we rely on some sort of divide-and-conquer strategy. For example, we may check the value returned by intermediate calculations until we locate the earliest code statement producing a wrong value. Another common case is when some input values trigger a bug. In such cases, it is frequently best to start by testing if different ``cases'' of input lead to errors/crashes or not. Boundary input values are usually the telltale ones: for numbers, zero, negative and positive values, very large values, very small values, missing values (\code{NA}), vectors of length zero (\code{numeric()}), etc.

\begin{warningbox}
  \textbf{Error messages} When debugging, keep in mind that in some cases a single bug can lead to a whole cascade of error messages. Do also keep in mind that typing mistakes, originating when code is entered through the keyboard, can wreak havock in a script: usually there is little correspondence between the number of error messages and the seriousness of the bug triggering them. When several errors are triggered, start by reading the error message printed first, as later errors can be an indirect consequence of earlier ones.
\end{warningbox}

There are special tools, called debuggers, available, and they help enormously. Debuggers allow one to step through the code, executing one statement at a time, allowing inspection of the objects present in the \Rlang environment. It is even possible to execute additional statements at the \Rpgrm console, e.g., to modify the value of a variable, while execution is paused. An \Rlang debugger is available within \RStudio and also through the \Rlang console.

When writing your first scripts, you will manage perfectly well, and learn more by running the script one line at a time, and when needed temporarily inserting \code{print()} statements to ``look'' at how the value of variables changes at each step. A debugger allows a lot more control, as one can ``step in'' and ``step out'' of function definitions, and set and unset break points where execution will stop. However, using a debugger is not as simple as using \code{print()}.

If you get stuck trying to find the cause of a bug, do extend your search both to the most trivial of possible causes, and later on to the least likely ones (such as a bug in a package installed from \CRAN or \Rlang itself). Of course, when suspecting a bug in code you have not written, it is wise to very carefully read the documentation, as the ``bug'' may be just a misunderstanding of what a certain piece of code is expected to do.  Also keep in mind that as discussed on page \pageref{sec:intro:net:help}, you will be able to find online already-answered questions to many of your likely problems and doubts. For example, searching with Google for the text of an error message is usually well rewarded. Most important to remember is that bugs do pop up frequently in newly written code, and occasionally in old code. No coding is immune to them, thus, the code you write, packages you use or \Rlang itself can contain bugs.

\section{Compound Statements}\label{sec:script:compound:statement}
\index{compound code statements}\index{simple code statements}

Individual statements can be grouped into \emph{compound statements} by enclosing them in curly braces (Figure \ref{fig:compound:statement}). Conceptually, is like putting these statements into a box that allows us to operate with them as an anonymous whole.

\begin{figure}
\centering
\begin{small}
\begin{tikzpicture}[node distance=1.7cm]
\node (start) [startstop] {\ldots};
\node (enc) [enclosure, color = blue, fill = blue!5, below of=start, yshift=-0.75cm] {\ };
\node (stat2) [process, color = blue, fill = blue!15, below of=start] {\code{<statement A>}};
\node (stat3) [process, color = blue, fill = blue!15, below of=stat2, yshift=+0.2cm] {\code{<statement B>}};
\node (stop) [startstop, below of=stat3] {\ldots};
\draw [arrow, color = blue] (start) -- (stat2);
\draw [arrow, color = blue] (stat2) -- (stat3);
\draw [arrow, color = blue] (stat3) -- (stop);
\draw [arrow, color = black] (start) -- (enc);
\draw [arrow, color = black] (enc) -- (stop);
\end{tikzpicture}
\end{small}
  \caption[Compound code statement]{Diagram of a compound code statement is a grouping of statements that in some contexts behaves as a single statement. In the diagram, statements A and B have been grouped into a compound statement.}\label{fig:compound:statement}
\end{figure}


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"..."}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "..."
\end{verbatim}
\begin{alltt}
\hlstd{\{}
  \hlkwd{print}\hlstd{(}\hlstr{"A"}\hlstd{)}
  \hlkwd{print}\hlstd{(}\hlstr{"B"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] "B"
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"..."}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "..."
\end{verbatim}
\end{kframe}
\end{knitrout}

The grouping of the two middle statements above is of no consequence, as it does not alter sequential evaluation. In the example above, only side effects are of interest. In the example below, the value returned by a compound statement is that returned by the last statement evaluated within it. Individual statements can be separated by an end-of-line as above, or by a semicolon (;) as below: two statements, each of them implementing an arithmetic operation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{\{}\hlnum{1} \hlopt{+} \hlnum{2}\hlstd{;} \hlnum{3} \hlopt{+} \hlnum{4}\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 7
\end{verbatim}
\end{kframe}
\end{knitrout}

The example above demonstrates that only the value returned by the compound statement as a whole is displayed automatically at the \Rlang console, i.e., the implicit call to \code{print()} is applied to the compound statement. Thus, even though both statements were evaluated, we only see the result returned by the second one.

\begin{playground}
Nesting is also possible. Before running the compound statement below try to predict the value it will return, and then run the code and compare your prediction to the value returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{\{}\hlnum{1} \hlopt{+} \hlnum{2}\hlstd{; \{a} \hlkwb{<-} \hlnum{3} \hlopt{+} \hlnum{4}\hlstd{; a} \hlopt{+} \hlnum{1}\hlstd{\}\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

Grouping is of little use by itself. It becomes useful together with control-of-execution constructs, when defining functions, and in similar cases where we need to treat a group of code statements as if they were a single statement. We will see several examples of the use of compound statements in the current chapter and in chapter \ref{chap:R:functions} on page \pageref{chap:R:functions}.

\section{Function Calls}
\index{functions!call}
We will describe functions in detail and how to create new ones in chapter \ref{chap:R:functions}. We have already been using functions since chapter \ref{chap:R:as:calc}. Functions are structurally \Rlang statements, in most cases, compound statements, using formal parameters as placeholders. When one calls a function, one passes arguments for the different parameters (or placeholder names) and the (compound) statement conforming the \emph{body} of the function is evaluated after ``replacing'' the placeholders by the values passed as arguments.

In the first example, we use two statements. In the first statement, $log(100)$ is computed by calling function \code{log10()} with \code{100} as argument and the returned value is assigned to variable \code{a}. In the second statement, the value 2 is displayed as a side effect of calling \code{print()} with variable \code{a} as argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{log10}\hlstd{(}\hlnum{100}\hlstd{)}
\hlkwd{print}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}

The two statements in example above can be rewritten as a single statement using a nested function call.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlkwd{log10}\hlstd{(}\hlnum{100}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}

The difference is that we avoid the explicit creation of a variable. Whether this is an advantage or not depends on whether we use variable \code{a} in later statements or not.

Statements with more levels of nesting than shown above become very difficult to read, so alternative notations can help.

\section{Data Pipes}\label{sec:script:pipes}
\index{pipes!base R|(}
\index{pipe operator}
\index{chaining statements with \emph{pipes}}
Pipes have been at the core of shell scripting in \osname{Unix} since early stages of its design \autocite{Kernigham1981} as well as in \osname{Linux} distributions. Within an OS, pipes are chains of small programs or ``tools'' that carry out a single well-defined task (e.g., \code{ed}, \code{sub}, \code{gsub}, \code{grep}, and \code{more}). Data such as text is described as flowing from a source into a sink through a series of steps at which a specific transformations take place. In \osname{Unix} and  \osname{Linux} shells like \pgrmname{sh} or \pgrmname{bash}, sinks and sources are files, but in \osname{Unix} and \osname{Linux} files are an abstraction that includes all devices and connections for input or output, including physical ones such as terminals and printers.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
stdin | grep("abc") | more
\end{alltt}
\end{kframe}
\end{knitrout}

How can \emph{pipes} exist within a single \Rlang script? When chaining functions into a pipe, data is passed between them through temporary \Rlang objects stored in memory, which are created and destroyed automatically. Conceptually, there is little difference between \osname{Unix} shell pipes and pipes in \Rlang scripts, but the implementations are different.

What do pipes achieve in \Rlang scripts? They relieve us from the responsibility of creating and deleting the temporary objects. By chaining the statements they enforce their sequential execution. Pipes usually improve the readability of scripts by allowing more concise code.

Since 2021, starting from version 4.1.0, \Rlang has had a native pipe operator (\Roperator{\textbar >}) as part of the language. Subsequently, the placeholder (\code{\_}) was implemented in version 4.2.0 and its functionality expanded in version 4.3.0. Another two implementations of pipes, that have been available as \Rlang extensions for some years in packages \pkgnameNI{magrittr} and \pkgnameNI{wrapr}, are described in chapter \ref{chap:R:data} on page \pageref{chap:R:data}.

I describe R's pipe syntax based on \Rpgrm 4.3.0. I start by showing the same operations coded using nested function calls, using explicit saving of intermediate values in temporary objects, and using the pipe operator.

Nested function calls are concise, but difficult to read when the depth of nesting increases.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sum}\hlstd{(}\hlkwd{sqrt}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\end{kframe}
\end{knitrout}

Saving intermediate results explicitly results in clear but verbose code.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{data.tmp} \hlkwb{<-} \hlkwd{sqrt}\hlstd{(data.in)}
\hlkwd{sum}\hlstd{(data.tmp)}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(data.tmp)} \hlcom{# clean up!}
\end{alltt}
\end{kframe}
\end{knitrout}

A pipe using operator \Roperator{\textbar >} makes the data flow clear and keeps the code concise.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{sum}\hlstd{()}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\end{kframe}
\end{knitrout}

We can assign the result of the computation to a variable, most elegantly using the \Roperator{->} operator on the \emph{rhs} of the pipe.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{sum}\hlstd{()} \hlkwb{->} \hlstd{my_rhs.var}
\hlstd{my_rhs.var}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\end{kframe}
\end{knitrout}

We can also use the \Roperator{<-} operator on the \emph{lhs} of the pipe, i.e., for assignments a pipe behaves as a compound statement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_lhs.var} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{sum}\hlstd{()}
\hlstd{my_lhs.var}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\end{kframe}
\end{knitrout}

Formally, the \Roperator{\textbar >} operator from base \Rlang takes two operands, just like operator \code{+} does. The value returned by the \emph{lhs} (left-hand side) operand, which can be any \Rlang expression, is passed as argument to the function-call operand on \emph{rhs} (right-hand side). The called function must accept at least one argument. This default syntax that implicitly passes the argument by position to the first parameter of the function would limit which functions could be used in a pipe construct. However, it is also possible to pass the piped argument explicitly by name to any parameter of the function on the \emph{rhs} using an underscore (\code{\_}) as a placeholder.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{(}\hlkwc{x} \hlstd{= _) |>} \hlkwd{sum}\hlstd{(}\hlkwc{x} \hlstd{= _)}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\end{kframe}
\end{knitrout}

The placeholder can be also used with extraction operators.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{(}\hlkwc{x} \hlstd{= _) |> _[}\hlnum{2}\hlopt{:}\hlnum{8}\hlstd{] |>} \hlkwd{sum}\hlstd{(}\hlkwc{x} \hlstd{= _)}
\end{alltt}
\begin{verbatim}
## [1] 15.306
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Base \Rlang functions like \Rfunction{subset()} have formal parameters in an order that is suitable for implicitly passing the piped value as an argument to their first parameter, while others like \Rfunction{assign()} do not. For example, when calling function \code{assign()} to save a value using a name available as a character string, we would like to pass the piped value as an argument to parameter \code{value} which is not the first. In such cases, we can use \code{\_} as a placeholder and pass it by name.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{obj.name} \hlkwb{<-} \hlstr{"data.out"}
\hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{sum}\hlstd{() |>} \hlkwd{assign}\hlstd{(}\hlkwc{x} \hlstd{= obj.name,} \hlkwc{value} \hlstd{= _)}
\end{alltt}
\end{kframe}
\end{knitrout}

Alternatively, we can define a wrapper function, with the desired order for the formal parameters. This approach can be worthwhile when the same function is called repeatedly within a script.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{value_assign} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{value}\hlstd{,} \hlkwc{x}\hlstd{,} \hlkwc{...}\hlstd{) \{}
  \hlkwd{assign}\hlstd{(}\hlkwc{x} \hlstd{= x,} \hlkwc{value} \hlstd{= value, ...)}
\hlstd{\}}
\hlstd{obj.name} \hlkwb{<-} \hlstr{"data.out"}
\hlnum{1}\hlopt{:}\hlnum{10} \hlstd{|>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{sum}\hlstd{() |>} \hlkwd{value_assign}\hlstd{(obj.name)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{explainbox}

In general, whenever we use temporary variables to store values that are passed as arguments only once, we can nest or chain the statements making the saving of intermediate results into a temporary variable implicit instead of explicit. Examples of some useful idioms follow.

Addition of computed variables to a data frame using \Rfunction{within()} (see section \ref{sec:calc:df:with} on page \pageref{sec:calc:df:with}) and selecting rows with \Rfunction{subset()} (see section \ref{sec:calc:df:subset} on page \pageref{sec:calc:df:subset}) are combined in our first simple example. For clarity, we use the \code{\_} placeholder to indicate the value returned by the preceding function in the pipe.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{)) |>}
  \hlkwd{within}\hlstd{(}\hlkwc{data} \hlstd{= _,}
         \hlstd{\{}
           \hlstd{x4} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4}
           \hlstd{is.large} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4} \hlopt{>} \hlnum{1000}
         \hlstd{\}) |>}
  \hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= _, is.large)}
\end{alltt}
\begin{verbatim}
##     x          y is.large    x4
## 6   6 -0.3973206     TRUE  1296
## 7   7 -0.1701238     TRUE  2401
## 8   8 -0.3953664     TRUE  4096
## 9   9  1.6617913     TRUE  6561
## 10 10  0.8047265     TRUE 10000
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Without using the \code{\_} placeholder, but using a more compact layout, the code above becomes that shown below. Compare it to that above to work out how I simplified the code.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{)) |>}
  \hlkwd{within}\hlstd{(\{x4} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4}\hlstd{; is.large} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4} \hlopt{>} \hlnum{1000}\hlstd{\}) |>}
  \hlkwd{subset}\hlstd{(is.large)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

Subset can be also used to select variables or columns from data frames and matrices.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{)) |>}
  \hlkwd{within}\hlstd{(}\hlkwc{data} \hlstd{= _,}
         \hlstd{\{}
           \hlstd{x4} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4}
           \hlstd{is.large} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4} \hlopt{>} \hlnum{1000}
         \hlstd{\}) |>}
  \hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= _, is.large,} \hlkwc{select} \hlstd{=} \hlopt{-}\hlstd{x)}
\end{alltt}
\begin{verbatim}
##             y is.large    x4
## 6   1.7328219     TRUE  1296
## 7   0.7202390     TRUE  2401
## 8   0.3188249     TRUE  4096
## 9  -0.9799537     TRUE  6561
## 10 -2.0550479     TRUE 10000
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{)) |>}
  \hlkwd{within}\hlstd{(}\hlkwc{data} \hlstd{= _,}
         \hlstd{\{}
           \hlstd{x4} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4}
           \hlstd{is.large} \hlkwb{<-} \hlstd{x}\hlopt{^}\hlnum{4} \hlopt{>} \hlnum{1000}
         \hlstd{\}) |>}
  \hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= _,} \hlkwc{select} \hlstd{=} \hlkwd{c}\hlstd{(y, x4))}
\end{alltt}
\begin{verbatim}
##             y    x4
## 1   0.5243559     1
## 2  -0.6870516    16
## 3  -1.9044115    81
## 4   0.5491692   256
## 5   0.5169959   625
## 6   1.4797383  1296
## 7   0.2849528  2401
## 8  -0.9854300  4096
## 9  -1.1774729  6561
## 10 -0.4103818 10000
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"T1"}\hlstd{,} \hlstr{"T2"}\hlstd{,} \hlstr{"Ctl"}\hlstd{),} \hlkwc{each} \hlstd{=} \hlnum{4}\hlstd{)),}
           \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{12}\hlstd{)) |>}
  \hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= _, group} \hlopt{%in%} \hlkwd{c}\hlstd{(}\hlstr{"T1"}\hlstd{,} \hlstr{"T2"}\hlstd{)) |>}
  \hlkwd{aggregate}\hlstd{(}\hlkwc{data} \hlstd{= _, y} \hlopt{~} \hlstd{group, mean)}
\end{alltt}
\begin{verbatim}
##   group          y
## 1    T1  0.7220769
## 2    T2 -0.4949876
\end{verbatim}
\end{kframe}
\end{knitrout}

The extraction operators are accepted on the \emph{rhs} of a pipe only starting from \Rpgrm 4.3.0. With these versions \code{\_[["y"]]}, as shown below, as well as its equivalent \code{\_\$y} can be used. Function \Rfunction{getElement()} used as \code{getElement("y")}, being a normal function, can be used in situations where operators are not accepted, like on the \emph{rhs} of \Roperator{|>} in older versions of \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"T1"}\hlstd{,} \hlstr{"T2"}\hlstd{,} \hlstr{"Ctl"}\hlstd{),} \hlkwc{each} \hlstd{=} \hlnum{4}\hlstd{)),}
           \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{12}\hlstd{)) |>}
  \hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= _, group} \hlopt{%in%} \hlkwd{c}\hlstd{(}\hlstr{"T1"}\hlstd{,} \hlstr{"T2"}\hlstd{)) |>}
  \hlkwd{aggregate}\hlstd{(}\hlkwc{data} \hlstd{= _, y} \hlopt{~} \hlstd{group, mean) |>}
  \hlstd{_[[}\hlstr{"y"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] -0.1143072 -0.7662241
\end{verbatim}
\end{kframe}
\end{knitrout}

Additional functions designed to be used in pipes are available through packages as described in chapter \ref{chap:R:data}.

\begin{playground}
  In the last three examples, in which function calls is the explicit use of the placeholder needed, and in which ones is it optional? Hint: edit the code, removing the parameter name, \code{=}, and \code{\_},  and test whether the edited code works and returns the same value as before.
\end{playground}
\index{pipes!base R|)}

\section{Conditional Evaluation}\label{sec:script:flow:control}
\index{control of execution flow}
By default, \Rlang statements in a script are evaluated (or executed) in the sequence they appear in the script \textit{listing} or text. We give the name \emph{control of execution constructs} to those special statements that allow us to alter this default sequence, by either skipping or repeatedly evaluating individual statements. The statements whose evaluation is controlled can be either simple or compound. Some of the control of execution flow statements, function like \emph{ON-OFF switches} for program statements. Others allow statements to be executed repeatedly while or until a condition is met, or until all members of a list or a vector are processed.

These \emph{control of execution constructs} can be also used at the \Rlang console, but it is usually awkward to do so as they can extend over several lines of text. In simple scripts, the \emph{flow of execution} can be fixed and linear from the first to the last statement in the script. However, \emph{control of execution constructs} are a crucial part of most useful scripts. As we will see next, a compound statement can include multiple simple or nested compound statements. \Rpgrm has two types of \emph{if}\index{conditional statements} statements, non-vectorised and vectorised.

\subsection[Non-vectorised \texttt{if}, \texttt{else} and \texttt{switch}]{Non-vectorised \code{if}, \code{else} and \code{switch}}\label{sec:script:if}
\qRcontrol{if}\qRcontrol{if\ldots{}else}%

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop] {\ldots};
\node (dec1) [decision, color = blue, fill = blue!15, below of=start, yshift=-0.3cm] {\code{if (<cond.>)}};
\node (stat2) [process, color = blue, fill = blue!15, right of=dec1, xshift=3.2cm] {\code{<statement A>}};
\node (stat3) [process, below of=dec1, yshift=-0.5cm] {\code{<statement B>}};
\node (stop) [startstop, below of=stat3] {\ldots};
\draw [arrow] (start) -- (dec1);
\draw [arrow, color=blue] (dec1) -- node[anchor=north] {\code{TRUE}} (stat2);
\draw [arrow, color=blue] (dec1) -- node[anchor=west] {\code{FALSE}} (stat3);
\draw [arrow] (stat2) |- (stat3);
\draw [arrow] (stat3) -- (stop);
\end{tikzpicture}
\end{small}
  \caption[Flowchart for \code{if} construct.]{Flowchart for \code{if} construct.}\label{fig:if:diagram}
\end{figure}

The \code{if} construct ``decides'', depending on a \code{logical} value, whether the next code statement is executed (if \code{TRUE}) or skipped (if \code{FALSE}) (Figure \ref{fig:if:diagram}). The flow chart shows how \code{if} works: \code{<statement A>} is either evaluated or skipped depending on the value of \code{<condition>}, while \code{<statement B>} is always evaluated.\label{flowchart:if}

The usefulness of \emph{if} statements stems from the possibility of computing the \code{logical} value used as \code{<condition>} with comparison operators (see section \ref{sec:calc:comparison} on page \pageref{sec:calc:comparison}) and logical operators (see section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean}).

We start with toy examples demonstrating how \emph{if} statements work. Later we will see examples closer to real use cases. Here \Rcontrol{if} controls the evaluation or not of the simple statement \code{print("Hello!")}.

\begin{explainbox}
We use the name \emph{flag} for a \code{logical} variable set manually, preferably near the top of the script. Real flags were used in railways to indicate to trains whether to stop or continue at stations and which route to follow at junctions. Use of \code{logical} flags in scripts is most useful when switching between two behaviours that depend on multiple separate statements.
\end{explainbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{flag} \hlkwb{<-} \hlnum{TRUE}
\hlkwa{if} \hlstd{(flag)} \hlkwd{print}\hlstd{(}\hlstr{"Hello!"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "Hello!"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Play with the code above by changing the value assigned to variable \code{flag}, \code{FALSE}, \code{NA}, and \code{logical(0)}.

In the example above we use variable \code{flag} as the \emph{condition}.

Nothing in the \Rlang language prevents this condition from being a \code{logical} constant. Explain why \code{if (FALSE)} in the syntactically correct statement below is of no practical use.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwa{if} \hlstd{(}\hlnum{FALSE}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"Hello!"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

Conditional execution is much more useful than what could be expected from the previous examples, because the statement whose execution is being controlled can be a compound statement of almost any length or complexity. A very simple example follows, with a compound statement containing two statements, each one, a call to function \code{print()} with a different argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{printing} \hlkwb{<-} \hlnum{TRUE}
\hlkwa{if} \hlstd{(printing) \{}
  \hlkwd{print}\hlstd{(}\hlstr{"A"}\hlstd{)}
  \hlkwd{print}\hlstd{(}\hlstr{"B"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "A"
## [1] "B"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
The condition passed as an argument to \code{if}, enclosed in parentheses, can be anything yielding a \Rclass{logical} vector of length one. As this condition is \emph{not} vectorised, a longer vector will trigger an \Rlang warning or error depending on \Rlang's version.
\end{warningbox}

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop] {\ldots};
\node (dec1) [decision, color = blue, fill = blue!15, below of=start, yshift=-0.5cm] {\code{if (<cond.>) else}};
\node (stat2) [process, color = blue, fill = blue!15, left of=dec1, xshift=-3.2cm] {\code{<statement A>}};
\node (stat3) [process, color = blue, fill = blue!15, right of=dec1, xshift=3.2cm] {\code{<statement B>}};
\node (stat4) [process, below of=dec1, yshift=-0.5cm] {\code{<statement C>}};
\node (stop) [startstop, below of=stat4] {\ldots};
\draw [arrow] (start) -- (dec1);
\draw [arrow, color=blue] (dec1) -- node[anchor=north] {\code{TRUE}} (stat2);
\draw [arrow, color=blue] (dec1) -- node[anchor=north] {\code{FALSE}} (stat3);
\draw [arrow] (stat2) |- (stat4);
\draw [arrow] (stat3) |- (stat4);
\draw [arrow] (stat4) -- (stop);
\end{tikzpicture}
\end{small}
  \caption[Flowchart for \code{if \ldots\ else} construct.]{Flowchart for \code{if \ldots else} construct.}\label{fig:if:else:diagram}
\end{figure}

The \code{if \ldots\ else \ldots} construct ``decides'', depending on a \code{logical} value, which of two code statements is executed (Figure \ref{fig:if:else:diagram}). The flow chart shows how it works: either \code{<statement A>} or \code{<statement B>} is evaluated and the other skipped depending on the value of \code{<condition>}, while \code{<statement C>} is always evaluated.\label{flowchart:if:else}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{10}
\hlkwa{if} \hlstd{(a} \hlopt{<} \hlnum{0}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"'a' is negative"}\hlstd{)} \hlkwa{else} \hlkwd{print}\hlstd{(}\hlstr{"'a' is not negative"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "'a' is not negative"
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlstr{"This is always printed"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "This is always printed"
\end{verbatim}
\end{kframe}
\end{knitrout}

As can be seen above, the statement immediately following \code{if} is executed if the condition returns \code{TRUE} and that following \code{else} is executed if the condition returns \code{FALSE}. Statements after the conditionally executed \code{if} and \code{else} statements are always executed, independently of the value returned by the condition.

\begin{playground}
Play with the code in the chunk above by assigning different numeric vectors to \code{a}.
\end{playground}



\begin{explainbox}
Do you still remember the rules about continuation lines?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# 1}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlkwa{if} \hlstd{(a} \hlopt{<} \hlnum{0}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"'a' is negative"}\hlstd{)} \hlkwa{else} \hlkwd{print}\hlstd{(}\hlstr{"'a' is not negative"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "'a' is not negative"
\end{verbatim}
\end{kframe}
\end{knitrout}

Why does the statement below (not evaluated here) trigger an error while the one above does not?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# 2 (not evaluated here)}
\hlkwd{if} (a < 0) \hlkwd{print}(\hlstr{"\hlstr{'a'} is negative"})
else \hlkwd{print}(\hlstr{"\hlstr{'a'} is not negative"})
\end{alltt}
\end{kframe}
\end{knitrout}

How do the continuation line rules apply when we add curly braces as shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# 1}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlkwa{if} \hlstd{(a} \hlopt{<} \hlnum{0}\hlstd{) \{}
    \hlkwd{print}\hlstd{(}\hlstr{"'a' is negative"}\hlstd{)}
  \hlstd{\}} \hlkwa{else} \hlstd{\{}
    \hlkwd{print}\hlstd{(}\hlstr{"'a' is not negative"}\hlstd{)}
  \hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "'a' is not negative"
\end{verbatim}
\end{kframe}
\end{knitrout}

In the example above, we enclosed a single statement between each pair of curly braces, but as these braces create compound statements, multiple statements could have been enclosed between each pair.
\end{explainbox}

\begin{playground}
Play with the use of conditional execution, with both simple and compound statements, and also think how to combine \code{if} and \code{else} to select among more than two options.
\end{playground}

In \Rlang, the value returned by any compound statement is the value returned by the last simple statement executed within the compound one. This means that we can assign the value returned by an \code{if} and \code{else} statement to a variable. This style is less frequently used, but occasionally can result in easier-to-understand scripts.\label{chunk:if:assignment}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlstd{my.message} \hlkwb{<-}
  \hlkwa{if} \hlstd{(a} \hlopt{<} \hlnum{0}\hlstd{)} \hlstr{"'a' is negative"} \hlkwa{else} \hlstr{"'a' is not negative"}
\hlkwd{print}\hlstd{(my.message)}
\end{alltt}
\begin{verbatim}
## [1] "'a' is not negative"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
If the condition statement returns a value of a class other than \code{logical}, \Rlang will attempt to convert it into a logical. This is sometimes used instead of a comparison to zero, as the conversion from \code{integer} yields \code{TRUE} for all integers except zero. The code below illustrates a rather frequently used idiom for checking if there is something available to display.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{message} \hlkwb{<-} \hlstr{"abc"}
\hlkwa{if} \hlstd{(}\hlkwd{length}\hlstd{(message))} \hlkwd{print}\hlstd{(message)}
\end{alltt}
\begin{verbatim}
## [1] "abc"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{advplayground}
\Kern{-1}{Study the conversion rules between \Rclass{numeric} and \Rclass{logical} values, run each of the statements below, and explain the output based on how type conversions are interpreted, remembering the difference between \emph{floating-point numbers} as implemented in computers and \emph{real numbers} as defined in mathematics (see page \pageref{box:integer:float}).}

% chunk contains intentional error-triggering examples
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwa{if} \hlstd{(}\hlnum{0}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlopt{-}\hlnum{1}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlnum{0.01}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlnum{1e-300}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlnum{1e-323}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlnum{1e-324}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlnum{1e-500}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlkwd{as.logical}\hlstd{(}\hlstr{"true"}\hlstd{))} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlkwd{as.logical}\hlstd{(}\hlkwd{as.numeric}\hlstd{(}\hlstr{"1"}\hlstd{)))} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlkwd{as.logical}\hlstd{(}\hlstr{"1"}\hlstd{))} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\hlkwa{if} \hlstd{(}\hlstr{"1"}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"hello"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Hint: if you need to refresh your understanding of the type conversion rules, see section \ref{sec:calc:type:conversion} on page \pageref{sec:calc:type:conversion}.
\end{advplayground}

\begin{figure}
  \centering
\begin{small}\label{flowchart:switch}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop] {\ldots};
\node (dec1) [decision, color = blue, fill = blue!15, below of=start, yshift=-0.4cm] {\code{switch(<value>)}};
\node (stat2) [process, color = blue, fill = blue!15, below of=dec1, xshift=3.4cm] {\code{<statement A>}};
\node (stat3) [process, color = blue, fill = blue!15, below of=stat2] {\code{<statement B>}};
\node (stat4) [process, color = blue, fill = blue!15, below of=stat3] {\code{<statement C>}};
\node (stat5) [process, color = blue, fill = blue!15, below of=stat4] {\code{<statement D>}};
\node (stat6) [process, below of=stat5, xshift=3.3cm] {\code{<statement E>}};
\node (stop) [startstop, below of=stat6] {\ldots};
\draw [arrow] (start) -- (dec1);
\draw [arrow, color=blue] (dec1) |- node[anchor=north west] {\code{<value 1>}} (stat2);
\draw [arrow, color=blue] (dec1) |- node[anchor=north west] {\code{<value 2>}} (stat3);
\draw [arrow, color=blue] (dec1) |- node[anchor=north west] {\code{<value 3>}} (stat4);
\draw [arrow, color=blue] (dec1) |- node[anchor=north west] {\code{<default>}} (stat5);
\draw [arrow] (stat2) -| (stat6);
\draw [arrow] (stat3) -| (stat6);
\draw [arrow] (stat4) -| (stat6);
\draw [arrow] (stat5) -| (stat6);
\draw [arrow] (stat6) -- (stop);
\end{tikzpicture}
\end{small}
  \caption{Flowchart for a \code{switch} construct with four cases.}\label{fig:switch:diagram}
\end{figure}

\Kern{-1}{In addition to \Rcontrol{if} and \Rcontrol{if\ldots{}else}, there is in \Rlang a \Rcontrol{switch()} statement (Figure \ref{fig:switch:diagram}). It can be used to select among several \emph{cases}, or alternative statements, based on an expression that returns a \code{numeric} or a \code{character} value of length one when evaluated.}

A \Rcontrol{switch()} statement returns a value, just like \code{if} does. The value passed as argument to \Rcontrol{switch()} functions as an index selecting one of the statements. The value returned by the \Rcontrol{switch()} statement is the value returned by the selected \textit{case} statement.

In the first example below, we use a \code{character} variable as the condition, named cases, and a final unlabelled case as default in case of no match. In real use, a computed value or user input would be used in place of \code{my.object}. As with the \code{logical} argument to \code{if}, the \code{character} string value passed as argument must be a vector of length one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.object} \hlkwb{<-} \hlstr{"two"}
\hlstd{b} \hlkwb{<-} \hlkwd{switch}\hlstd{(my.object,}
            \hlkwc{one} \hlstd{=} \hlnum{1}\hlstd{,}
            \hlkwc{two} \hlstd{=} \hlnum{1} \hlopt{/} \hlnum{2}\hlstd{,}
            \hlkwc{four} \hlstd{=} \hlnum{1} \hlopt{/} \hlnum{4}\hlstd{,}
            \hlnum{0}
\hlstd{)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

Multiple condition values can share the same statement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.object} \hlkwb{<-} \hlstr{"two"}
\hlstd{b} \hlkwb{<-} \hlkwd{switch}\hlstd{(my.object,}
            \hlkwc{one} \hlstd{=,} \hlkwc{uno} \hlstd{=} \hlnum{1}\hlstd{,}
            \hlkwc{two} \hlstd{=,} \hlkwc{dos} \hlstd{=} \hlnum{1} \hlopt{/} \hlnum{2}\hlstd{,}
            \hlkwc{four} \hlstd{=,} \hlkwc{cuatro} \hlstd{=} \hlnum{1} \hlopt{/} \hlnum{4}\hlstd{,}
            \hlnum{0}
\hlstd{)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
    Do play with the use of the switch statement. Look at the documentation for \code{switch()} using \code{help(switch)} and study the examples at the end of the help page. Explore what happens if you set \code{my.object <- "ten"}, \code{my.object <- "three"}, \code{my.object <- NA\_character\_} or  \code{my.object <- character()}. Then remove the \code{, 0} as default value, and repeat.
\end{playground}

When the expression used as a condition returns a value that is not a \code{character}, it will be interpreted as an \code{integer} index. In this case, no names are used for the cases and the last case is always interpreted as the default.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.number} \hlkwb{<-} \hlnum{2}
\hlstd{b} \hlkwb{<-} \hlkwd{switch}\hlstd{(my.number,}
            \hlnum{1}\hlstd{,}
            \hlnum{1} \hlopt{/} \hlnum{2}\hlstd{,}
            \hlnum{1} \hlopt{/} \hlnum{4}\hlstd{,}
            \hlnum{0}
\hlstd{)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
    Continue playing with the use of the switch statement. Explore what happens if you set \code{my.number <- 10}, \code{my.number <- 3}, \code{my.number <- NA}, or  \code{my.object <- numeric()}. Afterwards, remove the \code{, 0} as default value, and repeat.
\end{playground}

\begin{explainbox}
The statements for the cases in a \Rcontrol{switch()} statement can be compound statements as in the case of \code{if}, and they can even be used for a side effect. The code example above can edited to print a message when the default value is returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.object} \hlkwb{<-} \hlstr{"ten"}
\hlstd{b} \hlkwb{<-} \hlkwd{switch}\hlstd{(my.object,}
            \hlkwc{one} \hlstd{=} \hlnum{1}\hlstd{,}
            \hlkwc{two} \hlstd{=} \hlnum{1} \hlopt{/} \hlnum{2}\hlstd{,}
            \hlkwc{three} \hlstd{=} \hlnum{1} \hlopt{/} \hlnum{4}\hlstd{,}
            \hlstd{\{}\hlkwd{print}\hlstd{(}\hlstr{"No match! Using default"}\hlstd{);} \hlnum{0}\hlstd{\}}
\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "No match! Using default"
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{explainbox}
  The \Rcontrol{switch()} statement can substitute for chained \code{if \ldots\ else} statements when all the conditions can be described by constant values or distinct values returned by the same test. The advantage is more concise and readable code. The equivalent of the first \Rcontrol{switch()} example above when written using \code{if \ldots\ else} becomes longer. Given how terse code using \Rcontrol{switch()} is, those not yet familiar with its use may find the more verbose style used below easier to understand. On the other hand, with numerous cases, a \Rcontrol{switch()} statement is easier to read and understand.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.object} \hlkwb{<-} \hlstr{"two"}
\hlkwa{if} \hlstd{(my.object} \hlopt{==} \hlstr{"one"}\hlstd{) \{}
  \hlstd{b} \hlkwb{<-} \hlnum{1}
\hlstd{\}} \hlkwa{else if} \hlstd{(my.object} \hlopt{==} \hlstr{"two"}\hlstd{) \{}
  \hlstd{b} \hlkwb{<-} \hlnum{1} \hlopt{/} \hlnum{2}
\hlstd{\}} \hlkwa{else if} \hlstd{(my.object} \hlopt{==} \hlstr{"four"}\hlstd{) \{}
  \hlstd{b} \hlkwb{<-} \hlnum{1} \hlopt{/} \hlnum{4}
\hlstd{\}} \hlkwa{else} \hlstd{\{}
  \hlstd{b} \hlkwb{<-} \hlnum{0}
\hlstd{\}}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{advplayground}
  Consider another alternative approach, the use of a named vector to map values. In most of the examples above, the code for the cases is a constant value or an operation among constant values. Implement one of these examples using a named vector instead of a \Rcontrol{switch()} statement.
\end{advplayground}

\subsection[Vectorised \texttt{ifelse()}]{Vectorised \code{ifelse()}}
\index{vectorised ifelse}
Vectorised \emph{ifelse} is a peculiarity of the \Rlang language, but very useful for writing concise code that may execute faster than logically equivalent but not vectorised code.
Vectorised conditional execution is coded by means of \emph{function} \Rcontrol{ifelse()} (written as a single word). This function takes three arguments: a \code{logical} vector usually the result of a test (parameter \code{test}), an expression to use for \code{TRUE} cases (parameter \code{yes}), and an expression to use for \code{FALSE} cases (parameter \code{no}). At each index position along the vectors, the value included in the returned vector is taken from \code{yes} if the corresponding member of the \code{test} logical vector is \code{TRUE} and from \code{no} if the corresponding member of \code{test} is \code{FALSE}. All three arguments can be any \Rlang statement returning the required vectors.

The flow chart for \Rcontrol{ifelse()} is similar to that for \code{if \ldots\ else} shown on page \pageref{flowchart:if} but applied in parallel to the individual members of vectors; e.g.,\ the condition expression is evaluated at index position \code{1} controls which value will be present in the returned vector at index position \code{1}, and so on.

It is customary to pass arguments to \code{ifelse} by position. We give a first example with named arguments to clarify the use of the function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.test} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{TRUE}\hlstd{)}
\hlkwd{ifelse}\hlstd{(}\hlkwc{test} \hlstd{= my.test,} \hlkwc{yes} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{no} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  1 -1  1  1
\end{verbatim}
\end{kframe}
\end{knitrout}

In practice, the most common idiom is to have as an argument passed to \code{test}, the result of a comparison calculated on the fly. As an example, the absolute values of the members of a vector are computed using \Rcontrol{ifelse()} instead of with \Rlang function \code{abs()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nums} \hlkwb{<-} \hlopt{-}\hlnum{3}\hlopt{:+}\hlnum{3}
\hlkwd{ifelse}\hlstd{(nums} \hlopt{<} \hlnum{0}\hlstd{,} \hlopt{-}\hlstd{nums, nums)}
\end{alltt}
\begin{verbatim}
## [1] 3 2 1 0 1 2 3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
In the case of \Rcontrol{ifelse()}, the length of the returned value is determined by the length of the logical vector passed as an argument to its first formal parameter (named \code{test})! A frequent mistake is to use a condition that returns a \code{logical} vector of length one, expecting that it will be recycled because arguments passed to the other formal parameters (named \code{yes} and \code{no}) are longer. However, no recycling will take place, resulting in a returned value of length one, with the remaining elements of the vectors passed to \code{yes} and \code{no} being discarded. Do try this by yourself, using logical vectors of different lengths. You can start with the examples below, making sure you understand why the returned values are what they are.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlopt{-}\hlnum{5}\hlopt{:-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlopt{-}\hlnum{5}\hlopt{:-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] -5
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{),} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlopt{-}\hlnum{5}\hlopt{:-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  1 -4
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{),} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlopt{-}\hlnum{5}\hlopt{:-}\hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] -5  2
\end{verbatim}
\begin{alltt}
\hlkwd{ifelse}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{),} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0 2
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

\begin{playground}
Some additional examples to play with, containing a few surprises. Study the examples below until you understand why returned values are what they are. In addition, create your own examples to test other possible cases. In other words, play with the code until you fully understand how \code{ifelse()} statements work.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlkwd{ifelse}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{,} \hlnum{1}\hlstd{,} \hlopt{-}\hlnum{1}\hlstd{)}
\hlkwd{ifelse}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{, a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)}
\hlkwd{ifelse}\hlstd{(}\hlkwd{any}\hlstd{(a} \hlopt{>} \hlnum{5}\hlstd{), a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# tricky}
\hlkwd{ifelse}\hlstd{(}\hlkwd{logical}\hlstd{(}\hlnum{0}\hlstd{), a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# even more tricky}
\hlkwd{ifelse}\hlstd{(}\hlnum{NA}\hlstd{, a} \hlopt{+} \hlnum{1}\hlstd{, a} \hlopt{-} \hlnum{1}\hlstd{)} \hlcom{# as expected}
\end{alltt}
\end{kframe}
\end{knitrout}
Hint: if you need to refresh your understanding of \code{logical} values and Boolean algebra see section \ref{sec:calc:boolean} on page \pageref{sec:calc:boolean}.
\end{playground}

\begin{advplayground}
Using \Rcontrol{ifelse()}, write a single statement to combine numbers from the two vectors \code{a} and \code{b} into a result vector \code{d}, based on whether the corresponding value in vector \code{c} is the character \code{"a"} or \code{"b"}. Then print vector \code{d} to make the result visible.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlopt{-}\hlnum{10}\hlopt{:-}\hlnum{1}
\hlstd{b} \hlkwb{<-} \hlopt{+}\hlnum{1}\hlopt{:}\hlnum{10}
\hlstd{c} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"b"}\hlstd{,} \hlnum{5}\hlstd{))}
\hlcom{# your code}
\end{alltt}
\end{kframe}
\end{knitrout}

If you do not understand how the three vectors are built, or you cannot guess the values they contain by reading the code, print them, and play with the arguments, until you understand what each parameter does. Also use \code{help(rep)} and/or \code{help(ifelse)} to access the documentation.
\end{advplayground}

\begin{advplayground}
Continuing from the playground above, test the behaviour of \Rcontrol{ifelse()} with \code{NA}, \code{NULL} and \code{logical()} passed as arguments to \code{test}. Also test the behaviour when only some members of a logical vector are not available (\code{NA}).
\end{advplayground}

\section{Iteration}
\index{loops|seealso{iteration}}
We give the name \emph{iteration} to the process of repetitive execution of a program statement---e.g., \emph{computed by iteration}. We use the same word, \emph{iteration}, to name each one of these repetitions of the execution of a statement---e.g., \emph{the second iteration}.

Iteration constructs make it possible to ``decide'' at run time the number of iterations, i.e., when execution breaks out of the loop and continues at the next statement in the script. Iteration can be used to apply the same computations to the different members of a vector or list (this section), but also to apply different functions to members of a vector, matrix, list, or data frame (section \ref{sec:R:faces:of:loops} on page \pageref{sec:R:faces:of:loops}).

In \Rlang, three types of iteration loops are available: \Rloop{for}, \Rloop{while} and \Rloop{repeat} constructs. They differ in the origin of the values they iterate over, and in the type of test used to terminate iteration. When the same algorithm can be implemented with more than one of these constructs, using the least flexible of them usually results in easier to understand code.

In \Rlang, explicit loops as described in this section can in some cases be replaced by calls to \emph{apply} functions (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}) or with vectorised functions and operators (see page \pageref{par:calc:vectorised:opers}). The choice among these approaches affects readability and performance (see section \ref{sec:loops:slow} on page \pageref{sec:loops:slow}).

\subsection[\texttt{for} loops]{\code{for} loops}

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop] {\ldots};
\node (entry) [below of=start, color = blue, yshift=0.5cm]{$\bullet$};
\node (dec1) [decision, color = blue, fill = blue!15, below of=entry, yshift=0.3cm] {\code{for (<list>)}};
\node (stat2) [process, color = blue, fill = blue!15, right of=dec1, xshift=3.55cm] {\code{<statement A>}};
\node (stat3) [process, below of=dec1, yshift=-0.5cm] {\code{<statement B>}};
\node (stop) [startstop, below of=stat3] {\ldots};
\draw [arrow] (start) -- (dec1);
\draw [arrow, color=blue] (dec1) -- node[anchor=north] {\textsl{continue}} (stat2);
\draw [arrow, color=blue] (dec1) -- node[anchor=west] {\textsl{break}} (stat3);
\draw [arrow, color = blue] (stat2) |- (entry);
\draw [arrow, color = blue] (entry) -- (dec1);
\draw [arrow] (stat3) -- (stop);
\end{tikzpicture}
\end{small}
  \caption{Flowchart for a \code{for} iteration loop.}\label{fig:for:loop:diagram}
\end{figure}

The\index{for loop}\index{iteration!for loop}\qRloop{for} most frequently used type of loop is a \code{for} loop. These loops work in \Rlang by ``walking through'' a list or vector of values to act upon (Figure \ref{fig:for:loop:diagram}). Within a \qRloop{for} loop, member values are available, sequentially, one at a time, through a variable that functions as a placeholder. The implicit test for the end of the vector or list takes place at the top of the construct before the loop statement is evaluated. The flow chart has the shape of a \emph{loop} as the execution can be directed to an earlier position in the sequence of statements, allowing the same section of code to be evaluated multiple times, each time with a new value assigned to the placeholder variable.

In the diagram above, the argument to \code{for()} is shown as \code{<list>} but it can also be a \code{vector} of any mode. Objects of most classes derived from \code{list} or from an atomic vector can also fulfil the same role. The extraction operation with a numeric index must be supported by objects of the class passed as argument.

Similarly to \code{if} constructs, only one statement is controlled by \Rloop{for}, however this statement can be a compound statement enclosed in braces \verb|{ }| (see pages \pageref{sec:script:compound:statement} and \pageref{sec:script:if}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{0} \hlcom{# variable needs to set to a valid numeric value!}
\hlkwa{for} \hlstd{(a} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{) b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\end{kframe}
\end{knitrout}

Here the statement \code{b <- b + a} is executed five times, with the placeholder variable \code{a} sequentially taking each of the values, 1, 2, 3, 4, and 5, the members of the anonymous vector \code{1:5}. The name used as a placeholder has to fulfil the same requirements as an ordinary \Rlang variable name. The list or vector following \code{in} can contain any valid \Rlang objects, as long as the code statements in the loop body can handle them.

\begin{warningbox}
In a \code{for} loop construct, even when it is a variable, the vector or list passed as argument cannot be modified by the code statement within the \code{for} loop.
\end{warningbox}

A\index{for loop!unrolled} loop can be ``unrolled'' into a linear sequence of statements. Let's work through the \code{for} loop above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{0}
\hlcom{# start of loop}
\hlcom{# first iteration}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlstd{b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlcom{# second iteration}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlstd{b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlcom{# third iteration}
\hlstd{a} \hlkwb{<-} \hlnum{3}
\hlstd{b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlcom{# fourth iteration}
\hlstd{a} \hlkwb{<-} \hlnum{4}
\hlstd{b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlcom{# fifth iteration}
\hlstd{a} \hlkwb{<-} \hlnum{5}
\hlstd{b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlcom{# end of loop}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\end{kframe}
\end{knitrout}

The operation implemented in this example is a very frequent one, the sum of a vector, so base \Rlang provides a function optimised for efficiently computing it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sum}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 15
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
It is important to note that a list or vector of length zero is a valid argument to \code{for}, that triggers no error, but skips the statements in the loop body.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{0}
\hlkwa{for} \hlstd{(a} \hlkwa{in} \hlkwd{numeric}\hlstd{()) b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a}
\hlkwd{print}\hlstd{(b)}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

By printing at each iteration variable \code{b}, the partial results at each iteration can be observed. Brackets are needed to form a compound statement from the two simple statements so that \code{print(b)} is also executed at each iteration.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{)}
\hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) \{}
  \hlstd{b} \hlkwb{<-} \hlstd{x}\hlopt{*}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
  \hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 8
## [1] 6
## [1] 12
## [1] 16
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
The iteration constructs \Rloop{for}, \Rloop{while}, and \code{repeat} always silently return \code{NULL}, which is a different behaviour than that of \code{if}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwa{for}\hlstd{(x} \hlkwa{in} \hlstd{a) x}\hlopt{*}\hlnum{2}
\hlstd{x}
\end{alltt}
\begin{verbatim}
## [1] 8
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

Thus as shown in earlier examples of \Rloop{for} loops, computed values need to be assigned to one or more variables within the loop so that they are not lost.
\end{warningbox}

While in the examples above the code directly walked through the values in the vector, an alternative approach is to walk through a sequence of indices using the extraction operator \Roperator{[ ]} to access the values in vectors or lists. This approach makes it possible to concurrently walk through more than one list or vector. In the example below, one member of vector \code{a} and of \code{b} are accessed in each iteration, \code{a} providing the input and \code{b} used to store the corresponding computed value.\label{chunk:for:example}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# an empty vector}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along.with} \hlstd{= a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
\hlstd{\}}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}\label{box:play:forloop}
Adding calls to \code{print()} makes visible the values taken by variables \code{i}, \code{a}, and \code{b} at each iteration. Try to understand where these values come from at each iteration, by playing with the code and modifying it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# an empty vector}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along.with} \hlstd{= a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(i)}
  \hlkwd{print}\hlstd{(a)}
  \hlkwd{print}\hlstd{(b)}
\hlstd{\}}
\hlstd{b}
\end{alltt}
\end{kframe}
\end{knitrout}

The same approach of adding calls to \code{print()} can be used for debugging any code that does not return the expected results.
\end{playground}

Above I used \code{seq(along.with = a)} to build a numeric vector containing a sequence of the same length as vector \code{a}. Using this \emph{idiom} ensures that a vector, in this example \code{a}, with length zero will be handled correctly, with \code{numeric(0)} assigned to \code{b}.

\begin{advplayground}
Run the examples below and explain why the two approaches are equivalent only when the length of \code{A} is one or more. Find the answer by assigning to \code{A}, vectors of different lengths, including zero (using \code{A <- numeric(0)}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlopt{-}\hlnum{5}\hlopt{:}\hlnum{5} \hlcom{# assign different numeric vector to A}
\hlstd{B} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(A))}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along.with} \hlstd{= A)) \{}
  \hlstd{B[i]} \hlkwb{<-} \hlstd{A[i]}\hlopt{^}\hlnum{2}
\hlstd{\}}
\hlstd{B}

\hlstd{C} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(A))}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{length}\hlstd{(A)) \{}
  \hlstd{C[i]} \hlkwb{<-} \hlstd{A[i]}\hlopt{^}\hlnum{2}
\hlstd{\}}
\hlstd{C}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{advplayground}

\begin{explainbox}
Using \code{seq(along.with = a)}, its equivalent \code{seq\_along(a)},\qRfunction{seq()}\qRfunction{seq\_along()} as above creates a sequence of integers in \code{i}, that indexes all members of \code{a} in the ``walk-through''. There is no requirement in the \Rlang for this, and including only some of the valid indexes, or including them in arbitrary order is possible if needed, however, this is rarely the case. On exit from the loop, the iterator \code{i} remains accessible and contains its value at the last iteration.
\end{explainbox}

Vectorisation usually results in the simplest and fastest code, as shown below (see section \ref{sec:loops:slow} on \pageref{sec:loops:slow}). However, not all \Rloop{for} loops can be replaced by vectorised statements.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
\Rloop{for} loops as described above, in the absence of errors, have statically predictable behaviour. The compound statement in the loop will be executed once for each member of the vector or list. Special cases may require the alteration of the normal flow of execution in the loop. Two cases are easy to deal with, one is stopping iteration early with a call to \Rloop{break()}, and another is jumping ahead to the next iteration with a call to \Rloop{next()}. The example below shows the use of these two functions: we ignore negative values contained in \code{a}, and exit or break out of the loop when the accumulated sum \code{b} exceeds 100.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{0}
\hlstd{a} \hlkwb{<-} \hlopt{-}\hlnum{10}\hlopt{:}\hlnum{100}
\hlstd{idxs} \hlkwb{<-} \hlkwd{seq_along}\hlstd{(a)}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlstd{idxs) \{}
  \hlkwa{if} \hlstd{(a[i]} \hlopt{<} \hlnum{0}\hlstd{)} \hlkwa{next}\hlstd{()}
  \hlstd{b} \hlkwb{<-} \hlstd{b} \hlopt{+} \hlstd{a[i]}
  \hlkwa{if} \hlstd{(b} \hlopt{>} \hlnum{100}\hlstd{)} \hlkwa{break}\hlstd{()}
\hlstd{\}}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 105
\end{verbatim}
\begin{alltt}
\hlstd{i}
\end{alltt}
\begin{verbatim}
## [1] 25
\end{verbatim}
\begin{alltt}
\hlstd{a[i]}
\end{alltt}
\begin{verbatim}
## [1] 14
\end{verbatim}
\end{kframe}
\end{knitrout}

Hint: if you find the code in the example above difficult to understand, insert \code{print()} statements and run it again inspecting how the values of \code{a}, \code{b}, \code{idxs} and \code{i} behave within the loop.

In \Rloop{for} loops, the use of \Rcontrol{break()} and \Rcontrol{next()} should be reserved for exceptional conditions. When the \Rloop{for} construct is not flexible enough for the computations being implemented, using a \Rloop{while} or a \Rloop{repeat} loop is preferable.

\end{explainbox}

\subsection[\texttt{while} loops]{\code{while} loops}

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop] {\ldots};
\node (entry) [below of=start, color = blue, yshift=0.5cm]{$\bullet$};
\node (dec1) [decision, color = blue, fill = blue!15, below of=entry, yshift=0.3cm] {\code{while (<cond.>)}};
\node (stat2) [process, color = blue, fill = blue!15, right of=dec1, xshift=3.3cm] {\code{<statement A>}};
\node (stat3) [process, below of=dec1, yshift=-0.5cm] {\code{<statement B>}};
\node (stop) [startstop, below of=stat3] {\ldots};
\draw [arrow] (start) -- (dec1);
\draw [arrow, color=blue] (dec1) -- node[anchor=north] {\code{TRUE}} (stat2);
\draw [arrow, color=blue] (dec1) -- node[anchor=west] {\code{FALSE}} (stat3);
\draw [arrow, color = blue] (stat2) |- (entry);
\draw [arrow, color = blue] (entry) -- (dec1);
\draw [arrow] (stat3) -- (stop);
\end{tikzpicture}
\end{small}
  \caption{Flowchart for a \code{while} iteration loop.}\label{fig:while:loop:diagram}
\end{figure}

\Rloop{while} loops\index{iteration!while loop} are more flexible than \code{for} loops (Figure \ref{fig:while:loop:diagram}). Instead of walking through a list or vector, iteration is controlled by a logical condition of length one, just like in \code{if}. Differently to in an \code{if} construct, the controlled statement is executed repeatedly as long as the condition remains \code{TRUE}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{while} \hlstd{(a} \hlopt{<} \hlnum{50}\hlstd{) \{}
  \hlkwd{print}\hlstd{(a)}
  \hlstd{a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
To ensure that a \code{while} loop is exited instead of circling for ever, the condition, \code{a < 50} in the example above, must depend on a value that is modified by the controlled statement, like \code{a} in this case.
\end{warningbox}

\begin{playground}
Make sure that you understand why the final value of \code{a} is larger than 50.
\end{playground}

\begin{explainbox}
The statements above can be simplified, by nesting the assignment inside a call to print.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwd{print}\hlstd{(a)}
\hlkwa{while} \hlstd{(a} \hlopt{<} \hlnum{50}\hlstd{)} \hlkwd{print}\hlstd{(a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

In \Rlang, statements like \code{c <- 1:5} return \emph{invisibly} (with no implicit call to \code{print()}) the value assigned. This makes possible \emph{chained} assignments to several variables within a single statement like in the example below, as well as using an assignment statement as an argument to a function or operator.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlstd{b} \hlkwb{<-} \hlstd{c} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{5}
\hlstd{a}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{advplayground}
Explain why a second \code{print(a)} has been added before \code{while()}. Hint: experiment if necessary.
\end{advplayground}

As with \code{for} loops, we can use an index variable in a \Rfunction{while} loop to walk through vectors and lists. The difference is that we have to update the index values explicitly in our own code. The code example based on a \code{for} loop given on page \pageref{chunk:for:example} can be rewritten as a \Rfunction{while} loop.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{6}\hlstd{,} \hlnum{8}\hlstd{)}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# an empty vector}
\hlstd{i} \hlkwb{<-} \hlnum{1}
\hlkwa{while}\hlstd{(i} \hlopt{<=} \hlkwd{length}\hlstd{(a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i]}\hlopt{^}\hlnum{2}
  \hlkwd{print}\hlstd{(b)}
  \hlstd{i} \hlkwb{<-} \hlstd{i} \hlopt{+} \hlnum{1}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 1
## [1]  1 16
## [1]  1 16  9
## [1]  1 16  9 36
## [1]  1 16  9 36 64
\end{verbatim}
\begin{alltt}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1]  1 16  9 36 64
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
\Rloop{while} loops as described above will terminate when the condition tested is \code{FALSE}. In cases that require stopping iteration based on an additional test condition within the compound statement, we can call \Rloop{break()} in the body of an \code{if} or \code{else} statement within the \code{while} statement. As in the case of \code{for} loops, it is good to use \Rloop{break()} only for exceptional conditions.
\end{explainbox}

\subsection[\texttt{repeat} loops]{\code{repeat} loops}

\begin{figure}
\centering
\begin{small}
\begin{tikzpicture}[node distance=1.5cm]
\node (start) [startstop] {\ldots};
\node (entry) [below of=start, color = blue, yshift=0.5cm]{$\bullet$};
\node (dec1) [process, color = blue, fill = blue!15, below of=start, yshift=-0.3cm] {\code{repeat}};
\node (stat2) [process, color = blue, fill = blue!15, right of=dec1, xshift=3.3cm] {\code{<statement A>}};
\node (stat3) [process, below of=stat2, yshift=-0.1cm] {\code{<statement B>}};
\node (stop) [startstop, below of=stat3] {\ldots};
\draw [arrow] (start) -- (dec1);
\draw [arrow, color=blue] (dec1) -- node[anchor=north] {} (stat2);
\draw [arrow, color=blue] (stat2) |- node[anchor=south east] {\textsl{continue}} (entry);
\draw [arrow, color=blue] (stat2) -- node[anchor=west] {\code{break()}} (stat3);
\draw [arrow, color = blue] (entry) -- (dec1);
\draw [arrow] (stat3) -- (stop);
\end{tikzpicture}
\end{small}
  \caption{Flowchart for a \code{repeat} iteration loop.}\label{fig:repeat:loop:diagram}
\end{figure}

The \Rloop{repeat}\index{iteration!repeat loop} construct is the most flexible as iteration only stops with a call to \Rcontrol{break()}. One or more calls to \Rcontrol{break()} can be located anywhere within the compound statement that forms the body of the loop (Figure \ref{fig:repeat:loop:diagram}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{2}
\hlkwa{repeat}\hlstd{\{}
  \hlkwd{print}\hlstd{(a)}
  \hlkwa{if} \hlstd{(a} \hlopt{>} \hlnum{50}\hlstd{)} \hlkwa{break}\hlstd{()}
  \hlstd{a} \hlkwb{<-} \hlstd{a}\hlopt{^}\hlnum{2}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] 2
## [1] 4
## [1] 16
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Try to explain why the example above returns the values it does. Use the approach of adding \code{print()} statements, as described on page \pageref{box:play:forloop}.
\end{playground}

When \code{repeat} loop constructs contain more than one call to \Rcontrol{break()}, each within a different \code{if} or \code{else} statement, indentation and/or comments can be used to highlight in the listing this infrequent use case .

\begin{advplayground}
  Explain why a \Rloop{repeat} construct is equivalent to a \Rloop{while} construct with the test condition set equal to \code{logical} constant \code{TRUE}.
\end{advplayground}

\subsection{Nesting of loops}\label{sec:nested:loops}
\index{iteration!nesting of loops}\index{nested iteration loops}\index{loops!nested}

All the execution-flow control statements seen above can be nested, as syntactically they are themselves statements. I show an example with two \code{for} loops used to walk through rows and columns of a \code{matrix} constructed as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{A} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{50}\hlstd{,} \hlkwc{nrow} \hlstd{=} \hlnum{10}\hlstd{)}
\hlstd{A}
\end{alltt}
\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5]
##  [1,]    1   11   21   31   41
##  [2,]    2   12   22   32   42
##  [3,]    3   13   23   33   43
##  [4,]    4   14   24   34   44
##  [5,]    5   15   25   35   45
##  [6,]    6   16   26   36   46
##  [7,]    7   17   27   37   47
##  [8,]    8   18   28   38   48
##  [9,]    9   19   29   39   49
## [10,]   10   20   30   40   50
\end{verbatim}
\end{kframe}
\end{knitrout}

The nested loops below compute the sum for each row of the matrix. In the example below, the value of \code{i} changes for each iteration of the outer loop. The value of \code{j} changes for each iteration of the inner loop, and the inner loop is run in full for each iteration of the outer loop. The inner loop index \code{j} changes fastest.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{()}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlnum{0}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(A))}
    \hlstd{row.sum[i]} \hlkwb{<-} \hlstd{row.sum[i]} \hlopt{+} \hlstd{A[i, j]}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\begin{verbatim}
##  [1] 105 110 115 120 125 130 135 140 145 150
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
The nested loops above work correctly with any two-dimensional matrix with at least one column and one row, but \emph{crash} with an empty matrix (\code{matrix()} or \code{matrix(numeric())}). Thus it is good practice to enclose the \Rloop{for} loop in an \Rcontrol{if} statement as protection. For the example above, a suitable \code{logical} condition is \code{!is.null(dim(A)) \&\& !any(dim(A) == 0}.
\end{warningbox}

\begin{advplayground}
1) Modify the code in last chunk above so that it sums the values only in the first three columns of \code{A}, and 2) modify the same code so that it sums the values only in the last three rows of \code{A}.

Does the code you wrote work as expected when the number of rows in \code{A} is different from 10? and, also if the number of columns in \code{A} is different from 5? What would happen if \code{A} had fewer than three columns? Try to think first what to expect based on the code you wrote. Then create matrices of different sizes and test your code. After that, if necessary, try to improve the code, so that wrong results are never returned.
\end{advplayground}

\section[Apply Functions]{\emph{Apply} Functions}\label{sec:data:apply}

\emph{Apply}\index{apply functions}\index{loops!faster alternatives} functions' role is similar to that of the iteration loops discussed above. One could say that apply functions ``walk along'' a vector, list or a dimension of a matrix or an array, calling a function with each member of the collection as argument. Notation is more concise than in \code{for} constructs. However, apply functions can be used only when the operations to be applied are \emph{independent---i.e., the results from one iteration are not used in another iteration}.

\begin{warningbox}
Conceptually, \code{for}, \code{while} and \code{repeat} loops are interpreted as controlling a sequential evaluation of program statements. In contrast, \Rlang's \emph{apply} functions are, conceptually, thought as evaluating a function in parallel for each of the different members of their input. So, while in loops the results of earlier iterations through a loop can be stored in variables and used in subsequent iterations, this is not possible in the case of \emph{apply} functions.
\end{warningbox}

The different \emph{apply} functions in base \Rlang differ in the class of the values they accept for their \code{X} parameter, the class of the object they return and/or the class of the value returned by the applied function. \Rloop{lapply()}, \Rloop{vapply()} and \Rloop{sapply()} expect a \code{vector} or \code{list} as an argument passed through \code{X}. \Rloop{lapply()} returns a \code{list} or an \code{array}; and \Rloop{vapply()} always \emph{simplifies} its returned value into a vector, while \Rloop{sapply()} does the simplification according to the argument passed to its \code{simplify} parameter. All these \emph{apply} functions can be used to apply an \Rlang function that returns a value of the same or a different class as its argument. In the case of \Rloop{apply()} and \Rloop{lapply()} not even the length of the values returned for each member of the collection passed as an argument, needs to be consistent. Function \Rloop{apply()} is used to apply a function to the elements along one dimension of an object that has two or more \emph{dimensions} returning an array or a list or a vector depending on the size, and consistency in length and class among the values returned by the applied function.

\subsection{Applying functions to vectors, lists and data frames}

I exemplify the use of \Rloop{lapply()}, \Rloop{sapply()} and \Rloop{vapply()}. Below, they are used to apply function \Rfunction{log()} to each member of a \code{numeric} vector. This is a function defined in \Rlang itself, but user-defined functions and functions imported from packages can be applied identically. How to define packages and define new functions are the subject of chapter \ref{chap:R:functions} (on page \pageref{chap:R:functions}).

\begin{warningbox}
The individual member objects in the list or vector passed as argument to parameter \code{x} of \textit{apply} functions are passed as a positional argument to the first formal parameter of the applied function, i.e., only some \Rlang functions can be passed as an argument to \code{FUN}.
\end{warningbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{123456}\hlstd{)} \hlcom{# so that vct1 does not change}
\hlstd{vct1} \hlkwb{<-} \hlkwd{runif}\hlstd{(}\hlnum{6}\hlstd{)} \hlcom{# A short vector as input to keep output short}
\hlkwd{str}\hlstd{(vct1)}
\end{alltt}
\begin{verbatim}
##  num [1:6] 0.798 0.754 0.391 0.342 0.361 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwc{X} \hlstd{= vct1,} \hlkwc{FUN} \hlstd{= log)}
\hlkwd{str}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
## List of 6
##  $ : num -0.226
##  $ : num -0.283
##  $ : num -0.938
##  $ : num -1.07
##  $ : num -1.02
##  $ : num -1.62
\end{verbatim}
\end{kframe}
\end{knitrout}

The code above calls \code{log()} once with each of the six members of \code{vct1} as its first argument and collects the returned values into a \code{list}, hence the \code{l} in \Rloop{lapply()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{sapply}\hlstd{(}\hlkwc{X} \hlstd{= vct1,} \hlkwc{FUN} \hlstd{= log)}
\hlkwd{str}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
##  num [1:6] -0.226 -0.283 -0.938 -1.074 -1.018 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

The code above calls \code{log()} as in the previous example but collects the returned values into a vector, i.e., by default it \emph{simplifies} the list into a \code{vector} or \code{matrix} when possible, hence the \code{s} in \Rloop{sapply()}. Simplification can be skipped, in this case returning a list as \Rloop{lapply()} above (returned value not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{sapply}\hlstd{(}\hlkwc{X} \hlstd{= vct1,} \hlkwc{FUN} \hlstd{= log,} \hlkwc{simplify} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\hlkwd{str}\hlstd{(z)}
\end{alltt}
\end{kframe}
\end{knitrout}

\Rloop{vapply()} always returns a vector (no example shown), hence the \code{v} in its name. The computed results are the same using \Rloop{lapply()}, \Rloop{sapply()} or \Rloop{vapply()}, but the class and structure of the objects returned can differ, as well as how numbers are printed.

Function \Rfunction{log()} has a second parameter named \code{base} that can be passed and argument to override the default base ($e$) used to compute natural logarithms. Additional arguments like this can be passed by name, using the name of the parameter in the function passed as argument to \code{FUN}, in this case, \code{base}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{sapply}\hlstd{(}\hlkwc{X} \hlstd{= vct1,} \hlkwc{FUN} \hlstd{= log,} \hlkwc{base} \hlstd{=} \hlnum{10}\hlstd{)}
\hlkwd{str}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
##  num [1:6] -0.0981 -0.1229 -0.4075 -0.4665 -0.4421 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Anonymous functions can be defined (see section \ref{sec:script:functions} on page \pageref{sec:script:functions}) and directly passed as an argument to \code{FUN} without the need of separately assigning them to a name.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{sapply}\hlstd{(}\hlkwc{X} \hlstd{= vct1,} \hlkwc{FUN} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}\hlkwd{log10}\hlstd{(x} \hlopt{+} \hlnum{1}\hlstd{)\})}
\hlkwd{str}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
##  num [1:6] 0.255 0.244 0.143 0.128 0.134 ...
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

As explained in section \ref{sec:R:data:frames} on page \pageref{sec:R:data:frames}, class \code{data.frame} is derived from class \code{list}. The columns in a data frame are equivalent to members of a list, and functions can thus be applied to columns. The data frame \code{cars} from package \pkgname{datasets} contains data for speed and for stopping distance for cars stored in two columns or member variables, named \code{speed} and \code{dist}. The members of the returned \code{numeric} vector, containing the computed means, are named accordingly.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sapply}\hlstd{(}\hlkwc{X} \hlstd{= cars,} \hlkwc{FUN} \hlstd{= mean)}
\end{alltt}
\begin{verbatim}
## speed  dist 
## 15.40 42.98
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Here is a possible way of obtaining means and standard deviations of member vectors. The argument passed to \code{FUN.VALUE} provides a template for the type of the returned value and its organisation into rows and columns. Notice that the rows in the output are now named according to the names in \code{FUN.VALUE}.

A function that returns a numeric vector of length 2 containing mean and standard deviation can be defined by calling existing functions (see section \ref{sec:script:functions} on page \pageref{sec:script:functions}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mean_and_sd} \hlkwb{<-}
  \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{na.rm} \hlstd{=} \hlnum{FALSE}\hlstd{) \{}
    \hlkwd{c}\hlstd{(}\hlkwc{mean} \hlstd{=} \hlkwd{mean}\hlstd{(x,} \hlkwc{na.rm} \hlstd{= na.rm),}  \hlkwc{sd} \hlstd{=} \hlkwd{sd}\hlstd{(x,} \hlkwc{na.rm} \hlstd{= na.rm))}
  \hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

and \Rloop{vapply()} used to apply it to each member vector of the list. The argument passed to \code{FUN.VALUE} serves as a template indicating the values returned by function \code{mean\_and\_sd()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{values} \hlkwb{<-} \hlkwd{vapply}\hlstd{(}\hlkwc{X} \hlstd{= cars,}
                 \hlkwc{FUN} \hlstd{= mean_and_sd,}
                 \hlkwc{FUN.VALUE} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{0}\hlstd{),}
                 \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{class}\hlstd{(values)}
\end{alltt}
\begin{verbatim}
## [1] "matrix" "array"
\end{verbatim}
\begin{alltt}
\hlstd{values}
\end{alltt}
\begin{verbatim}
##          speed     dist
## mean 15.400000 42.98000
## sd    5.287644 25.76938
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{playground}
  Apply function \code{mean\_and\_sd()} defined above to the data frame \code{cars} from \pkgname{datasets}. The aim is to obtain the mean and standard deviation for each numeric column.
\end{playground}

\begin{advplayground}
Obtain the summary of dataset \code{airquality} with function \Rfunction{summary()}, but in addition, write code with an \emph{apply} function to count the number of non-missing values in each column. Hint: using \code{sum()} on a \code{logical} vector returns the count of \code{TRUE} values as \code{TRUE}, and \code{FALSE} are transparently converted into \code{numeric} 1 and 0, respectively, when \code{logical} values are used in arithmetic expressions.
\end{advplayground}

In the examples above, the \emph{apply} functions were used to ``reduce'' the data by applying summary functions. In the next code chunk, \code{lapply()} is used to construct the \code{list} of five vectors \code{ls1} using a vector of five numbers as argument passed to parameter \code{X}. As above, additional \emph{named} arguments are relayed to each call of \code{rnorm()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{123456}\hlstd{)}
\hlstd{ls1} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlkwc{X} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{v1} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{v2} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{v3} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{v4} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{v5} \hlstd{=} \hlnum{4}\hlstd{),}
              \hlkwc{FUN} \hlstd{= rnorm,} \hlkwc{mean} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{)}
\hlkwd{str}\hlstd{(ls1)}
\end{alltt}
\begin{verbatim}
## List of 5
##  $ v1: num [1:2] 10.83 9.72
##  $ v2: num [1:5] 9.64 10.09 12.25 10.83 11.31
##  $ v3: num [1:3] 12.5 11.17 9.57
##  $ v4: num 9
##  $ v5: num [1:4] 8.89 9.94 11.17 11.05
\end{verbatim}
\end{kframe}
\end{knitrout}

In addition to functions returning pseudo-random draws from different probability distributions, constructors for objects of various classes can be used similarly.

\subsection{Applying functions to matrices and arrays}

Matrices and arrays have two or more dimensions, and contrary to data frames, they are not a special kind of one-dimensional lists. In \Rlang, the dimensions of a matrix, rows and columns, over which a function is applied are called \emph{margins} (see section \ref{sec:matrix:array}, and Figure \ref{fig:matrix:margins} on page \pageref{fig:matrix:margins}). The argument passed to parameter \code{MARGIN} determines \emph{over} which margin the function will be applied. Arrays can have many dimensions (see Figure \ref{fig:array:margins} on page \pageref{fig:array:margins}), and consequently more margins. In the case of arrays with more than two dimensions, it is possible and can be useful to apply functions over multiple margins at once.

\begin{warningbox}
The individual \emph{slices} of the matrix or array passed as argument to parameter \code{X} of \textit{apply} functions are passed as a positional argument to the first formal parameter of the applied function, i.e., only some \Rlang functions can be passed as argument to \code{FUN}.
\end{warningbox}

Matrix \code{mat1} constructed here will be used in examples. Adding names helps with understanding both here and when using matrices in real data analysis situations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{6}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{),} \hlkwc{ncol} \hlstd{=} \hlnum{2}\hlstd{)}
\hlstd{mat1} \hlkwb{<-} \hlkwd{round}\hlstd{(mat1,} \hlkwc{digits} \hlstd{=} \hlnum{1}\hlstd{)}
\hlkwd{dimnames}\hlstd{(mat1)} \hlkwb{<-} \hlcom{# add row and column names}
  \hlkwd{list}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"row"}\hlstd{,} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(mat1)),} \hlkwd{paste}\hlstd{(}\hlstr{"col"}\hlstd{,} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(mat1)))}
\hlstd{mat1}
\end{alltt}
\begin{verbatim}
##       col 1 col 2
## row 1  10.1  11.7
## row 2   9.3  10.6
## row 3  10.9   9.2
\end{verbatim}
\end{kframe}
\end{knitrout}

Column (or row) means of matrices can be easily computed with \Rfunction{apply()}. However, in contrast to when using other \emph{apply} functions, an argument must be passed to parameter \code{MARGIN}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{apply}\hlstd{(mat1,} \hlkwc{MARGIN} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{FUN} \hlstd{= mean)}
\end{alltt}
\begin{verbatim}
## col 1 col 2 
##  10.1  10.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Edit the example above so that it computes row means instead of column means.
\end{playground}

\begin{advplayground}
As described above, we can pass arguments by name to the applied function. Can you guess why parameter names of \emph{apply} functions are fully in uppercase, something very unusual for \Rlang coding style?
\end{advplayground}

If the function applied returns a value of the same length as its input, then the dimensions of the value returned by \Rloop{apply()} are the same as those of its input. Using the identity function \Rfunction{I()} that returns its argument unchanged, facilitates the comparison of output against input.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{apply}\hlstd{(}\hlkwc{X} \hlstd{= mat1,} \hlkwc{MARGIN} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{FUN} \hlstd{= I)}
\hlkwd{dim}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
## [1] 3 2
\end{verbatim}
\begin{alltt}
\hlstd{z}
\end{alltt}
\begin{verbatim}
##       col 1 col 2
## row 1  10.1  11.7
## row 2   9.3  10.6
## row 3  10.9   9.2
\end{verbatim}
\end{kframe}
\end{knitrout}

Passing \code{MARGIN = 1} as below instead of \code{MARGIN = 2} as above, rows and columns are transposed in the returned value!.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{apply}\hlstd{(}\hlkwc{X} \hlstd{= mat1,} \hlkwc{MARGIN} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{FUN} \hlstd{= I)}
\hlkwd{dim}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
## [1] 2 3
\end{verbatim}
\begin{alltt}
\hlstd{z}
\end{alltt}
\begin{verbatim}
##       row 1 row 2 row 3
## col 1  10.1   9.3  10.9
## col 2  11.7  10.6   9.2
\end{verbatim}
\end{kframe}
\end{knitrout}

The next, more realistic example, applies function \Rfunction{summary()} that returns a value usually shorter than its input, but longer than one. Both for column summaries (\code{MARGIN = 2}) and row summaries (\code{MARGIN = 1}), a matrix is returned. Each columns, a numeric vector in this example, contains the vector returned by a call to \Rfunction{summary()}. Column and row names from \code{mat1} are preserved, as well as the names in the value returned by \Rfunction{summary()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{apply}\hlstd{(}\hlkwc{X} \hlstd{= mat1,} \hlkwc{MARGIN} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{FUN} \hlstd{= summary)}
\hlstd{z}
\end{alltt}
\begin{verbatim}
##         col 1 col 2
## Min.      9.3  9.20
## 1st Qu.   9.7  9.90
## Median   10.1 10.60
## Mean     10.1 10.50
## 3rd Qu.  10.5 11.15
## Max.     10.9 11.70
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{z} \hlkwb{<-} \hlkwd{apply}\hlstd{(}\hlkwc{X} \hlstd{= mat1,} \hlkwc{MARGIN} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{FUN} \hlstd{= summary)}
\hlstd{z}
\end{alltt}
\begin{verbatim}
##         row 1  row 2  row 3
## Min.     10.1  9.300  9.200
## 1st Qu.  10.5  9.625  9.625
## Median   10.9  9.950 10.050
## Mean     10.9  9.950 10.050
## 3rd Qu.  11.3 10.275 10.475
## Max.     11.7 10.600 10.900
\end{verbatim}
\end{kframe}
\end{knitrout}

\Kern{-1}{Binary operators in \Rlang are functions with two formal parameters which can be called using infix notation in expressions---i.e., \code{a + b}. By back-quoting their names they can be called using the same syntax as for ordinary functions, and consequently also passed to the \code{FUN} parameter of apply functions. A toy example, equivalent to the vectorised operation \code{vct1 + 5} follows. By enclosing operator \Roperator{+} in back ticks (\code{`}) and passing by name a constant to its second formal parameter (\code{e2 = 5}) operator \Roperator{+} behaves like an ordinary function. See section \ref{sec:operator:functions} on page \pageref{sec:operator:functions}).}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{123456}\hlstd{)} \hlcom{# so that vct1 does not change}
\hlstd{vct1} \hlkwb{<-} \hlkwd{runif}\hlstd{(}\hlnum{10}\hlstd{)}
\hlstd{z} \hlkwb{<-} \hlkwd{sapply}\hlstd{(}\hlkwc{X} \hlstd{= vct1,} \hlkwc{FUN} \hlstd{= `+`,} \hlkwc{e2} \hlstd{=} \hlnum{5}\hlstd{)}
\hlkwd{str}\hlstd{(z)}
\end{alltt}
\begin{verbatim}
##  num [1:10] 5.8 5.75 5.39 5.34 5.36 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Functions that Replace Loops}\label{sec:vectorised:functions}

\begin{table}
  \caption[Functions that replace loops]{\Rlang functions that can substitute for iteration loops. They accept vectors as arguments for their first parameter, except for \Rfunction{rowSums()}, \Rfunction{colSums()}, \Rfunction{rowMeans()}, and \Rfunction{colMeans()} which accept \code{matrix} objects. Only functions that return a value with the same dimensions as the argument passed as input are vectorised in the sense used in this book.\vspace{1ex}}\label{tab:vectorised:functions}
  \centering
\noindent
\begin{tabular}{lll}
  \toprule
  Function & Computation & Returned class, length \\
  \midrule
  \Rfunction{sum()}\strut & $\sum_{i=1}^n x_i$ & \code{numeric}, $1$ \\
  \Rfunction{rowSums()}\strut & $\sum_{j=1}^l x_i$ & \code{numeric}, $n$ \\
  \Rfunction{colSums()}\strut & $\sum_{i=1}^n x_j$ & \code{numeric}, $l$ \\
  \Rfunction{mean()}\strut & $\sum_{i=1}^n x_i$ & \code{numeric}, $1$ \\
  \Rfunction{rowMeans()}\strut & $\sum_{j=1}^l x_i / l$ & \code{numeric}, $n$ \\
  \Rfunction{colMeans()}\strut & $\sum_{i=1}^n x_j / n$ & \code{numeric}, $l$ \\
  \Rfunction{prod()}\strut & $\prod_{i=1}^n x_i$ & \code{numeric}, $1$ \\
  \Rfunction{cumsum()}\strut & $\sum_{i=1}^1 x_i, \cdots \sum_{i=1}^j x_i, \cdots \sum_{i=1}^n x_i$ & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}$ \\
  \Rfunction{cumprod()}\strut & $\prod_{i=1}^1 x_i, \cdots \prod_{i=1}^j x_i, \cdots \prod_{i=1}^n x_i$ & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}$ \\
  \Rfunction{cummax()}\strut & cumulative maximum & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}$ \\
  \Rfunction{cummin()}\strut & cumulative minimum & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}$ \\
  \Rfunction{runmed()}\strut & running median & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}$ \\
  \Rfunction{diff()}\strut & $x_2 - x_1, \cdots x_i - x_{i-1}, \cdots x_n - x_{n-1}$ & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}-1$ \\
  \Rfunction{diffinv()}\strut & inverse of diff & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}+1$ \\
  \Rfunction{factorial()}\strut & $x!$ & \code{numeric}, $n_\mathrm{out} = n_\mathrm{in}$ \\
  \Rfunction{rle()}\strut & run-length encoding & \code{rle}, $n_\mathrm{out} < n_\mathrm{in}$ \\
  \Rfunction{inverse.rle()}\strut & run-length decoding & \code{vector}, $n_\mathrm{out} > n_\mathrm{in}$ \\
  \bottomrule
\end{tabular}
\end{table}

\Rlang provides several functions that can be used to avoid writing iterative loops. The most frequently used are taken for granted: \Rfunction{mean()}, \Rfunction{var()} (variance), \Rfunction{sd()} (standard deviation), \Rfunction{max()}, and \Rfunction{min()}. Replacing code implementing an iterative algorithm by a single function call simplifies the script's code and can make it easier to understand. These functions are written in \Clang and compiled, so even when iterative algorithms are used, they are fast (see section \ref{sec:loops:slow} on page \pageref{sec:loops:slow}). Table \ref{tab:vectorised:functions} lists several functions from base \Rlang that implement iterative algorithms. All these functions take a vector of arbitrary length as their first argument, except for \Rfunction{inverse.rle()}.\vspace{2ex}

\begin{playground}
  Build a \code{numeric} vector such as \code{x <- c(1, 9, 6, 4, 3)} and pass it as argument to the functions in Table \ref{tab:vectorised:functions}. Do the corresponding computations manually for the functions your find most relevant, trying to understand what values they calculate.
\end{playground}
\index{loops!faster alternatives|)}

\section{The Multiple Faces of Loops}\label{sec:R:faces:of:loops}

\ilAdvanced\ In this advanced section, I describe some uses of \Rlang loops that help with writing  concise scrips. As these make heavy use of functions, if you are reading the book sequentially, you should skip this section and return to it after reading chapters \ref{chap:R:functions} and \ref{chap:R:statistics}.

In the same way as we can assign names to \code{numeric}, \code{character} and other types of objects, we can assign names to functions and expressions. We can also create lists of functions and/or expressions. The \Rlang language has a very consistent grammar, with all lists and vectors behaving in the same way. The implication of this is that we can assign different functions or expressions to a given name and, consequently, it is possible to write loops over lists of functions or expressions.

The next example, uses a \emph{character vector of function names} together with function \Rfunction{do.call()} in the body of a \Rcontrol{for} loop, to construct a \code{numeric} vector with members, named according to the function names, storing the computed values. Function \Rfunction{do.call()} accepts both character strings and function names as argument to its first parameter, and calls the corresponding function with arguments supplied as a \code{list}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{)}
\hlstd{results} \hlkwb{<-} \hlkwd{numeric}\hlstd{()}
\hlstd{fun.names} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"mean"}\hlstd{,} \hlstr{"max"}\hlstd{,} \hlstr{"min"}\hlstd{)}
\hlkwa{for} \hlstd{(f.name} \hlkwa{in} \hlstd{fun.names) \{}
  \hlstd{results[[f.name]]} \hlkwb{<-} \hlkwd{do.call}\hlstd{(f.name,} \hlkwd{list}\hlstd{(vct1))}
\hlstd{\}}
\hlstd{results}
\end{alltt}
\begin{verbatim}
##       mean        max        min 
##  0.5453427  2.5026454 -1.1139499
\end{verbatim}
\end{kframe}
\end{knitrout}

When traversing a \emph{list of functions} in a loop, the original names of the functions are not available as what is stored in the list are the definitions of the functions rather than their names. In this case, the function definitions are assigned to the placeholder variable (\code{f} in the chunk below) and the functions be called directly with (\code{f()}). The result is a numeric vector with anonymous members.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{results} \hlkwb{<-} \hlkwd{numeric}\hlstd{()}
\hlstd{funs} \hlkwb{<-} \hlkwd{list}\hlstd{(mean, max, min)}
\hlkwa{for} \hlstd{(f} \hlkwa{in} \hlstd{funs) \{}
  \hlstd{results} \hlkwb{<-} \hlkwd{c}\hlstd{(results,} \hlkwd{f}\hlstd{(x))}
\hlstd{\}}
\hlstd{results}
\end{alltt}
\begin{verbatim}
## [1] 8 8 8
\end{verbatim}
\end{kframe}
\end{knitrout}

A named list of functions makes it possible to gain full control of the naming of the results. It is possible to construct a numeric vector with named members with names matching the names given to the list members, which can be different to the names of the functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{results} \hlkwb{<-} \hlkwd{numeric}\hlstd{()}
\hlstd{funs} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{average} \hlstd{= mean,} \hlkwc{maximum} \hlstd{= max,} \hlkwc{minimum} \hlstd{= min)}
\hlkwa{for} \hlstd{(f} \hlkwa{in} \hlkwd{names}\hlstd{(funs)) \{}
  \hlstd{results[[f]]} \hlkwb{<-} \hlstd{funs[[f]](x)}
\hlstd{\}}
\hlstd{results}
\end{alltt}
\begin{verbatim}
## average maximum minimum 
##       8       8       8
\end{verbatim}
\end{kframe}
\end{knitrout}

Next is an example using model formulas. In the this example, a loop is used to fit three models, obtaining a list of fitted models. It is not possible to pass to \Rfunction{anova()} this list of fitted models, as it expects each fitted model as a separate nameless argument to its \code{\ldots} parameter. It is possible to get around this problem using function \Rfunction{do.call()} to call \Rfunction{anova()}. Function \Rfunction{do.call()} passes the members of the list passed as its second argument as individual arguments to the function being called, using their names if present. \Rfunction{anova()} expects nameless arguments, so the names present in \code{results} have to be removed with a call to \Rfunction{unname()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10} \hlopt{+} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{0.1}\hlstd{))}
\hlstd{results} \hlkwb{<-} \hlkwd{list}\hlstd{()}
\hlstd{models} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{linear} \hlstd{= y} \hlopt{~} \hlstd{x,} \hlkwc{linear.orig} \hlstd{= y} \hlopt{~} \hlstd{x} \hlopt{-} \hlnum{1}\hlstd{,} \hlkwc{quadratic} \hlstd{= y} \hlopt{~} \hlstd{x} \hlopt{+} \hlkwd{I}\hlstd{(x}\hlopt{^}\hlnum{2}\hlstd{))}
\hlkwa{for} \hlstd{(m} \hlkwa{in} \hlkwd{names}\hlstd{(models)) \{}
  \hlstd{results[[m]]} \hlkwb{<-} \hlkwd{lm}\hlstd{(models[[m]],} \hlkwc{data} \hlstd{= my.data)}
\hlstd{\}}
\hlkwd{str}\hlstd{(results,} \hlkwc{max.level} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## List of 3
##  $ linear     :List of 12
##   ..- attr(*, "class")= chr "lm"
##  $ linear.orig:List of 12
##   ..- attr(*, "class")= chr "lm"
##  $ quadratic  :List of 12
##   ..- attr(*, "class")= chr "lm"
\end{verbatim}
\begin{alltt}
\hlkwd{do.call}\hlstd{(anova,} \hlkwd{unname}\hlstd{(results))}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Model 1: y ~ x
## Model 2: y ~ x - 1
## Model 3: y ~ x + I(x^2)
##   Res.Df     RSS Df Sum of Sq      F    Pr(>F)    
## 1      8 0.05525                                  
## 2      9 2.31266 -1   -2.2574 306.19 4.901e-07 ***
## 3      7 0.05161  2    2.2611 153.34 1.660e-06 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

If the only aim is to pass \code{results} to \Rfunction{anova()} a \code{list} of nameless members can be constructed using positional indexing.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{results} \hlkwb{<-} \hlkwd{list}\hlstd{()}
\hlstd{models} \hlkwb{<-} \hlkwd{list}\hlstd{(y} \hlopt{~} \hlstd{x, y} \hlopt{~} \hlstd{x} \hlopt{-} \hlnum{1}\hlstd{, y} \hlopt{~} \hlstd{x} \hlopt{+} \hlkwd{I}\hlstd{(x}\hlopt{^}\hlnum{2}\hlstd{))}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along.with} \hlstd{= models)) \{}
  \hlstd{results[[i]]} \hlkwb{<-} \hlkwd{lm}\hlstd{(models[[i]],} \hlkwc{data} \hlstd{= my.data)}
\hlstd{\}}
\hlkwd{str}\hlstd{(results,} \hlkwc{max.level} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## List of 3
##  $ :List of 12
##   ..- attr(*, "class")= chr "lm"
##  $ :List of 12
##   ..- attr(*, "class")= chr "lm"
##  $ :List of 12
##   ..- attr(*, "class")= chr "lm"
\end{verbatim}
\begin{alltt}
\hlkwd{do.call}\hlstd{(anova, results)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Model 1: y ~ x
## Model 2: y ~ x - 1
## Model 3: y ~ x + I(x^2)
##   Res.Df     RSS Df Sum of Sq      F    Pr(>F)    
## 1      8 0.05525                                  
## 2      9 2.31266 -1   -2.2574 306.19 4.901e-07 ***
## 3      7 0.05161  2    2.2611 153.34 1.660e-06 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\section{Iteration When Performance Is Important}\label{sec:loops:slow}
\index{vectorisation}\index{recycling of arguments}\index{iteration}\index{loops!faster alternatives|(}
When working with large data sets, or many smaller data sets, one frequently needs to take performance into account. In \Rlang, explicit \Rloop{for}, \Rloop{while} and \Rloop{repeat} are frequently considered to be slow. Vectorised operations are in general comparatively faster. As vectorisation (see page \pageref{par:calc:vectorised:opers}) usually also makes code simpler, it is good to use vectorisation whenever possible. Depending on the case, loops can be replaced using vectorised arithmetic operators, \emph{apply} functions (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}) and functions implementing frequently used operations (see section \ref{sec:vectorised:functions} on page \pageref{sec:vectorised:functions}). Improved performance needs to be balanced against the effort invested in writing faster code, as in most cases our own time is more valuable than computer running time. However, using vectorised operators and optimised functions becomes nearly effortless once one is familiar with them.\qRloop{for}

To demonstrate the magnitude of the differences in performance that can be expected, I used as a first case the computation of the differences between successive numbers in a vector, applied to vectors of lengths ranging from 10 to 100 million numbers (Figure \ref{fig:diff:benchmarks}). In relative terms, the difference in computation time was huge between loops and vectorisation for vectors of up to 1\,000 numbers (near $\times 500$), but the total times were very short ($5 \times 10^{-3}$\,s vs.\ $10 \times 10^{-6}$\,s). For these vectors, pre-allocation of a vector to collect the results made almost no difference and vectorisation with the extraction operator \Roperator{[ ]} together with the minus arithmetic operator \Roperator{-} was the fastest. There seems to be a significant overhead for explicit loops, as the running time was nearly independent of the length of these short vectors.

For vectors of 10\,000 or more numbers there was only a very small advantage in using function \Rfunction{diff()} over using vectorised arithmetic and extraction operators. For \Rloop{while} and \Rloop{for} loops pre-allocation of the vector to collect results made an important difference ($\times 2$ to $\times 3$), larger in the case of \Rloop{for}. However, vectorised operators and function \Rfunction{diff()} remained nearly $\times 10$ faster than the fastest explicit loop. For the longer vectors the time increased almost linearly with their length, with similar slopes for the different approaches. Because of the computation used for this example, \emph{apply()} functions could not be used.

\begin{figure}
\centering



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-bench-diff-01-1} 

}


\end{knitrout}



\caption[Benchmark results for running differences.]{Benchmark results for different approaches to computing running differences in numeric (double) vectors of different lengths. The data in this figure were obtained in a computer with a 12-years old Xenon E3-1235 CPU with four cores, 32\,GB of RAM, Windows 10 and \Rpgrm 4.3.1.}\label{fig:diff:benchmarks}
\end{figure}

\begin{explainbox}
The chunks below show the code for the six approaches compared in Figure \ref{fig:diff:benchmarks}, where \code{a} is a numeric vector varying length constructed with function \code{rnorm()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# do not pre-allocate memory}
\hlstd{i} \hlkwb{<-} \hlnum{1}
\hlkwa{while} \hlstd{(i} \hlopt{<} \hlkwd{length}\hlstd{(a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i}\hlopt{+}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{a[i]}
  \hlstd{i} \hlkwb{<-} \hlstd{i} \hlopt{+} \hlnum{1}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{)} \hlcom{# pre-allocate memory}
\hlstd{i} \hlkwb{<-} \hlnum{1}
\hlkwa{while} \hlstd{(i} \hlopt{<} \hlkwd{length}\hlstd{(a)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i}\hlopt{+}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{a[i]}
  \hlstd{i} \hlkwb{<-} \hlstd{i} \hlopt{+} \hlnum{1}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{()} \hlcom{# do not pre-allocate memory}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along.with} \hlstd{= b)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i}\hlopt{+}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{a[i]}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{)} \hlcom{# pre-allocate memory}
\hlkwa{for}\hlstd{(i} \hlkwa{in} \hlkwd{seq}\hlstd{(}\hlkwc{along.with} \hlstd{= b)) \{}
  \hlstd{b[i]} \hlkwb{<-} \hlstd{a[i}\hlopt{+}\hlnum{1}\hlstd{]} \hlopt{-} \hlstd{a[i]}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# vectorised using extraction operators}
\hlstd{b} \hlkwb{<-} \hlstd{a[}\hlnum{2}\hlopt{:}\hlkwd{length}\hlstd{(a)]} \hlopt{-} \hlstd{a[}\hlnum{1}\hlopt{:}\hlkwd{length}\hlstd{(a)}\hlopt{-}\hlnum{1}\hlstd{]}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# vectorised function diff()}
\hlstd{b} \hlkwb{<-} \hlkwd{diff}\hlstd{(a)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

In nested iteration loops, it is most important to vectorise, or otherwise enhance the performance of the innermost loop, as it is the one executed most frequently. The code for nested loops (used as an example in section \ref{sec:nested:loops} on page \pageref{sec:nested:loops}) can be edited to remove the explicit use of \Rloop{for} loops. I assessed the performance of different approaches by collecting timings for square \code{matrix} objects with dimensions (rows $\times$ columns) ranging from $10 \times 10$, size = $10^2$, to $10\,000 \times 10\,000$, size = $10^8$ (Figure \ref{fig:rowsums:benchmarks}).

In this second case, pre-allocation of memory to \code{b} did not enhance performance in good agreement with the benchmarks for the first example as when largest its length was 10\,000. The two nested loops always took the longest to run irrespective of the size of matrix \code{A}. A single loop over rows using a call to \Rfunction{sum()} for each row, improved performance compared to nested loops, most clearly for large matrices. This approach was out-performed by \Rfunction{apply()} only for small matrices, from which we can infer that \Rfunction{apply()} has a much smaller overhead than an explicit \Rloop{for} loop. \Rfunction{rowSums()} was between $\times 5$ and $\times 20$ faster than the second fastest approach depending on the size of the matrix.

\begin{figure}
\centering



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-bench-rowsums-01-1} 

}


\end{knitrout}



\caption[Benchmark results for row sums.]{Benchmark results for different approaches to computing row sums of square numeric (double) matrices of different sizes. The data in this figure were obtained in a computer with a 12-years-old Xenon E3-1235 CPU with four cores, 32\,GB of RAM, Windows 10, and \Rpgrm 4.3.1.}\label{fig:rowsums:benchmarks}
\end{figure}

\begin{explainbox}
The chunks below show the code for the six approaches compared in Figure \ref{fig:rowsums:benchmarks}, where \code{A} was a numeric matrix constructed with function \code{rnorm()}.

The inner \Rloop{for} loop can be replaced by function \code{sum()} which returns the sum of a vector. Within the loop, \code{A[i, ]} extracts whole rows, one at a time.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{()}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlnum{0}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{ncol}\hlstd{(A))}
    \hlstd{row.sum[i]} \hlkwb{<-} \hlstd{row.sum[i]} \hlopt{+} \hlstd{A[i, j]}
\hlstd{\}}
\hlkwd{print}\hlstd{(row.sum)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{numeric}\hlstd{(}\hlkwd{nrow}\hlstd{(A))} \hlcom{# faster}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(A)) \{}
  \hlstd{row.sum[i]} \hlkwb{<-} \hlkwd{sum}\hlstd{(A[i, ])}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The\index{apply functions} outer loop can be replaced by a call to \Rfunction{apply()} (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{row.sum} \hlkwb{<-} \hlkwd{apply}\hlstd{(A,} \hlkwc{MARGIN} \hlstd{=} \hlnum{1}\hlstd{, sum)} \hlcom{# MARGIN=1 indicates rows}
\end{alltt}
\end{kframe}
\end{knitrout}

Calculating row sums is a frequent operation, thus, \Rlang provides a built-in function for this.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{rowSums}\hlstd{(A)}
\end{alltt}
\end{kframe}
\end{knitrout}
\pagebreak

The simplest way of measuring the execution time of an \Rlang expression is to use function \Rfunction{system.time()}. Package \pkgname{microbenchmark}, used for the benchmarks shown in Figures \ref{fig:diff:benchmarks} and \ref{fig:rowsums:benchmarks}, provides finer time resolution.
\end{explainbox}

As in these examples the computations in the body of the loop are very simple, the overhead of the iterative loops strongly affects the total computation time in these benchmarks. When the computations at each iteration are time consuming, the overhead of using explicit iteration loops gets diluted. Thus, removing the explicit use of iteration is most helpful, when it is easier to implement vectorised arithmetic or find optimised functions.

\begin{warningbox}
  The timings in Figures \ref{fig:diff:benchmarks} and \ref{fig:rowsums:benchmarks} are only valid for the specific computer configuration, operating system and \Rpgrm version that I used. They provide only an approximate guide to what can be expected in different conditions. The scripts used are included in package \pkgname{learnrbook} in case readers wish to run them on their computers. As replication is used, the total run time for the script is relatively long.
\end{warningbox}

\begin{explainbox}
  You may be wondering: how do the faster approaches manage to avoid the overhead of iteration? Of course, they do not really avoid iteration, but the loops in functions written in \Clang, \Cpplang, or \langname{FORTRAN} are compiled into machine code as part of \Rpgrm itself or when packages binaries are created. In simpler words, the time required to convert and optimise the code written in these languages into machine code is spent during compilation, usually before we download and install \Rlang or packages. Instead, a loop coded in \Rlang is interpreted into machine code each time we source our script, and in some cases for each iteration in a loop. The \Rlang interpreter does some compilation into virtual machine code, as a preliminary stage which helps improve performance.
\end{explainbox}

The examples in this section use numbers and arithmetic operations, but vectorisation and \emph{apply} functions can be also used with vectors of other modes, such as vectors of \code{character} strings or \code{logical} values.

With modern computer processors, or CPUs, splitting the tasks across multiple cores for concurrent execution can enhance performance. To some extent this happens invisibly due to optimisations in the translation into machine code. Explicit approaches are available in package \pkgname{parallel} included in the \Rlang distribution and contributed packages such as \pkgname{future}. Parallelisation is also possible across interconnected computers. However, how to enhance performance based on parallel or distributed execution is beyond the scope of this book.

\section{Object Names as Character Strings}

In\index{object names}\index{object names!as character strings} all assignment examples before this section, we have used object names included as literal character strings in the code expressions. In other words, the names are ``decided'' as part of the code, rather than at run time. In scripts or packages, the object name to be assigned may need to be decided at run time and, consequently, be available only as a character string stored in a variable. In this case, function \Rfunction{assign()} must be used instead of the operators \code{<-} or \code{->}. The statements below demonstrate its use.

First using a \code{character} constant.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{assign}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlnum{9.99}\hlstd{)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 9.99
\end{verbatim}
\end{kframe}
\end{knitrout}
Next using a \code{character} value stored in a variable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{name.of.var} \hlkwb{<-} \hlstr{"b"}
\hlkwd{assign}\hlstd{(name.of.var,} \hlnum{9.99}\hlstd{)}
\hlstd{b}
\end{alltt}
\begin{verbatim}
## [1] 9.99
\end{verbatim}
\end{kframe}
\end{knitrout}

The two toy examples above do not demonstrate why one may want to use \Rfunction{assign()}. Common situations where we may want to use character strings to store (future or existing) object names are 1) when we allow users to provide names for objects either interactively or as \code{character} data, 2) when in a loop we transverse a vector or list of object names, or 3) we construct at runtime object names from multiple character strings based on data or settings. A common case is when we import data from a text file and we want to name the object according to the name of the file on disk, or a character string read from the header at the top of the file.

Another case is when \code{character} values are the result of a computation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{) \{}
   \hlkwd{assign}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"square_of_"}\hlstd{, i,} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{), i}\hlopt{^}\hlnum{2}\hlstd{)}
\hlstd{\}}
\hlkwd{ls}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"square_of_*"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "square_of_1" "square_of_2" "square_of_3" "square_of_4" "square_of_5"
\end{verbatim}
\end{kframe}
\end{knitrout}

The complementary operation of \emph{assigning} a name to an object is to \emph{get} an object when we have available its name as a character string. The corresponding function is \Rfunction{get()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{get}\hlstd{(}\hlstr{"a"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 9.99
\end{verbatim}
\begin{alltt}
\hlkwd{get}\hlstd{(}\hlstr{"b"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 9.99
\end{verbatim}
\end{kframe}
\end{knitrout}

If we have available a character vector containing object names and we want to create a list containing these objects we can use function \Rfunction{mget()}. In the example below we use function \code{ls()} to obtain a character vector of object names matching a specific pattern and then collect all these objects into a list.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{obj_names} \hlkwb{<-} \hlkwd{ls}\hlstd{(}\hlkwc{pattern} \hlstd{=} \hlstr{"square_of_*"}\hlstd{)}
\hlstd{obj_lst} \hlkwb{<-} \hlkwd{mget}\hlstd{(obj_names)}
\hlkwd{str}\hlstd{(obj_lst)}
\end{alltt}
\begin{verbatim}
## List of 5
##  $ square_of_1: num 1
##  $ square_of_2: num 4
##  $ square_of_3: num 9
##  $ square_of_4: num 16
##  $ square_of_5: num 25
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Think of possible uses of functions \Rfunction{assign()}, \Rfunction{get()} and \Rfunction{mget()} in scripts you use or could use to analyse your own data (or from other sources). Write a script to implement this, and iteratively test and revise this script until the result produced by the script matches your expectations.
\end{advplayground}

\section{Clean-Up}

Sometimes we need to make sure that clean-up code is executed even if the execution of a script or function is aborted by the user or as a result of an error condition. A typical example is a script that temporarily sets a disk folder as the working directory or uses a file as temporary storage. Function \Rfunction{on.exit()} can be used to record that a user supplied expression needs to be executed when the current function, or a script, exits. Function \Rfunction{on.exit()} can also make code easier to read as it keeps creation and clean-up next to each other in the body of a function or in the listing of a script.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{file.create}\hlstd{(}\hlstr{"temp.file"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{on.exit}\hlstd{(}\hlkwd{file.remove}\hlstd{(}\hlstr{"temp.file"}\hlstd{))}
\hlcom{# code that makes use of the file goes here}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{library()} attaches the namespace of the loaded packages and in some special cases one may want to detach them at the end of a script. We can use \Rfunction{detach()} similarly as with attached \code{data.frame} objects (see page \pageref{par:calc:attach}). As an example, we detach the packages used in section \ref{sec:loops:slow}. It is important to remember that the order in which they can be detached is determined by their interdependencies.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{patchwork)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{ggplot2)}
\hlkwd{detach}\hlstd{(package}\hlopt{:}\hlstd{scales)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Further Reading}
For\index{further reading!the R language} further readings on the aspects of \Rlang discussed in the current chapter, I suggest the books \citetitle{Matloff2011} \autocite{Matloff2011} and \citetitle{Wickham2019} \autocite{Wickham2019}.


% !Rnw root = appendix.main.Rnw


\chapter{Base \Rlang: Adding New ``Words''}\label{chap:R:functions}

\begin{VF}
Computer Science is a science of abstraction---creating the right model for a problem and devising the appropriate mechanizable techniques to solve it.

\VA{Alfred V. Aho and Jeffrey D. Ullman}{\emph{Foundations of Computer Science}, 1992}\nocite{Aho1992}
\end{VF}

%\dictum[Alfred V. Aho, Jeffrey D. Ullman, \emph{Foundations of Computer Science}, Computer Science Press, 1992]{Computer Science is a science of abstraction---creating the right model for a problem and devising the appropriate mechanizable techniques to solve it.}\vskip2ex

\section{Aims of This Chapter}

In earlier chapters we have only used base \Rlang features. In this chapter you will learn how to expand the range of features available. I start by discussing how to define and use new functions, operators, and classes. What are their semantics and how they contribute to conciseness and reliability of computer scripts and programs. Later I focus on using existing packages to share extensions to \Rlang and touch briefly on how they work. I do not consider the important, but more advanced question of packaging functions and classes into new \Rlang packages. Instead I discuss how packages are installed and used.

\section{Defining Functions and Operators}\label{sec:script:functions}
\index{functions!defining new}\index{operators!defining new}

\emph{Abstraction} can be defined as separating the fundamental properties from the accidental ones. Say obtaining the mean from a given vector of numbers is an actual operation. There can be many such operations on different numeric vectors, each one a specific case. When we describe an algorithm for computing the mean from any numeric vector, we formulate an abstraction of \emph{mean}. In the same way, each time we separate operations from specific data we create a new abstraction. In this sense, functions are abstractions of operations or actions; they are like ``verbs'' describing actions separately from actors.

The main role of functions is that of providing an abstraction allowing us to avoid repeating blocks of code (groups of statements) applying the same operations on different data. The reasons to avoid repetition of similar blocks of code statements are that 1) if the algorithm or implementation needs to be revised---e.g., to fix a bug or error---it is best to make edits in a single place; 2) sooner or later pieces of repeated code can become different leading to inconsistencies and hard-to-track bugs; 3) abstraction and division of a problem into smaller chunks, greatly helps with keeping the code understandable to humans; 4) textual repetition makes the script file longer, and this makes debugging, commenting, etc., more tedious, and error prone; 5) with well-defined input and output, functions facilitate testing.

How does one, in practice, avoid repeating bits of code? One writes a function containing the statements that would need to be repeated, and later one \emph{calls} (``uses'') the function in their place. We have been calling \Rlang functions or operators in almost every example in this book; what we will next tackle is how to define new functions of our own.

The diagram in section \ref{sec:script:compound:statement} on page \pageref{sec:script:compound:statement} describes a compound statement. A function is a code statement, simple or compound, that is partly isolated from the enclosing environment. The \emph{function} abstraction relies on formal parameters working as placeholders for arguments within the function body. When the function is called (or ``used'') values are passed as arguments to the parameters, and used when executing the code within the function.

New functions and operators are defined using function \Rfunction{function()}, and saved like any other object in \Rlang by assignment to a variable name. In the example below, \code{x} and \code{y} are both formal parameters, or names used within the function for objects that will be supplied as \emph{arguments} when the function is called.

Function \code{fun1()} has two formal parameters, \code{x} and \code{y}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fun1} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{y}\hlstd{)\{x} \hlopt{*} \hlstd{y\}}
\end{alltt}
\end{kframe}
\end{knitrout}

When we call \code{fun1()} with \code{4} and \code{3} as arguments, the computation that takes place is \code{4 * 3} and the value returned is \code{12}. In this example, the returned value or result is printed, but it could have been assigned to a variable or used in further computations within the calling statement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{fun1}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 12
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
What is the computation that takes places in these function calls?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{fun1}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{50}\hlstd{)}
\hlkwd{fun1}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{50}\hlstd{)} \hlopt{*} \hlnum{3}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\begin{warningbox}
Even though the statements within the function body do have access to the environment in which the function is called, it is safest to pass all input through the function parameters, and return all values to the caller. This ensures that the users of the function can treat it as a black box with no side effects.
\end{warningbox}

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.7cm]
\node (call) [startstop] {\textsl{arguments $\to$ \textcolor{blue}{parameters}}};
\node (enc) [enclosure, color = blue, fill = blue!5, below of=call, yshift=-0.85cm] {\ };
\node (stat1) [process, color = blue, fill = blue!15, below of=call] {\code{<statement A>}};
\node (stat2) [process, color = blue, fill = blue!15, below of=stat1] {\code{<statement B>}};
\node (return) [startstop, below of=stat2] {\textsl{\textcolor{blue}{returned  value} $\to$ caller}};
\draw [arrow, color = blue] (call) -- (stat1);
\draw [arrow, color = blue] (stat1) -- (stat2);
\draw [arrow, color = blue] (stat2) -- (return);
\end{tikzpicture}
\end{small}
  \caption[Diagram of function with no side effects]{Diagram of function with no side effects, seen as a compound code statement receiving its input as arguments passed to its formal parameters and returning an object or value to the statement from where it was called or run. The body of the function is represented by the filled box.}\label{fig:function:diagram}
\end{figure}

In \Rlang, statements within the function usually do not affect directly any variable defined outside the function, the result from the computation is returned as a value. The diagram in Figure \ref{fig:function:diagram} describes a function that has no \emph{side effects}, as it does not affect its environment, it only returns a value to the caller. A value on which the caller has full control. The statement that calls the function ``decides'' what to do with the value received from the function.

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.7cm]
\node (call) [startstop] {\textsl{arguments $\to$ \textcolor{blue}{parameters}}};
\node (enc) [enclosure, color = blue, fill = blue!5, below of=call, yshift=-0.85cm] {\ };
\node (stat1) [process, color = blue, fill = blue!15, below of=call] {\code{<statement A>}};
\node (sideeff) [process, color = black, fill = yellow!20, right of=stat2, xshift=3cm] {\textsl{\textcolor{blue}{side effect}}};
\node (stat2) [process, color = blue, fill = blue!15, below of=stat1] {\code{<statement B>}};
\node (return) [startstop, below of=stat2] {\textsl{\textcolor{blue}{returned  value} $\to$ caller}};
\draw [arrow, color = blue] (call) -- (stat1);
\draw [arrow, color = blue] (stat1) -- (stat2);
\draw [arrow, color = blue] (stat2) -- (sideeff);
\draw [arrow, color = blue] (stat2) -- (return);
\end{tikzpicture}
\end{small}
  \caption[Diagram of function with side effects]{Diagram of function as a compound code statement receiving its input as arguments passed to its formal parameters and returning an object or value to the statement from where it was called or run. The body of the function is represented by the box filled in blue, while the side effect of the code in the function directly outside is represented by the box filled in yellow.}\label{fig:function:side:effect:diagram}
\end{figure}

When a function has a side effect, the caller is no longer in full control (Figure \ref{fig:function:side:effect:diagram}). Side effects can be actions that do not alter any object in the calling code, like when a call to \Rfunction{print()} displays text or numbers. Side effects can also be an assignment that modifies an object in the caller's environment, such as assigning a new value to a variable in the caller's environment, i.e., ``outside the function''.

A function can return only one object, so when multiple results are produced they need to be collected into a single object. In many cases, lists are used to collect all the values to be returned into one \Rlang object. For example, model fit functions like \code{lm()}, discussed in section \ref{sec:stat:LM} on page \pageref{sec:stat:LM}, return lists with multiple heterogeneous members, plus ancillary information stored in several attributes. In the case of \Rfunction{lm()} the returned object's class is \Rclass{lm}, and its mode is \Rclass{list}.

\begin{playground}
When function \Rcontrol{return()} is called within a function, the flow of execution within the function stops and the argument passed to \Rcontrol{return()} is the value returned by the function call. In contrast, if function \Rcontrol{return()} is not explicitly called, the value returned by the function call is that returned by the last statement \emph{executed} within the body of the function. Run these examples, and your own variations.

\label{chunck:print:funs}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{FN1} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)} \hlkwd{print}\hlstd{(}\hlstr{"prn"}\hlstd{)}
\hlkwd{FN1}\hlstd{(}\hlstr{"arg"}\hlstd{)}
\hlstd{FN2} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{print}\hlstd{(}\hlstr{"prn"}\hlstd{)}
                   \hlkwd{return}\hlstd{(x)\}}
\hlkwd{FN2}\hlstd{(}\hlstr{"arg"}\hlstd{)}
\hlstd{FN3} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{(x)}
                   \hlkwd{print}\hlstd{(}\hlstr{"prn"}\hlstd{)\}}
\hlkwd{FN3}\hlstd{(}\hlstr{"arg"}\hlstd{)}
\hlstd{FN4} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{()}
                   \hlkwd{print}\hlstd{(}\hlstr{"prn"}\hlstd{)\}}
\hlkwd{FN4}\hlstd{(}\hlstr{"arg"}\hlstd{)}
\hlstd{FN5} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{return}\hlstd{(}\hlkwd{print}\hlstd{(x))}
                   \hlkwd{print}\hlstd{(}\hlstr{"prn"}\hlstd{)\}}
\hlkwd{FN5}\hlstd{(}\hlstr{"arg"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

In base \Rlang, arguments\index{functions!arguments} to functions are passed by copy. This is something important to remember. If code in a function's body modifies the value of a parameter (the placeholder for an argument), its value outside the function is not affected, e.g., if the argument passed was a variable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fn2} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{x} \hlkwb{<-} \hlnum{99}\hlstd{\}}
\hlstd{a} \hlkwb{<-} \hlnum{1}
\hlkwd{fn2}\hlstd{(a)}
\hlstd{a}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
In some other computer languages, arguments can be passed by reference, meaning that assignments to a formal parameter within the body of the function are back-referenced to the argument and modify it. It is possible to imitate such behaviour in \Rlang using some language trickery and consequently, occasionally functions in \Rlang use this approach.
\end{warningbox}

Functions have their own \emph{scope}. Any new variables created by normal assignment within the body of a function are visible only within the body of the function and are destroyed when the function returns from the call. In normal use, functions in \Rlang do not affect their environment through side effects.

\begin{warningbox}
Functions can be called without giving them a name. This is common when the function is simple and called only once. Anonymous functions are frequently used together with \emph{apply functions}, as a definition passed directly as an argument to parameter \code{FUN} (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{(}\hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{y}\hlstd{)\{x} \hlopt{*} \hlstd{y\})(}\hlkwc{x} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 12
\end{verbatim}
\end{kframe}
\end{knitrout}

A new terse notation for defining functions was introduced in \Rlang 4.1.0, with \Rfunction{\textbackslash()} as a synonym of \Rfunction{function()}. This is intended to make code concise, and especially useful for anonymous or lambda functions. However, I think this notation should be used sparingly, and possibly only at the \Rlang console. I have not used \Rfunction{\textbackslash()} in code examples in the book, except for the one below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{(\textbackslash{}(}\hlkwc{x}\hlstd{,} \hlkwc{y}\hlstd{)\{x} \hlopt{*} \hlstd{y\})(}\hlkwc{x} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 12
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{warningbox}

\subsection{Scope of names}
\index{names and scoping}\index{scoping rules}\index{namespaces}
Scoping in \Rlang is implemented using \emph{environments} and \emph{name spaces}. We can think of environments as having a boundary with asymmetric visibility. The code within a function runs in its own environment, in isolation from the calling environment in relation to assignments, but the values stored in objects in the calling environment can be retrieved. This protects from unintentional side effects by making difficult to overwrite object definitions in the calling environment. It is possible to override this protection with operator \Roperator{<<-} or with function \Rfunction{assign()}. When used, assignment as side effects, can make the code much more difficult to read and debug, so its best to avoid them.

\begin{warningbox}
  Parameters and local variables are not read-only, they behave like normal variables within the body of the function. However, assignments made using the operator \Roperator{<-}, only affect a local copy that is destroyed when the function returns.
\end{warningbox}

The visibility of names is determined by the \emph{scoping rules} of a language. The clearest, but not the only situation when scoping rules matter, is when objects with the same name coexist. In such a situation, one will be accessible by its unqualified name and the other hidden but possibly accessible by qualifying the name with the namespace where it is defined.

As the \Rlang language has few reserved words for which no redefinition is allowed, we should take care not to accidentally reuse names that are part of the language. For example, \code{pi} is a constant defined in \Rlang with the value of the mathematical constant $\pi$. If we use the same name for one of our variables, the original definition is hidden and can no longer be normally accessed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pi}
\end{alltt}
\begin{verbatim}
## [1] 3.141593
\end{verbatim}
\begin{alltt}
\hlstd{pi} \hlkwb{<-} \hlstr{"apple pie"}
\hlstd{pi}
\end{alltt}
\begin{verbatim}
## [1] "apple pie"
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(pi)}
\hlstd{pi}
\end{alltt}
\begin{verbatim}
## [1] 3.141593
\end{verbatim}
\begin{alltt}
\hlkwd{exists}\hlstd{(}\hlstr{"pi"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

In the example above, the two variables are not defined in the same scope. In the example below, we assign a new value to a variable we have earlier created within the same scope, and consequently the second assignment overwrites, rather than hides, the existing definition.\qRscoping{exists()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.pie} \hlkwb{<-} \hlstr{"raspberry pie"}
\hlstd{my.pie}
\end{alltt}
\begin{verbatim}
## [1] "raspberry pie"
\end{verbatim}
\begin{alltt}
\hlstd{my.pie} \hlkwb{<-} \hlstr{"apple pie"}
\hlstd{my.pie}
\end{alltt}
\begin{verbatim}
## [1] "apple pie"
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(my.pie)}
\hlkwd{exists}\hlstd{(}\hlstr{"my.pie"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Name spaces play an important role in avoiding name clashes when contributed packages are attached (see section \ref{sec:packages:work} on page \pageref{sec:packages:work}).

\begin{explainbox}
Environments can be explicitly created with function \Rfunction{environment()}. However, \Rfunction{environment()} is rarely used in scripts while it can be useful within packages.
\end{explainbox}

\subsection{Ordinary functions}\label{sec:functions:sem}\label{sec:ordinary:functions}
\index{functions!defining new}

After the toy examples above, we will define a small but useful function: a function for calculating the standard error of the mean from a numeric vector. The standard error is given by $S_{\hat{x}} = \sqrt{S^2 / n}$. We can translate this into the definition of an \Rlang function called \code{SEM}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{SEM} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x)} \hlopt{/} \hlkwd{length}\hlstd{(x))\}}
\end{alltt}
\end{kframe}
\end{knitrout}

As a test, we call \Rfunction{SEM()} with both \code{a} and \code{a.na} as argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlopt{-}\hlnum{5}\hlstd{)}
\hlstd{a.na} \hlkwb{<-} \hlkwd{c}\hlstd{(a,} \hlnum{NA}\hlstd{)}
\hlkwd{SEM}\hlstd{(}\hlkwc{x} \hlstd{= a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{SEM}\hlstd{(}\hlkwc{x} \hlstd{= a.na)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\end{kframe}
\end{knitrout}

Our function \code{SEM(a)} never returns a wrong answer because \code{NA} values in its input always result in \code{NA} being returned. The downside is that unlike \Rlang's functions such as \code{var()}, \Rfunction{SEM()} does not support omitting \code{NA} values.

Adding \code{na.rm} as a second parameter and passing the argument it receives to the call to \Rfunction{var()} within the body of \code{SEM()} is not enough. To avoid returning wrong values, \code{NA} values should be also removed before counting the number of observations with \code{length()}. A good alternative is to define the function as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sem} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{na.rm} \hlstd{=} \hlnum{FALSE}\hlstd{) \{}
 \hlkwa{if} \hlstd{(na.rm) \{}
   \hlstd{x} \hlkwb{<-} \hlkwd{na.omit}\hlstd{(x)}
 \hlstd{\}}
 \hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(x)}\hlopt{/}\hlkwd{length}\hlstd{(x))}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sem}\hlstd{(}\hlkwc{x} \hlstd{= a)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\begin{alltt}
\hlkwd{sem}\hlstd{(}\hlkwc{x} \hlstd{= a.na)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{sem}\hlstd{(}\hlkwc{x} \hlstd{= a.na,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.796988
\end{verbatim}
\end{kframe}
\end{knitrout}

\Rlang does not provide a function for standard error, so the function above is generally useful. Its user interface is consistent with that of functionally similar existing functions. We have added a new word to the \Rlang vocabulary available to us.

In the definition of \code{sem()} we set a default argument for parameter \code{na.omit} which is used unless the user explicitly passes an argument to this parameter.

%In addition if names of the parameters are supplied arguments can be passed in any order. If parameter names are not supplied arguments are matched to parameters based on their position. Once one parameter name is given, all later arguments need also to be explicitly named.

%We can assign to a variable defined `outside' a function with operator \code{<<-} but the usual recommendation is to avoid its use. This type of effects of calling a function are frequently called `side-effects'.

\begin{playground}
Define your own function to calculate the mean in a similar way as \Rfunction{SEM()} was defined above. Hint: function \Rfunction{sum()} could be of help.
\end{playground}

Within an expression, a function name followed by parentheses is interpreted as a call to the function, while the bare name of a function, returns its definition (similarly to any other \Rlang object). If the name is entered as a statement at the \Rpgrm console, its value is printed.

We first print (implicitly) the definition of our function from earlier in this section.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sem}
\end{alltt}
\begin{verbatim}
## function(x, na.rm = FALSE) {
##  if (na.rm) {
##    x <- na.omit(x)
##  }
##  sqrt(var(x)/length(x))
## }
## <bytecode: 0x000002b1bd2ae848>
\end{verbatim}
\end{kframe}
\end{knitrout}

Next, we print the definition of \Rlang's standard deviation function \code{sd()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sd}
\end{alltt}
\begin{verbatim}
## function (x, na.rm = FALSE) 
## sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), 
##     na.rm = na.rm))
## <bytecode: 0x000002b1b5b0a400>
## <environment: namespace:stats>
\end{verbatim}
\end{kframe}
\end{knitrout}

As can be seen at the end of the printouts, these functions written in the \Rlang language have been byte-compiled so that they execute faster. We can also see that the definition of \code{sd()} resides in \code{namespace:stats} because it has been attached from package \pkgname{stats}.

Functions that are part of the \Rlang language, but that are not coded using the \Rlang language, are called primitives and their full definition cannot be accessed through their name (c.f., \code{sem()} defined above and \code{sd}, with \code{list()} below).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{list}
\end{alltt}
\begin{verbatim}
## function (...)  .Primitive("list")
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Operators}\label{sec:operator:functions}
\index{operators!defining new}

Operators are functions that use a different syntax for being called. If their name is enclosed in back ticks they can be called as ordinary functions. Binary operators like \code{+} have two formal parameters, and unary operators like unary \code{-} have only one formal parameter. The parameters of many binary \Rlang operators are named \code{e1} and \code{e2}. This is just a convention, not enforced by the \Rlang language.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{1} \hlopt{/} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\begin{alltt}
\hlkwd{`/`}\hlstd{(}\hlnum{1} \hlstd{,} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\begin{alltt}
\hlkwd{`/`}\hlstd{(}\hlkwc{e1} \hlstd{=} \hlnum{1} \hlstd{,} \hlkwc{e2} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\Kern{1}{An important consequence of the possibility of calling operators using ordinary syntax is that operators can be used as arguments to \emph{apply} functions in the same way as ordinary functions. When passing operator names as arguments to \emph{apply} functions, we only need to enclose them in back ticks (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}).}

The name by itself and enclosed in back ticks allows us to access the definition of an operator.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{`/`}
\end{alltt}
\begin{verbatim}
## function (e1, e2)  .Primitive("/")
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
\textbf{Defining a new operator.} We will define a binary operator (taking two arguments) that subtracts from the numbers in a vector the mean of another vector. First, we need a suitable name, but we have less freedom as names of user-defined operators must be enclosed in percent signs. We will use \code{\%-mean\%} and as with any \emph{special name}, we need to enclose it in quotation marks for the assignment.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstr{"%-mean%"} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{e1}\hlstd{,} \hlkwc{e2}\hlstd{) \{}
  \hlstd{e1} \hlopt{-} \hlkwd{mean}\hlstd{(e2)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

We can then use our new operator in a example.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlnum{10}\hlopt{:}\hlnum{15} \hlopt{%-mean%} \hlnum{1}\hlopt{:}\hlnum{20}
\end{alltt}
\begin{verbatim}
## [1] -0.5  0.5  1.5  2.5  3.5  4.5
\end{verbatim}
\end{kframe}
\end{knitrout}

To print the definition, we enclose the name of our new operator in back ticks---i.e., we \emph{back quote} the special name.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{`%-mean%`}
\end{alltt}
\begin{verbatim}
## function(e1, e2) {
##   e1 - mean(e2)
## }
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\section{Objects, Classes and Methods}\label{sec:script:objects:classes:methods}\label{sec:methods}
\index{objects}\index{classes}\index{methods}\index{object-oriented programming}
\index{S3 class system}\index{classes!S3 class system}\index{methods!S3 class system}
New classes are normally defined within packages rather than in user scripts. To be really useful implementing a new class involves not only defining a class but also a set of specialised functions or \emph{methods} that implement operations on objects belonging to the new class. Nevertheless, an understanding of how classes work is important even if only very occasionally a user will define a new method for an existing class within a script.

Classes are abstractions, but abstractions describing the shared properties of ``types'' or groups of similar objects. In this sense, classes are abstractions of ``actors'', they are like ``nouns'' in natural language. What we obtain with classes is the possibility of defining multiple versions of functions (or \emph{methods}) sharing the same name but tailored to operate on objects belonging to different classes. We have already been using methods with multiple \emph{specialisations} throughout the book, for example, \code{plot()} and \code{summary()}.

We start with a quotation from \citebooktitle{Burns1998} \autocite[][, page 13]{Burns1998}.
\begin{quotation}
The idea of object-oriented programming is simple, but carries a lot of weight.
Here's the whole thing: if you told a group of people ``dress for work,'' then
you would expect each to put on clothes appropriate for that individual's job.
Likewise it is possible for S[R] objects to get dressed appropriately depending on
what class of object they are.
\end{quotation}

We say that specific methods are \emph{dispatched} based on the class of the argument passed. This, together with the loose type checks of \Rlang, allows writing code that functions as expected on different types of objects, e.g., character and numeric vectors.

\Rlang has good support for the object-oriented programming paradigm, but as a system that has evolved over the years, currently \Rlang supports multiple approaches. The still most popular approach is called S3, and a more recent and powerful approach, with slower performance, is called S4. The general idea is that a name like ``plot'' can be used as a generic name and that the specific version of \Rfunction{plot()} called depends on the arguments of the call. Using computing terms we could say that the \emph{generic} of \Rfunction{plot()} dispatches the original call to different specific versions of \Rfunction{plot()} based on the class of the arguments passed. S3 generic functions dispatch, by default, based only on the argument passed to a single parameter, the first one. S4 generic functions can dispatch the call based on the arguments passed to more than one parameter and the structure of the objects of a given class is known to the interpreter. In S3 functions, the specialisations of a generic are recognised/identified only by their name. And the class of an object by a character string stored as an attribute to the object (see section \ref{sec:calc:attributes} on page \pageref{sec:calc:attributes} about attributes).

We first explore one of the methods already available in \Rlang. The definition of \code{mean} shows that it is the generic for a method.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mean}
\end{alltt}
\begin{verbatim}
## function (x, ...) 
## UseMethod("mean")
## <bytecode: 0x000002b1b1e2cdc0>
## <environment: namespace:base>
\end{verbatim}
\end{kframe}
\end{knitrout}

We can find out which specialisations of a method are available in the current search path using \Rfunction{methods()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{methods}\hlstd{(mean)}
\end{alltt}
\begin{verbatim}
##  [1] mean.Date        mean.default     mean.difftime    mean.POSIXct    
##  [5] mean.POSIXlt     mean.quosure*    mean.vctrs_vctr* mean.yearmon*   
##  [9] mean.yearqtr*    mean.zoo*       
## see '?methods' for accessing help and source code
\end{verbatim}
\end{kframe}
\end{knitrout}

We can also use \Rfunction{methods()} to query all methods, including operators, defined for objects of a given class.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{methods}\hlstd{(}\hlkwc{class} \hlstd{=} \hlstr{"list"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] all.equal     as.data.frame coerce        na.contiguous Ops          
## [6] relist        sew           type.convert  within       
## see '?methods' for accessing help and source code
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
S3 class information is stored as a character vector in an attribute named \code{"class"}. The most basic approach to the construction (= creation) of an object of a new S3 class, is to add the new class name to the \code{class} attribute of the object. As the implied class hierarchy is given by the order of the members of the character vector, the name of the new class must be added at the head of the vector. Even though this step can be done as shown here, in practice this step would normally take place within a \emph{constructor} function and the new class, if defined within a package, would need to be registered. We show here this bare-bones example only to demonstrate how S3 classes are implemented in \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{a} \hlkwb{<-} \hlnum{123}
\hlkwd{class}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(a)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"myclass"}\hlstd{,} \hlkwd{class}\hlstd{(a))}
\hlkwd{class}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] "myclass" "numeric"
\end{verbatim}
\end{kframe}
\end{knitrout}

Now we create a print method specific to \code{"myclass"} objects. Internally we are using function \Rfunction{sprintf()} and for the format template to work we need to pass a \code{numeric} value as an argument---i.e., obviously \Rfunction{sprintf()} does not ``know'' how to handle objects of the class we have just created!

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{print.myclass} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}
    \hlkwd{sprintf}\hlstd{(}\hlstr{"[myclass] %.0f"}\hlstd{,} \hlkwd{as.numeric}\hlstd{(x))}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

Once a specialised method exists for a class, it will be used for objects of this class.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] "[myclass] 123"
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlkwd{as.numeric}\hlstd{(a))}
\end{alltt}
\begin{verbatim}
## [1] 123
\end{verbatim}
\end{kframe}
\end{knitrout}

Adding the name \code{"derivclass"} to the head of the \code{class} character vector, makes object \code{b} a member of both classes, \code{"myclass"} and \code{"derivclass"}, where \code{"derivclass"} is derived from \code{"myclass"}. As \code{"derivclass"} is at position \code{1}, it is for this object its \emph{most derived class}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{b} \hlkwb{<-} \hlnum{456}
\hlkwd{class}\hlstd{(b)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"derivclass"}\hlstd{,} \hlkwd{class}\hlstd{(a))}
\end{alltt}
\end{kframe}
\end{knitrout}

A specialised \code{print()} method is not available for \code{"derivclass"}, the method for \code{"myclass"}, the next class name along the vector, is called.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(b)}
\end{alltt}
\begin{verbatim}
## [1] "[myclass] 456"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlkwd{as.numeric}\hlstd{(b))}
\end{alltt}
\begin{verbatim}
## [1] 456
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{warningbox}
 The S3 class system is ``lightweight'' in that it adds very little additional computation load, but it is rather ``fragile'' in that most of the responsibility for consistency and correctness of the design---e.g., not messing up dispatch by redefining functions or loading a package exporting functions with the same name, etc., is not checked by the \Rlang interpreter.
\end{warningbox}

%Defining a new S3 generic\index{generic method!S3 class system} is also simple. A generic method and a default method need to be created.
%
%<<explain-object-classes-04>>=
%my_print <- function (x, ...) {
%   UseMethod("my_print", x)
% }
%
%my_print.default <- function(x, ...) {
%   print(class(x))
%   print(x, ...)
%}
%@
%
%<<explain-object-classes-05>>=
%my_print(123)
%my_print("abc")
%@
%
%Up to now, \Rfunction{my\_print()}, has no specialisation. We now write one for data frames.
%
%<<explain-object-classes-06>>=
%my_print.data.frame <- function(x, rows = 1:5, ...) {
%   print(x[rows, ], ...)
%   invisible(x)
%}
%@
%
%We add the second statement so that the function invisibly returns the whole data frame, rather than the lines printed. We now do a quick test of the function.
%
%<<explain-object-classes-07>>=
%my_print(cars)
%@
%
%<<explain-object-classes-07a>>=
%my_print(cars, 8:10)
%@
%
%<<explain-object-classes-07b>>=
%b <- my_print(cars)
%str(b)
%nrow(b) == nrow(cars) # was the whole data frame returned?
%@
%
%%\begin{playground}
%%1) What would be the most concise way of defining a \code{my\_print()} specialization for \code{matrix}? Write one, and test it.
%%2) How would you modify the code of your \code{my\_print.matrix()} so that also the columns to print can be selected?
%%\end{playground}
%%
%\end{explainbox}

\section{Packages}\label{sec:script:packages}

\subsection{Sharing of \Rlang-language extensions}
\index{extensions to R}
The most elegant way of adding new features or capabilities to \Rlang is through packages. A package can contain any, several or all of \Rlang function and operator definitions, data objects, classes, and their methods, plus the corresponding documentation. Some packages available through \CRAN contain only one or two \Rlang objects while others contain hundreds of them. After loading and attaching a package, the objects that the package exports can be used as if they were part \Rlang itself.

Packages are, without doubt, the best mechanism for sharing extensions to \Rlang. However, in most situations, packages are also very useful for managing code that will be reused by a single person over time. \Rlang packages have strict rules about their contents, file structure, and documentation, which makes it possible among other things for the package documentation to be merged into \Rpgrm's help system when a package is loaded. With a few exceptions, packages can be written so that they will work on any computer where \Rpgrm runs.

\begin{explainbox}
In a ``source package'', the code written in \Rlang, and possibly in other programming languages, is contained in text files that are compressed together into a single archive file. In a ``binary package'' the source code is already processed into a form suitable for faster installation. Binary package files are specific to each major version of \Rlang, operating system, and computer architecture. In addition to being slower, package installation from sources can requires additional software, such as compilers. A compiler translates the text representation of a computer program written in \Clang, \Cpplang, \langname{FORTRAN}, etc., into machine code, i.e., instructions for the computer hardware. \Rlang code is compiled into instructions for a virtual machine, part of \Rlang, that does the final translation into machine code at runtime.
\end{explainbox}

For distribution, a single compressed archive file is used for aech package. Packages can be shared as source- or binary-code files, sent for example through e-mail. However, the largest public repository of \Rpgrm packages is called \CRAN (\url{https://cran.r-project.org/}), an acronym for Comprehensive R Archive Network. Packages available through \CRAN are guaranteed to work, in the sense of not failing any tests built into the packages and not crashing or aborting prematurely. They are tested daily, as they may depend on other packages whose code will change when updated. The number of packages available through \CRAN at the time of printing (2024-02-17) was \ensuremath{2.04\times 10^{4}}.

A key repository for bioinformatics with \Rlang is Bioconductor\index{Bioconductor} (\url{https://www.bioconductor.org/}), containing packages that pass strict quality tests, adding an additional 3\,400 packages. rOpenScience\index{rOpenScience} has established guidelines and a system for code peer review for \Rlang packages. These peer-reviewed packages are available through \CRAN or other repositories and listed at the rOpenScience website (\url{https://ropensci.org/}). Occasionally, one may have, or want, to install packages or updates that are not yet in \CRAN, either from the R Universe (\url{https://r-universe.dev/}) repositories, or from Git repositories (e.g., from GitHub).

A good way of learning how the extensions provided by a package work, is to experiment with them. When using a function we are not yet familiar with, looking at its help to check all its features expands our ``toolbox''. While documentation of exported objects is enforced, many packages include, in addition, comprehensive user guides or articles as \emph{vignettes}. It is not unusual to decide which package to use from a set of alternatives based its documentation. In the case of packages adding extensive new functionality, they may be documented in depth in a book. Well-known examples are \citebooktitle{Pinheiro2000} \autocite{Pinheiro2000} and \citebooktitle{Wickham2016} \autocite{Wickham2016}.

\subsection{Download, installation and use}\label{sec:packages:install}

\index{packages!using}
In \Rlang speak, ``library'' is the location where packages are installed. Packages are sets of functions, and data, specific for some particular purpose, that can be loaded into an \Rlang session to make them available so that they can be used in the same way as built-in \Rlang functions and data. Function \Rfunction{library()} is used to load and attach packages that are already installed in the local \Rlang library. In contrast, function \Rfunction{install.packages()} is used to install packages.

\begin{warningbox}
The instructions below assume that the user has access to repositories on the internet and enough user rights to install packages. This is rarely the case in organisations using strict security protocols. In such cases, the organisation may keep a mirror of \CRAN in the intranet. The local/user's private \Rpgrm library can be kept in a folder where the user has writing and reading rights.
\end{warningbox}

\begin{faqbox}{How to install or update a package from CRAN?}
\CRAN is the default repository for \Rlang packages. If you use \RStudio or another IDE as a front end on any operating system or \pgrmname{RGUI} under \pgrmname{MS-Windows}, installation and updates can be done through a menu or GUI button. These menus use calls to \Rfunction{install.packages()} and \Rfunction{update.packages()} behind the scenes.

Alternatively, at the \Rpgrm command line, or in a script, \Rfunction{install.packages()} can be called with the name of the package as an argument. For example, to install package \pkgname{learnrbook} one can use

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"learnrbook"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\noindent
and to update already installed packages

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{update.packages}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{faqbox}

\begin{faqbox}{How to install or update a package from GitHub?}
Package \pkgname{remotes} makes it possible to install packages directly from \GitHub, \Bitbucket and other repositories based on \pgrmname{Git}. The code in the next chunk (not run here) can be used to install the latest, possibly, still under development, version of package \pkgname{learnrbook}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{remotes}\hlopt{::}\hlkwd{install_github}\hlstd{(}\hlstr{"aphalo/learnrbook-pkg"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{faqbox}

\begin{explainbox}
Function \Rfunction{pkg\_install()} from \pkgname{pak} can install packages, both from CRAN and Bioconductor repositories, and from \pgrmname{Git} repositories. The same function can be used to update specific already installed packages and dependencies.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pak}\hlopt{::}\hlkwd{pkg_install}\hlstd{(}\hlstr{"learnrbook"}\hlstd{)} \hlcom{# from CRAN}
\hlstd{pak}\hlopt{::}\hlkwd{pkg_install}\hlstd{(}\hlstr{"aphalo/learnrbook-pkg"}\hlstd{)} \hlcom{# from GitHub}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

\Rpgrm packages can be installed either from sources, or from already built ``binaries''. Installing from sources, depending on the package, may require additional software to be available. This is because some \Rlang packages contain source code in other languages such as \Clang, \Cpplang or \langname{FORTRAN} that needs to be compiled into machine code during installation. Under \pgrmname{MS-Windows}, the needed shell, commands, and compilers are not available as part of the operating system. Installing them is not difficult as they are available prepackaged in an installer under the name \pgrmname{RTools} (available from \CRAN). \pgrmnameTwo{\hologo{MiKTeX}}{MiKTeX}) is usually needed to build the PDF of the package's manual.

Under \pgrmname{MS-Windows}, it is easier to install packages from binary \texttt{.zip} files than from \texttt{.tar.gz} source files. For \pgrmname{OS X} (Apple Mac) the situation is similar, with binaries available both for Intel and ARM (M1, M2 series) processors. Most, but not all, Linux distributions include in the default setup the tools needed for installation of \Rlang packages. Under Linux it is rather common to install packages from sources, although package binaries have recently become more easily available.

If the tools are available, packages can be easily installed from sources from within \RStudio. However, binaries are for most packages also readily available. In \CRAN, the binary for a new version of a package becomes available with a delay of one or two days compared to the source. For packages that need compilation, the installation from sources takes more time than installation from binaries.

\begin{advplayground}
Use \code{help} to look up the help page for \Rfunction{install.packages()}, and explore how to control whether the package is installed from a source or a binary file. Also explore, how to install a package from a file in a local disk instead of from a repository like \CRAN.
\end{advplayground}

Frequently the README file of a package includes instructions on how to install it from \CRAN or another online repository. Exceptionally, packages may require additionally the installation of software outside \Rpgrm before their installation and/or use. When present, these rather exceptional requirements are always listed in the DESCRIPTION under \code{SystemRequirements:} and explained in more detail in the README file. In \CRAN, each package has a home web page that can be easily found if one knows the name of the package, e.g., \url{https://CRAN.R-project.org/package=learnrbook}. Nowadays, it is common for the help for a package being also available as a web site, e.g., \url{https://docs.r4photobiology.info/learnrbook/}.

\begin{faqbox}{How to change the repository used to install packages?}
Function \Rfunction{setRepositories()} can be used to enable other repositories in addition or instead of \CRAN during an \Rpgrm session. In recent versions of \Rpgrm, the default list of repositories is taken from \Rlang option \code{"repos"} if defined. Consult \code{help("setRepositories")} for the details.

Alternatively, one can use function \Rfunction{pkg\_install()} from package \pkgname{pak} as this function attempts to automatically set the correct repository based on the name of the package.
\end{faqbox}

\begin{faqbox}{How to use an installed package?}
To use the functions and other objects defined in a package, the package must first be loaded, and for the names of these objects to be visible in the user's workspace, the package needs to be attached. Function \Rfunction{library()} loads and attaches one package at a time. For example, to load and attach package \pkgname{learnrbook} we use.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(}\hlstr{"learnrbook"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{faqbox}

\begin{faqbox}{How to find the currently installed version of a package?}
Function \Rfunction{packageVersion} returns the version as an object of class \code{"package\_version"} that can not only be printed, but also meaningfully compared, e.g., to test for a minimum version requirement.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{packageVersion}\hlstd{(}\hlkwc{pkg}\hlstd{=}\hlstr{"learnrbook"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] '1.0.2.1'
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{faqbox}

As packages are contributed by independent authors, they should be cited in addition to citing \Rpgrm itself when they are used to obtain results or plots included in publications. \Rlang function \Rfunction{citation()} when called with the name of a package as its argument provides the reference that should be cited for the package, and without an explicit argument, the reference to cite for the version of \Rlang in use as shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{citation}\hlstd{()}
\end{alltt}
\begin{verbatim}
## To cite R in publications use:
## 
##   R Core Team (2024). _R: A Language and Environment for Statistical
##   Computing_. R Foundation for Statistical Computing, Vienna, Austria.
##   <https://www.R-project.org/>.
## 
## A BibTeX entry for LaTeX users is
## 
##   @Manual{,
##     title = {R: A Language and Environment for Statistical Computing},
##     author = {{R Core Team}},
##     organization = {R Foundation for Statistical Computing},
##     address = {Vienna, Austria},
##     year = {2024},
##     url = {https://www.R-project.org/},
##   }
## 
## We have invested a lot of time and effort in creating R, please cite it
## when using it for data analysis. See also 'citation("pkgname")' for
## citing R packages.
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  Look at the help page for function \code{citation()} for a discussion of why it is important that users cite \Rpgrm and packages when using them.
\end{playground}

\begin{warningbox}
Conflicts among packages can easily arise, for example, when they use the same names for objects or functions. These are reported when the packages are attached (see section \ref{sec:packages:work} on page \pageref{sec:packages:work} for a workaround). In addition, many packages use functions defined in packages in the \Rlang distribution itself or other independently developed packages by importing them. Updates to depended-upon packages can ``break'' (make non-functional) the dependent packages or parts of them. The rigourous testing by \CRAN detects such problems in most cases when package revisions are submitted, forcing package maintainers to fix problems before distribution through \CRAN is possible. However, if you use other repositories, I recommend that you make sure that revised (especially if under development) versions do work with your own code, before their use in ``production'' (important) data analyses.
\end{warningbox}

\subsection{Finding suitable packages}

Due to the large number of contributed \Rlang packages, it can sometimes be difficult to find a suitable package for a task at hand. It is good to first check if the necessary capability is already built into base \Rlang. Base \Rlang plus the recommended packages (installed when \Rlang is installed) cover a lot of ground. Analysing data using almost any of the more common statistical methods does not require the use of contributed packages. Sometimes, contributed packages duplicate or extend the functionality in base \Rlang. When one considers the use of novel or specialised types of data analysis, the use of contributed packages can be unavoidable. Even in such cases, it is not unusual to have alternatives to choose from within the available contributed packages. Sometimes groups or suites of packages are designed to work well together.

The \CRAN repository has a very broad scope and includes a section called ``views''. \Rlang views are web pages providing annotated lists of packages frequently used within a given field of research, engineering, or specific applications. These views are maintained by different expert editors. The \Rlang views can be found at \url{https://cran.r-project.org/web/views/}.

The Bioconductor repository specialises in bioinformatics with \Rlang. It also has a section with ``views'' and within it, descriptions of different data analysis workflows. The workflows are especially good as they reveal which sets of packages work well together. These views can be found at \url{https://www.bioconductor.org/packages/release/BiocViews.html}.

\textsf{rOpenSci} \autocite{Ram2019} fosters a culture that values open and reproducible research using shared data and reusable software. One aspect of this is making possible peer-review of \Rlang packages. \textsf{rOpenSci} does not keep a separate package repository for the peer-reviewed packages, they keep an index at \url{https://ropensci.org/packages/}. The packages included have become more diverse, but initially the main focus was on facilitating access to open data sources.

The \CRAN repository keeps an archive of earlier versions of packages, on an individual package basis. This is also important for long-term reproducibility.

\subsection{How packages work}\label{sec:packages:work}

\Rlang packages define all objects within a \emph{namespace} with the same name as the package itself. Loading and attaching a package with \Rfunction{library()} makes visible only the exported objects. Attaching a package adds these objects to the search path so that they can be accessed without prepending the name of the namespace. Most packages do not export all the functions and objects defined in their code; some are kept internal, in most cases, to avoid making a commitment about their availability in future versions, which could constrain further development.

\begin{explainbox}
Package namespaces can be detached and also unloaded with function \Rscoping{detach()} using a slightly different notation for the argument from that which we described for data frames in section \ref{sec:calc:df:with} on page \pageref{sec:calc:df:with}. This is very seldom needed, but one case I have come across is a package that redefines a generic function of a method of a package it imports, thus preventing the normal use of a third package that depends on the original definition of the generic.
\end{explainbox}

When we reuse a name defined in a package, its definition in the package does not get overwritten, but instead, only hidden. These hidden objects remain accessible using the name \emph{qualified} by prepending the name of the package followed by two colons, e.g., \code{base:mean()}.

If two packages define objects with the same name, then which one is visible depends on the order in which the packages were attached with \Rfunction{library()}. To avoid confusion in such cases, in scripts it is best to use the qualified names for calling objects defined with the same name in two packages. Using the qualified name for an object from an already attached package, is inconsequential for its interpretation by \Rpgrm, but can enhance the readability of the code.

\begin{warningbox}
If one uses a qualified name for an object but does not attach the package with a call to \Rfunction{library()}, the package is only loaded. In other words, the names of the exported objects are not added to the search pass, but the code defining them is retrieved and available using qualified names.
\end{warningbox}

Some functions that are part of \Rlang are collected into packages grouped by category: \pkgname{base}, \pkgname{stats}, \pkgname{datasets}, etc., and can be called when needed using qualified names.  We can find out the search order by calling \Rfunction{search()}, with the search starting at the \code{".GlobalEnv"} for statements evaluated at the \Rlang command line.

\begin{playground}
Namespaces isolate the names defined within them from those in other namespaces. This helps prevent name clashes, and makes it possible to access objects even when they are ``hidden'' by a different object with the same name.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(cars)}
\hlkwd{head}\hlstd{(cars,} \hlnum{3}\hlstd{)}
\hlkwd{getAnywhere}\hlstd{(}\hlstr{"cars"}\hlstd{)}\hlopt{$}\hlstd{where} \hlcom{# defined in package}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cars} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\hlkwd{class}\hlstd{(cars)}
\hlkwd{head}\hlstd{(cars,} \hlnum{3}\hlstd{)} \hlcom{# prints 'cars' defined in the global environment}
\hlkwd{rm}\hlstd{(cars)} \hlcom{# clean up}
\hlkwd{head}\hlstd{(cars,} \hlnum{3}\hlstd{)}
\hlkwd{getAnywhere}\hlstd{(}\hlstr{"cars"}\hlstd{)}\hlopt{$}\hlstd{where} \hlcom{# the first visible definition is in the global environemnt}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

\begin{warningbox}
In the playground above, I used a data frame object, but the same mechanisms apply to all \Rlang objects including functions. The situation when one of the definitions is a function and the other is not, is slightly different in that a call using parenthesis notation will distinguish between a function and an object of the same name that is not a function. Relying on this distinction is anyway very confusing and, thus, a bad idea.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mean}
\end{alltt}
\begin{verbatim}
## function (x, ...) 
## UseMethod("mean")
## <bytecode: 0x000002b1b1e2cdc0>
## <environment: namespace:base>
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mean} \hlkwb{<-} \hlkwd{mean}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{)}
\hlstd{mean}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{mean}\hlstd{(}\hlnum{8}\hlopt{:}\hlnum{9}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 8.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{getAnywhere}\hlstd{(}\hlstr{"mean"}\hlstd{)}\hlopt{$}\hlstd{where}
\end{alltt}
\begin{verbatim}
## [1] ".GlobalEnv"     "package:base"   "namespace:base"
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(mean)}
\hlkwd{getAnywhere}\hlstd{(}\hlstr{"mean"}\hlstd{)}\hlopt{$}\hlstd{where}
\end{alltt}
\begin{verbatim}
## [1] "package:base"   "namespace:base"
\end{verbatim}
\end{kframe}
\end{knitrout}

In this last example, \code{rm(mean)} removed the variable we had assigned a value to. Package namespaces protect the objects defined in the package from deletion or overwriting. This is different to defining a new object with the same name, which is allowed. The two statements below trigger errors and are not evaluated when typesetting the book.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{datasets}\hlopt{::}\hlstd{cars} \hlkwb{<-} \hlstr{"my car is green"}
\hlkwd{rm}\hlstd{(datasets}\hlopt{::}\hlstd{cars)}
\end{alltt}
\end{kframe}
\end{knitrout}

The value returned by \Rfunction{getAnywhere()} has additional information than that in its member \code{where}. Do have a look at its help page with \code{help(getAnywhere)} for the details.

\end{warningbox}

\section{Further Reading}

Several\index{further reading!object oriented programming in R} books describe in detail the different class systems available and how to use them in \Rlang. For an in-depth treatment of the subject please consult the books \citebooktitle{Wickham2019} \autocite{Wickham2019} and \citebooktitle{Chambers2016} \autocite{Chambers2016}.

\index{further reading!package development}The development of \Rlang packages is accessibly explained in the book \citebooktitle{Wickham2023} \autocite{Wickham2023}, using a practical approach and tools developed by the author and his collaborators. The book \citebooktitle{Chambers2016} \autocite{Chambers2016} has its focus on \Rlang itself, how it works, and how to develop extensions both with simple and challenging goals.





% !Rnw root = appendix.main.Rnw


\chapter{Base \Rlang: ``Verbs'' and ``Nouns'' for Statistics}\label{chap:R:statistics}

\begin{VF}
The purpose of computing is insight, not numbers.

\VA{Richard W. Hamming}{\emph{Numerical Methods for Scientists and Engineers}, 1987}\nocite{Hamming1987}
\end{VF}

\section{Aims of This Chapter}

This chapter aims to give the reader an introduction to the approach used in base \Rlang for the computation of statistical summaries, the fitting of models to observations and tests of hypothesis. This chapter does \emph{not} explain data analysis methods, statistical principles or experimental designs. There are many good books on the use of \Rpgrm for different kinds of statistical analyses (see further reading on page \pageref{sec:stat:further:reading}) but most of them tend to focus on specific statistical methods rather than on the commonalities among them. Although base \R's model fitting functions target specific statistical procedures, they use a common approach to model specification and for returning the computed estimates and test outcomes. This approach, also followed by many contributed extension packages, can be considered as part of the philosophy behind the \Rlang language. In this chapter, you will become familiar with the approaches used in \Rlang for calculating statistical summaries, generating (pseudo-)random numbers, sampling, fitting models, and carrying out tests of significance. We will use linear correlation, \emph{t}-test, linear models, generalised linear models, non-linear models, and some simple multivariate methods as examples. The focus is on how to specify statistical models, contrasts and observations, how to access different components of the objects returned by the corresponding fit and summary functions, and how to use these extracted components in further computations or for customised printing and formatting.

%\emph{At present I use several examples adapted from the help pages for the functions described. I may revise this before publication.}
\section{Statistical Summaries}
\index{summaries!statistical|(}
Being the main focus of the \Rlang language in data analysis and statistics, \Rlang provides functions both for simple and complex calculations, going from means and variances to fitting very complex models. Table \ref{tab:stat:summaries} lists some frequently used functions.  All these methods accept numeric vectors and/or matrices as arguments. In addition, function \Rfunction{quantile()} can be used to simultaneously compute multiple arbitrary quantiles for a vector of observations, and method \Rfunction{summary()} produces a summary that depends on the class of the argument passed to it. (See section \ref{sec:functions:sem} on page \pageref{sec:functions:sem} for how to define your own functions.)

\begin{table}
  \centering
  \caption[Simple statistical summaries.]{Frequently used simple statistical summaries and the corresponding \Rlang functions.\vspace{1ex}}\label{tab:stat:summaries}
  \begin{tabular}{llll}
     \toprule
     Function & Symbol & Formulation & Name \\
     \midrule
     \Rfunction{mean()} & $\bar{x}$ & $\sum x / n$ & mean \\
     \Rfunction{var()} & $s^2$ & $\sum (x_i - \hat{x})^2 / (n - 1)$ & sample variance \\
     \Rfunction{sd()} & $s$ & $\sqrt[2]{s^2}$ & sample standard deviation \\
     \Rfunction{median()} & M or $\tilde{x}$ &  & median \\
     \Rfunction{mad()} & MAD & median $|x_i - \hat{x}|$ & median absolute deviation \\
     \Rfunction{mode()} & MOD &  & mode \\
     \Rfunction{max()} & $x_\mathrm{max}$ &  & maximum \\
     \Rfunction{min()} & $x_\mathrm{min}$ &  & minimum \\
     \Rfunction{range()} & $x_\mathrm{min}, x_\mathrm{max}$ &  & range \\
     \bottomrule
   \end{tabular}
\end{table}

By default, if the argument contains \code{NAs} these functions return \code{NA}. The logic behind this is that if one value exists but is unknown, the true result of the computation is unknown (see page \pageref{par:special:values} for details on the role of \code{NA} in \Rlang). However, an additional parameter called \code{na.rm} allows us to override this default behaviour by requesting any \code{NA} in the input to be removed (or discarded) before calculating the summary,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{20}\hlstd{,} \hlnum{NA}\hlstd{)}
\hlkwd{mean}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] NA
\end{verbatim}
\begin{alltt}
\hlkwd{mean}\hlstd{(x,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 10.5
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{mean()} can be used to compute the mean from all values, as in the example above, as well as trimmed means, i.e., means computed after discarding extreme values. The argument passed to parameter \code{trim} decides the fraction of the observations to discard at \emph{each extreme} of the vector of values after ordering them from smallest to largest.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{20}\hlstd{,} \hlnum{100}\hlstd{)}
\hlkwd{mean}\hlstd{(x)}
\end{alltt}
\begin{verbatim}
## [1] 14.7619
\end{verbatim}
\begin{alltt}
\hlkwd{mean}\hlstd{(x,} \hlkwc{trim} \hlstd{=} \hlnum{0.05}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 11
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
  In contrast to the use of other functions, I do not provide examples of the use of all the functions listed in Table \ref{tab:stat:summaries}. Construct \code{numeric} vectors with artificial data or use real data to play with the remaining functions. Study the help pages to learn about the different parameters and their uses.% Later in the book, only the output from certain examples will be shown, with the expectation, that other examples will be run by readers.
\end{playground}

Other more advanced functions are also available in \Rlang, such as \Rfunction{boxplot.stats()} that computes the values needed to draw boxplots (see section \ref{sec:boxplot} on page \pageref{sec:boxplot}).

In many cases, you will want to compute statistical summaries by group or treatment in addition or instead of for a whole data set or vector. See section \ref{sec:calc:df:aggregate} on page \pageref{sec:calc:df:aggregate} for details on how to compute summaries of data stored in data frames using base \Rlang functions, and section \ref{sec:dplyr:manip} on page \pageref{sec:dplyr:manip} for alternative functions from contributed packages.
\index{summaries!statistical|)}

\section{Standard Probability Distributions}\label{sec:prob:dist}
\index{probability distributions!standard|(}%
\index{probability distributions!theoretical|see{--- standard}}%
\index{Normal distribution}%
Density functions, probability distribution functions, quantile functions, and functions for pseudo-random draws are available in \Rlang for several different standard (theoretical) probability distributions. Entering \code{help(Distributions)} at the \Rlang prompt will open a help page describing all the distributions available in base \Rlang. For each distribution, the different functions contain the same ``root'' in their names: \code{norm} for the normal distribution, \code{unif} for the uniform distribution, and so on. The ``head'' of the name indicates the type of values returned: ``\code{d}'' for density, ``\code{q}'' for quantile, ``\code{r}'' (pseudo-)random draws, and ``\code{p}'' for probability (Table \ref{tab:prob:funs}).

\begin{table}
  \centering
    \caption[Standard probability distributions]{Standard probability distributions in \Rlang. Partial list of base \Rlang functions related to probability distributions. The full list can be obtained by executing the command \code{help(Distributions)}.\vspace{1ex}}\label{tab:prob:funs}

  \begin{tabular}{llllll}
     \toprule
     Distribution & Symbol & Density & $P$-value & Quantiles & Draws \\
     \midrule
     Normal & $N$ & \Rfunction{dnorm()} & \Rfunction{pnorm()} & \Rfunction{qnorm()} & \Rfunction{rnorm()} \\
     Student's & $t$ & \Rfunction{dt()} & \Rfunction{pt()} & \Rfunction{qt()} & \Rfunction{rt()}\\
     F & $F$ & \Rfunction{df()} & \Rfunction{pf()} & \Rfunction{qf()} & \Rfunction{rf()} \\
     binomial & $B$ & \Rfunction{dbinom()} & \Rfunction{pbinom()} & \Rfunction{qbinom()} & \Rfunction{rbinom()} \\
     multinomial & $M$ & \Rfunction{dmultinom()} & \Rfunction{pmultinom()} & \Rfunction{qmultinom()} & \Rfunction{rmultinom()} \\
     Poisson &   & \Rfunction{dpois()} & \Rfunction{ppois()} & \Rfunction{qpois()} & \Rfunction{rpois()} \\
     $\Chi$-squared & $\Chi^2$ & \Rfunction{dchisq()} & \Rfunction{pchisq()} & \Rfunction{qchisq()} & \Rfunction{rchisq()} \\
     lognormal &  & \Rfunction{dlnorm()} & \Rfunction{plnorm()} & \Rfunction{qlnorm()} & \Rfunction{rlnorm()} \\
     uniform &  & \Rfunction{dunif()} & \Rfunction{punif()} & \Rfunction{qunif()} & \Rfunction{runif()} \\
     \bottomrule
   \end{tabular}
\end{table}

Theoretical distributions are defined by mathematical functions that accept parameters that control the exact shape and location. In the case of the Normal distribution, these parameters are the \emph{mean} (\code{mean}) controlling the location center and \emph(standard deviation) (\code{sd}) controlling the spread away from the center of the distribution. The four different functions differ in which values are calculated (the unknowns) and which values are supplied as arguments (the known inputs).

In what follows, I use the Normal distribution as an example, but with differences in their parameters, the functions for other theoretical distributions follow a similar naming pattern.

\subsection{Density from parameters}\label{sec:prob:dens}
\index{probability distributions!density from parameters}
To obtain a single point from the distribution curve we pass a vector of length one as an argument for \code{x}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dnorm}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1.5}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{0.5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.4839414
\end{verbatim}
\end{kframe}
\end{knitrout}

To obtain multiple values we can pass a longer vector as an argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dnorm}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{seq}\hlstd{(}\hlkwc{from} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{to} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{length.out} \hlstd{=} \hlnum{5}\hlstd{),} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{0.5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.0002676605 0.0088636968 0.1079819330 0.4839414490 0.7978845608
\end{verbatim}
\end{kframe}
\end{knitrout}

With 50 equally spaced values for $x$ we can plot a line (\code{type = "l"}) that shows that the 50 generated data points give the illusion of a continuous curve. We also add a point showing the value for $x = 1.5$ calculated above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vct1} \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlkwc{from} \hlstd{=} \hlopt{-}\hlnum{1}\hlstd{,} \hlkwc{to} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{length.out} \hlstd{=} \hlnum{50}\hlstd{)}

\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{= vct1,}
                  \hlkwc{y} \hlstd{=} \hlkwd{dnorm}\hlstd{(}\hlkwc{x} \hlstd{= vct1,} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{))}
\hlkwd{plot}\hlstd{(y}\hlopt{~}\hlstd{x,} \hlkwc{data} \hlstd{= df1,} \hlkwc{type} \hlstd{=} \hlstr{"l"}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{"z"}\hlstd{,} \hlkwc{ylab} \hlstd{=} \hlstr{"f(z)"}\hlstd{)}
\hlkwd{points}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{dnorm}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-distrib-01b-1} 

}


\end{knitrout}

\subsection{Probabilities from parameters and quantiles}\label{sec:prob:quant}
\index{probability distributions!probabilities from quantiles}

With a known quantile value, it is possible to look up the corresponding $P$-value from the Normal distribution, i.e., the area under the curve, either to the right or to the left of a given value of \code{q} (by default, integrating the lower or left tail). When working with observations, the quantile, mean and standard deviation are in most cases computed from the same observations under the null hypothesis. In the example below, we use invented values for all parameters \code{q}, the quantile, \code{mean}, and \code{sd}, the standard deviation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{pnorm}\hlstd{(}\hlkwc{q} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.8413447
\end{verbatim}
\begin{alltt}
\hlkwd{pnorm}\hlstd{(}\hlkwc{q} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.1586553
\end{verbatim}
\begin{alltt}
\hlkwd{pnorm}\hlstd{(}\hlkwc{q} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.4012937
\end{verbatim}
\begin{alltt}
\hlkwd{pnorm}\hlstd{(}\hlkwc{q} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{4}\hlstd{),} \hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.158655254 0.001349898
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
  In tests of significance, empirical $z$-values and $t$-values are computed by subtracting from the observed mean for one group or raw quantile, the ``expected'' mean (a hypothesised theoretical value, the mean of a control condition used as a reference, or the mean computed over all treatments under the assumption of no effect of treatments) and then dividing this difference by the standard deviation. Consequently, the $p$-values corresponding to these empirical $z$-values and $t$-values need to be looked up using \code{mean = 0} and \code{sd = 1} when calling \Rfunction{pnorm()} or \Rfunction{pt()} respectively. These frequently used values are the defaults.
\end{explainbox}

\subsection{Quantiles from parameters and probabilities}\label{sec:quant:prob}
\index{probability distributions!quantiles from probabilities}

The reverse computation from that in the previous section is to obtain the quantile corresponding to a known $P$-value or area under one of the tails of the distribution curve. These quantiles are equivalent to the values in the tables of precalculated quantiles used in earlier times to assess significance with statistical tests.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{qnorm}\hlstd{(}\hlkwc{p} \hlstd{=} \hlnum{0.01}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] -2.326348
\end{verbatim}
\begin{alltt}
\hlkwd{qnorm}\hlstd{(}\hlkwc{p} \hlstd{=} \hlnum{0.05}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] -1.644854
\end{verbatim}
\begin{alltt}
\hlkwd{qnorm}\hlstd{(}\hlkwc{p} \hlstd{=} \hlnum{0.05}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.644854
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
Quantile functions like \Rfunction{qnorm()} and probability functions like \Rfunction{pnorm()} always do computations based on a single tail of the distribution, even though it is possible to specify which tail we are interested in. If we are interested in obtaining simultaneous quantiles for both tails, we need to do this manually. If we are aiming at quantiles for $P = 0.05$, we need to find the quantile for each tail based on $P / 2 = 0.025$.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{qnorm}\hlstd{(}\hlkwc{p} \hlstd{=} \hlnum{0.025}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] -1.959964
\end{verbatim}
\begin{alltt}
\hlkwd{qnorm}\hlstd{(}\hlkwc{p} \hlstd{=} \hlnum{0.025}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 1.959964
\end{verbatim}
\end{kframe}
\end{knitrout}

When calculating a $P$-value from a quantile computed from observations in a test of significance, we need to first decide whether a two-sided or single-sided test is relevant, and in the case of a single sided test, which tail is of interest. In a two-sided test we need to multiply the returned $P$-value by 2. This works in the case of a symmetric distribution like the Normal, because the quantiles in the two tails differ only in sign. However, this is not the case for asymmetric distributions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{pnorm}\hlstd{(}\hlkwc{q} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{1}\hlstd{)} \hlopt{*} \hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 1.999937
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{warningbox}

\subsection{``Random'' draws from a distribution}\label{sec:stat:random}
\index{random draws|see{probability distributions, pseudo-random draws}}\index{probability distributions!pseudo-random draws}

True random sequences can only be generated by physical processes. All ``pseudo-random'' sequences of numbers generated by computation are really deterministic although they share many properties with true random sequences (e.g., in relation to autocorrelation).

It is possible to compute not only pseudo-random draws from a uniform distribution but also from the Normal, $t$, $F$, and other distributions. In each case, the probability with which different values are ``drawn'' approximates the probabilities set by the corresponding theoretical distribution. Parameter \code{n} indicates the number of values to be drawn, or its equivalent, the length of the vector returned (see section \ref{sec:plot:histogram} on page \pageref{sec:plot:histogram} for example plots).\qRfunction{rnorm()}\qRfunction{runif()}%

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{rnorm}\hlstd{(}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] -0.8248801  0.1201213 -0.4787266 -0.7134216  1.1264443
\end{verbatim}
\begin{alltt}
\hlkwd{rnorm}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] 12.394190  9.697729  9.212345 11.624844 12.194317 10.257707 10.082981
##  [8] 10.268540 10.792963  7.772915
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Edit the examples in sections \ref{sec:prob:quant}, \ref{sec:quant:prob}, and \ref{sec:stat:random} to do computations based on different distributions, such as Student's \emph{t}, \emph{F} or uniform.
\end{playground}

\begin{explainbox}
\index{random numbers|see{pseudo-random numbers}}\index{pseudo-random numbers}
It is impossible to generate truly random sequences of numbers by means of a deterministic process such as a mathematical computation. ``Random numbers'' as generated by \Rpgrm and other computer programs are \emph{pseudo-random numbers}, long deterministic series of numbers that resemble random draws. Random number generation uses a \emph{seed} value that determines where in the series the first value is fetched. The usual way of automatically setting the value of the seed is to take the milliseconds or a similar rapidly changing set of digits from the real-time clock of the computer. However, in cases when we wish to repeat a calculation using the same series of pseudo-random values, we can use \Rfunction{set.seed()} with an arbitrary integer as an argument to reset the generator to the same point in the underlying (deterministic) sequence.
\end{explainbox}

\begin{advplayground}
Execute the statement \code{rnorm(3)}\qRfunction{rnorm()} by itself several times, paying attention to the values obtained. Repeat the exercise, but now executing \code{set.seed(98765)}\qRfunction{set.seed()} immediately before each call to \code{rnorm(3)}, again paying attention to the values obtained. Next execute \code{set.seed(98765)}, followed by \code{c(rnorm(3), rnorm(3))}, and then execute \code{set.seed(98765)}, followed by \code{rnorm(6)} and compare the output. Repeat the exercise using a different argument in the call to \code{set.seed()}. analyse the results and explain how \code{setseed()} affects the generation of pseudo-random numbers in \Rlang.
\end{advplayground}
\index{probability distributions!standard|)}

\section{Observed Probability Distributions}
\index{probability distributions!observed|(}%
\index{empirical probability distributions|see{probability distributions, observed}}%
It is common to estimate the value of the parameters for a standard distribution like Student's $t$ or Normal distributions from observational data, assuming a priori the suitability of the distribution. If we compute the mean and standard deviation of a large sample, these two parameters define a specific Normal distribution curve. If we add the estimate of the degrees of freedom, $v = n - 1$, the three parameters define a specific $t$-distribution curve. Thus it is possible to use the functions described in section \ref{sec:prob:dist} on page \ref{sec:prob:dist}, in statistical inference.

\begin{explainbox}
Package \pkgname{mixtools} provides tools for fitting and analysing \emph{mixture models} such as the mix of two or more univariate Normal distributions. An example of its use could be to estimate mean and standard deviations for males and females in a dataset where the gender was not recorded at the time of observation.
\end{explainbox}

It is also possible to describe the observed shape of the distribution, or empirical distribution, for a data set without relying on a standard distribution. The fitted empirical distribution can later be used to compute probabilities, quantiles, and random draws as from standard distributions. This also allows statistical inference, using methods such as the bootstrap or some additive models.

Function \Rfunction{density()} computes kernel density estimates, using different methods. A curve is used to describe the shape, and the bandwidth determines how flexible this curve is. The curve is a smoother that adapts to the observed shape of the distribution of observations. The object returned is a complex list that can be used to plot the estimated curve.

The code below estimates the empirical distribution for the waiting time in minutes between eruptions of the Old Faithful geyser at Yellowstone, a dataset from \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{d} \hlkwb{<-} \hlkwd{density}\hlstd{(faithful}\hlopt{$}\hlstd{waiting,} \hlkwc{bw} \hlstd{=} \hlstr{"sj"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Using \Rfunction{str()} we can explore the structure of the object returned by function \Rfunction{density()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(d)}
\end{alltt}
\begin{verbatim}
## List of 8
##  $ x         : num [1:512] 35.5 35.6 35.8 35.9 36 ...
##  $ y         : num [1:512] 8.36e-06 9.89e-06 1.17e-05 1.38e-05 1.62e-05 ...
##  $ bw        : num 2.5
##  $ n         : int 272
##  $ old.coords: logi FALSE
##  $ call      : language density.default(x = faithful$waiting, bw = "sj")
##  $ data.name : chr "faithful$waiting"
##  $ has.na    : logi FALSE
##  - attr(*, "class")= chr "density"
\end{verbatim}
\end{kframe}
\end{knitrout}

The object saved as \code{d} is a \code{list} with seven members. The two numeric vectors, \code{x} and \code{y} describe the estimated probability distribution and produce the curve in the plot below. The numerical bandwidth estimated using method \code{"sj"} is in \code{bw}, and the length of vector \code{faithful\$waiting}, the data used, is in \code{n}. Member \code{call} is the command used to call the function, the remaining two members have self-explanatory names. The returned object belongs to class \Rclass{density}. The overall pattern is similar, but simpler than for the model fitting functions that we will see later in the chapter. The class name of the object is the same as the name of the function that created it, \code{call} provides a \emph{trace} of how the object was created. Other members, facilitate computation of derived quantities and plotting. Being a list, the individual members can be extracted by name.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{d}\hlopt{$}\hlstd{n}
\end{alltt}
\begin{verbatim}
## [1] 272
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

As a \Rmethod{plot()} method is available for class \Rclass{density} we can easily produce a plot of the estimated empirical density distribution. In this case, the fitted bimodal curve, with two maxima, is very different to the Normal.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(d)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-desnity-04-1} 

}


\end{knitrout}

Observed probability distributions, especially empirical ones, nowadays play a central role in data visualisation including 1D and 2D empirical density plots based on the use of functions like \Rfunction{density()}, as well as traditional histograms (see section \ref{sec:plot:density} on page \pageref{sec:plot:density} for examples of more elaborate and elegant plots).
\index{probability distributions!observed|)}

\section{``Random'' Sampling}
\index{random sampling|see{pseudo-random sampling}}%
\index{pseudo-random sampling|(}%

In addition to drawing values from a theoretical distribution, we can draw values from an existing set or collection of values. We call this operation (pseudo-)random sampling. The draws can be done either with replacement or without replacement. In the second case, all draws are taken from the whole set of values, making it possible for a given value to be drawn more than once. In the default case of not using replacement, subsequent draws are taken from the values remaining after removing the values chosen in earlier draws.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sample}\hlstd{(}\hlkwc{x} \hlstd{= LETTERS)}
\end{alltt}
\begin{verbatim}
##  [1] "Z" "N" "Y" "R" "M" "E" "W" "J" "H" "G" "U" "O" "S" "T" "L" "F" "X" "P" "K"
## [20] "V" "D" "A" "B" "C" "I" "Q"
\end{verbatim}
\begin{alltt}
\hlkwd{sample}\hlstd{(}\hlkwc{x} \hlstd{= LETTERS,} \hlkwc{size} \hlstd{=} \hlnum{12}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] "M" "S" "L" "R" "B" "D" "Q" "W" "V" "N" "J" "P"
\end{verbatim}
\begin{alltt}
\hlkwd{sample}\hlstd{(}\hlkwc{x} \hlstd{= LETTERS,} \hlkwc{size} \hlstd{=} \hlnum{12}\hlstd{,} \hlkwc{replace} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] "K" "E" "V" "N" "A" "Q" "L" "C" "T" "L" "H" "U"
\end{verbatim}
\end{kframe}
\end{knitrout}

In practice, pseudo-random sampling is useful when we need to select subsets of observations. One such case is assigning treatments to experimental units in an experiment or selecting persons to interview in a survey. Another use is in bootstrapping to estimate variation in parameter estimates using empirical distributions.

\begin{faqbox}{How to sample random rows from a data frame?}
As described in section \ref{sec:R:data:frames} on page \pageref{sec:R:data:frames}, data frames are commonly used to store one observation per row. To sample a subset of rows, we need to generate a random set of indices to use with the extraction operator (\Roperator{[ ]}). Here we sample four rows from data frame \code{cars} included in \Rlang. These data consist of stopping distances for cars moving at different speeds as described in the documentation available by entering \code{help(cars)}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cars[}\hlkwd{sample}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlkwd{nrow}\hlstd{(cars),} \hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{), ]}
\end{alltt}
\begin{verbatim}
##    speed dist
## 33    18   56
## 31    17   50
## 50    25   85
## 36    19   36
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{faqbox}

\begin{advplayground}
Consult the documentation of \Rfunction{sample()} and explain why the code below is equivalent to that in the example immediately above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{cars[}\hlkwd{sample}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{nrow}\hlstd{(cars),} \hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{), ]}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{advplayground}
\index{pseudo-random sampling|)}%

\section{Correlation}\label{sec:stats:correlation}
\index{correlation|(}
Both parametric (Pearson's) and non-parametric robust (Spearman's and Kendall's) methods for the estimation of the (linear) correlation between pairs of variables are available in base \Rlang. The different methods are selected by passing arguments to a single function. While Pearson's method is based on the actual values of the observations, non-parametric methods are based on the ordering or rank of the observations, and consequently less affected by observations with extreme values.

\subsection{Pearson's $r$}
\index{correlation!parametric}
\index{correlation!Pearson}

Function \Rfunction{cor()} can be called with two vectors of the same length as arguments. In the case of the parametric Pearson method, we do not need to provide further arguments as this method is the default one.  We use data set \code{cars}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cor}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist)}
\end{alltt}
\begin{verbatim}
## [1] 0.8068949
\end{verbatim}
\end{kframe}
\end{knitrout}

It is also possible to pass a data frame (or a matrix) as the only argument. When the data frame (or matrix) contains only two columns, the returned correlation estimate is equivalent to that of passing the two columns individually as vectors. The object returned is a $2 \times 2$ \code{matrix} instead of a vector of length one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cor}\hlstd{(cars)}
\end{alltt}
\begin{verbatim}
##           speed      dist
## speed 1.0000000 0.8068949
## dist  0.8068949 1.0000000
\end{verbatim}
\end{kframe}
\end{knitrout}

When the data frame or matrix contains more than two numeric vectors, the returned value is a matrix of estimates of pairwise correlations between columns. We here use \Rfunction{rnorm()} described above to create a long vector of pseudo-random values drawn from the Normal distribution and \Rfunction{matrix()} to convert it into a matrix with three columns (see page \pageref{sec:matrix:array} for details about \Rlang matrices).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mat1} \hlkwb{<-} \hlkwd{matrix}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{54}\hlstd{),} \hlkwc{ncol} \hlstd{=} \hlnum{3}\hlstd{,}
               \hlkwc{dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{rows} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{18}\hlstd{,} \hlkwc{cols} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{)))}
\hlkwd{cor}\hlstd{(mat1)}
\end{alltt}
\begin{verbatim}
##            A         B          C
## A 1.00000000 0.1899797 0.07591003
## B 0.18997966 1.0000000 0.36800323
## C 0.07591003 0.3680032 1.00000000
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Modify the code in the chunk immediately above constructing a matrix with six columns and then computing the correlations.
\end{playground}

While \Rfunction{cor()} returns an estimate of $r$, the correlation coefficient, \Rfunction{cor.test()} computes, in addition, the $t$-value, $P$-value, and confidence interval for the estimate.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cor.test}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist)}
\end{alltt}
\begin{verbatim}
## 
## 	Pearson's product-moment correlation
## 
## data:  cars$speed and cars$dist
## t = 9.464, df = 48, p-value = 1.49e-12
## alternative hypothesis: true correlation is not equal to 0
## 95 percent confidence interval:
##  0.6816422 0.8862036
## sample estimates:
##       cor 
## 0.8068949
\end{verbatim}
\end{kframe}
\end{knitrout}

Above we passed two numeric vectors as arguments, one to parameter \code{x} and one to parameter \code{y}. Alternatively, we can pass a data frame as an argument to \code{data}, and a \emph{model formula} to \code{formula}. The argument passed to \code{formula} determines which variables from \code{data} are used, and in which role. Briefly, the variable(s) to the left of the tilde (\code{~}) are response variables, and those to the right are independent, or explanatory, variables. In the case of correlation, no assumption is made on cause and effect, and both variables appear to the right of the tilde. The code below is equivalent to that above. See section \ref{sec:stat:formulas} on page \pageref{sec:stat:formulas} for details on the use of model formulas and section \ref{sec:stat:mf} on page \pageref{sec:stat:mf} for examples of their use in model fitting.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cor.test}\hlstd{(}\hlkwc{formula} \hlstd{=} \hlopt{~} \hlstd{speed} \hlopt{+} \hlstd{dist,} \hlkwc{data} \hlstd{= cars)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Functions \Rfunction{cor()} and \Rfunction{cor.test()} return \Rlang objects, that when using \Rlang interactively get automatically ``printed'' on the screen. One should be aware that \Rfunction{print()} methods do not necessarily display all the information contained in an \Rlang object. This is almost always the case for complex objects like those returned by \Rlang functions implementing statistical tests. As with any \Rlang object, we can save the result of an analysis into a variable. As described in section \ref{sec:calc:lists} on page \pageref{sec:calc:lists} for lists, we can peek into the structure of an object with method \Rfunction{str()}. We can use \Rfunction{class()} and \Rfunction{attributes()} to extract further information. Run the code in the chunk below to discover what is actually returned by \Rfunction{cor()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{MAT1} \hlkwb{<-} \hlkwd{cor}\hlstd{(cars)}
\hlkwd{class}\hlstd{(MAT1)}
\hlkwd{attributes}\hlstd{(MAT1)}
\hlkwd{str}\hlstd{(MAT1)}
\end{alltt}
\end{kframe}
\end{knitrout}

Methods \Rfunction{class()}, \Rfunction{attributes()} and \Rfunction{str()} are very powerful tools that can be used when we are in doubt about the data contained in an object and/or how it is structured. Knowing the structure allows us to retrieve the data members directly from the object when predefined extractor methods are not available.
\end{playground}

\subsection{Kendall's $\tau$ and Spearman's $\rho$}
\index{correlation!non-parametric}
\index{correlation!Kendall}
\index{correlation!Spearman}

We use the same functions as for Pearson's $r$ but explicitly request the use of one of these methods by passing an argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cor}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist,} \hlkwc{method} \hlstd{=} \hlstr{"kendall"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.6689901
\end{verbatim}
\begin{alltt}
\hlkwd{cor}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist,} \hlkwc{method} \hlstd{=} \hlstr{"spearman"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0.8303568
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{cor.test()}, described above, also allows the choice of method with the same syntax as shown for \Rfunction{cor()}.

\begin{playground}
Repeat the exercise in the playground immediately above, but now using non-parametric methods. How does the information stored in the returned \code{matrix} differ depending on the method, and how can we extract from the returned object information about the method used for the calculation of the correlation?
\end{playground}
\index{correlation|)}

\section{$t$-test}\label{sec:stats:ttest}
\index{t-test@$t$-test|(}%
\index{Student's t-test@Student's $t$-test|see{$t$-test}}%
The $t$-test is based on Student's $t$-distribution. It can be applied to any parameter estimate for which its standard deviation is available, and the $t$-distribution is a plausible assumption. It is most frequently used to compare an estimate of the mean against a constant value, or the estimate of a difference between two means and a target difference, usually no difference. In \Rlang these can be computed manually using functions \Rfunction{mean()}, \Rfunction{sd()}, and \Rfunction{pt()} or with \Rfunction{t.test()}.

Although rarely presented in such a way, the $t$-test can be thought of as a special case of a linear model fit. Consistently with functions used to fit models to observations, we can use a \emph{formula} to describe a $t$-test. A formula such as \code{y\,\char"007E\,x} is read as $y$ is explained by $x$. We use \emph{lhs} (left-hand-side) and \emph{rhs} (right-hand-side) to signify all terms to the left and right of the tilde (\code{\,\char"007E\,}), respectively (\code{<lhs>\,\char"007E\,<rhs>}). (See section \ref{sec:stat:formulas} on page \pageref{sec:stat:formulas} for a detailed discussion of model formulas, and section \ref{sec:stat:mf} on page \pageref{sec:stat:mf} for examples of their use in model fitting.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{some.size} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{2.5}\hlstd{),} \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{2.0}\hlstd{)),}
                  \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{),} \hlkwc{each} \hlstd{=} \hlnum{10}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}

The formula \code{some.size\,\char"007E\,1} is read as ``the mean of variable \code{some.size} is explained by a constant value''. The value estimated from observations, $\bar{x}$, is compared against the value of $\mu$ set as the null hypothesis, where $\mu$ is the \emph{unknown} mean of the sampled population. By default, \Rfunction{t.test()} applies a two-sided test (\code{alternative = "two.sided"}) against \code{mu = 0}, but here we use \code{mu = 2} instead.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{t.test}\hlstd{(some.size} \hlopt{~} \hlnum{1}\hlstd{,} \hlkwc{mu} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{data} \hlstd{= df1)}
\end{alltt}
\begin{verbatim}
## 
## 	One Sample t-test
## 
## data:  some.size
## t = 1.078, df = 19, p-value = 0.2945
## alternative hypothesis: true mean is not equal to 2
## 95 percent confidence interval:
##  1.741200 2.808479
## sample estimates:
## mean of x 
##   2.27484
\end{verbatim}
\end{kframe}
\end{knitrout}

The same test can be calculated step by step. In this case, this approach is not needed, but it is useful when we have a parameter estimate (not just mean) and its standard error available, as in model fits (see the advanced playground on page \pageref{box:stats:slope:ttest} for an example).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sem} \hlkwb{=} \hlkwd{sqrt}\hlstd{(}\hlkwd{var}\hlstd{(df1}\hlopt{$}\hlstd{some.size)} \hlopt{/} \hlkwd{nrow}\hlstd{(df1))}
\hlstd{t.value} \hlkwb{=} \hlstd{(}\hlkwd{mean}\hlstd{(df1}\hlopt{$}\hlstd{some.size)} \hlopt{-} \hlnum{2}\hlstd{)} \hlopt{/} \hlstd{sem} \hlcom{# Ho: mu = 2}
\hlstd{p.value} \hlkwb{<-} \hlkwd{pt}\hlstd{(t.value,} \hlkwc{df} \hlstd{=} \hlkwd{nrow}\hlstd{(df1)} \hlopt{-} \hlnum{1}\hlstd{,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)} \hlopt{*} \hlnum{2} \hlcom{# two tails}
\hlkwd{signif}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwc{t} \hlstd{= t.value,} \hlkwc{df} \hlstd{=} \hlkwd{nrow}\hlstd{(df1)} \hlopt{-} \hlnum{1}\hlstd{,} \hlkwc{P} \hlstd{= p.value),} \hlnum{4}\hlstd{)} \hlcom{# 4 digits}
\end{alltt}
\begin{verbatim}
##       t      df       P 
##  1.0780 19.0000  0.2945
\end{verbatim}
\end{kframe}
\end{knitrout}

The same function, with a different formula, tests for the difference between the means of two groups or treatments, $H_o: {\mu}_A - {\mu}_B = 0$. We read the formula \code{some.size\,\char"007E\,group} as ``differences in \code{some.size} are explained by factor \code{group}''. The difference between the means for the two groups is estimated and compared against the hypothesis. (In this case, the value of the argument passed to \code{mu}, zero by default, describes this difference.) By default, variances in the two groups are not to assumed equal,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{t.test}\hlstd{(some.size} \hlopt{~} \hlstd{group,} \hlkwc{data} \hlstd{= df1)}
\end{alltt}
\begin{verbatim}
## 
## 	Welch Two Sample t-test
## 
## data:  some.size by group
## t = 1.5864, df = 17.666, p-value = 0.1304
## alternative hypothesis: true difference in means between group A and group B is not equal to 0
## 95 percent confidence interval:
##  -0.2538836  1.8108119
## sample estimates:
## mean in group A mean in group B 
##        2.664072        1.885608
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
but with \code{var.equal = TRUE}, the variances in the populations from which observations in  groups A and B were sampled are assumed equal, and pooled into a single estimate.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{t.test}\hlstd{(some.size} \hlopt{~} \hlstd{group,} \hlkwc{var.equal} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{data} \hlstd{= df1)}
\end{alltt}
\begin{verbatim}
## 
## 	Two Sample t-test
## 
## data:  some.size by group
## t = 1.5864, df = 18, p-value = 0.1301
## alternative hypothesis: true difference in means between group A and group B is not equal to 0
## 95 percent confidence interval:
##  -0.2524857  1.8094140
## sample estimates:
## mean in group A mean in group B 
##        2.664072        1.885608
\end{verbatim}
\end{kframe}
\end{knitrout}

The $t$-test serves as an example of how statistical tests are usually carried out in \Rlang. Table \ref{tab:stats:tests} lists \Rlang functions for frequently used statistical tests.

\begin{table}
  \caption[Statistical tests]{\Rlang functions implementing frequently used statistical tests. Student's $t$-test and correlation tests are described on pages \pageref{sec:stats:ttest} and \pageref{sec:stats:correlation}, respectively.}\vspace{1ex}\label{tab:stats:tests}

  \centering\noindent
   \begin{tabular}{ll}
     \toprule
     Statistical test & Function name \\
     \midrule
     Student's $t$-test (1 and 2 samples) & \code{t.test()} \\
     Wilcoxon rank sum and signed rank tests & \code{wilcox.test} \\
     Kolmogorov-Smirnov tests & \code{ks.test()} \\
     Correlation tests (Pearson, Kendall, Spearman) & \code{cor.test()} \\
     $F$-test to compare two variances & \code{var.test()} \\
     Fisher's exact test for count data & \code{fisher.test()} \\
     Pearson's Chi-squared ($\chi^2$) test for count data & \code{chisq.test()} \\
     Exact Binomial Test & \code{binom.test()} \\
     Test of equal or given proportions & \code{prop.test()} \\
     \bottomrule
   \end{tabular}
\end{table}

\index{t-test@$t$-test|)}

\section{Model Fitting in \Rlang}\label{sec:stat:mf}
\index{models!fitting|(}
The general approach to model fitting in \Rlang is to separate the actual fitting of a model from the inspection of the fitted model. A model fitting function minimally requires a description of the model to fit, as a model \code{formula} and a data frame or vectors with the data or observations to which to fit the model. These functions in \Rlang return a model-fit object. This object contains the data, the model formula, the call, and the result of fitting the model. Several methods are available for querying it. The diagram in Figure \ref{fig:model:fit:diagram} summarises the approach used in \Rlang for data analysis based on fitted models.

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model specification}};
\node (data) [tprocess, below of=model] {\textsl{observations}};
\node (fitfun) [tprocess, right of=model, yshift=-0.7cm, xshift=2.5cm] {\textsl{fitting function}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.5cm] {\textsl{fitted model}};
\node (summary) [tprocess, color = black, right of=fm, xshift=1.7cm] {\textsl{query methods}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (summary);
\end{tikzpicture}
\end{small}
  \caption[Model fitting in \Rlang]{Model fitting in \Rlang is done in steps, and can be represented schematically as a flow of information.}\label{fig:model:fit:diagram}
\end{figure}

Models are described using model formulas such as \code{y\,\char"007E\,x} which we read as $y$ is explained by $x$. We use \emph{lhs} (left-hand-side) and \emph{rhs} (right-hand-side) to signify all terms to the left and right of the tilde (\code{\,\char"007E\,}), respectively (\code{<lhs>\,\char"007E\,<rhs>}). Model formulas are used in different contexts: fitting of models, plotting, and tests like $t$-test. The syntax of model formulas is consistent throughout base \Rlang and numerous independently developed packages. However, their use is not universal, and several packages extend the basic syntax to allow the description of specific types of models. As most things in \Rlang, model formulas are objects and can be stored in variables. See section \ref{sec:stat:formulas} on page \pageref{sec:stat:formulas} for a detailed discussion of model formulas.

Although there is some variation, especially for fitted model classes defined in extension packages, in most cases, the \textsl{query functions} bulked together in the rightmost box in the diagram in Figure \ref{fig:model:fit:diagram} include \Rfunction{summary()}, \Rfunction{anova()} and \Rfunction{plot()}, with other methods such as \Rfunction{coef()}, \Rfunction{residuals()}, \Rfunction{fitted()}, \Rfunction{predict()}, \Rfunction{AIC()}, and \Rfunction{BIC()} usually also available. Additional methods may be available. However, as model fit objects are \code{list}-like, these and other values can be extracted and/or computed programmatically when needed. The examples in this chapter can be adapted to the fitting of types of models not described in this book.

\begin{explainbox}
  Fitted model objects in \Rlang are self contained and include a copy of the data to which the model was fit, as well as residuals and possibly even intermediate results of computations. Although this can make the size of these objects large, it allows querying and even updating them in the absence of the data in the current \Rlang workspace.
\end{explainbox}

\section{Fitting Linear Models}\label{sec:stat:LM}
\index{models!linear|see{linear models}}
\index{linear models|(}
\index{LM|see{linear models}}

Regression, analysis of variance (ANOVA) and analysis of covariance (ANCOVA) are all linear models, differing only on the type of explanatory variables included in the statistical model fitted. If in the fitted model all explanatory variables are continuous, i.e., \code{numeric}, vectors, the model is a regression model. If all explanatory variables are discrete, i.e., \code{factors}, the model is ANOVA. Finally, if the model contains but \code{numeric} variables and \code{factors} it is named ANCOVA. As in all cases the fitting approach is the same, based on ordinary least squares (OLS), in \Rlang, they are all implemented in function \Rfunction{lm()}.

There is another meaning of ANOVA, referring only to the tests of significance rather than to an approach to model fitting. Consequently, rather confusingly, results for tests of significance can both in the case of regression, ANOVA and ANCOVA, be presented in an ANOVA table. In this second, stricter meaning, ANOVA means a test of significance based on the ratios between pairs of variances.

\begin{warningbox}
If you do not clearly remember the difference between numeric vectors and factors, or how they can be created, please, revisit chapter \ref{chap:R:as:calc} on page \pageref{chap:R:as:calc}.
\end{warningbox}

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model} $\to$ \code{formula}};
\node (data) [tprocess, below of=model, yshift = 0.4cm] {\textsl{observations} $\to$ \code{data}};
\node (weights) [tprocess, dashed, below of=data, fill=blue!1, yshift = 0.4cm] {\textsl{weights} $\to$ \code{weights}};
\node (fitfun) [tprocess, right of=data, xshift=2.5cm, fill=blue!5] {\code{lm()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.5cm, fill=blue!5] {\code{lm} \textsl{object}};
\node (summary) [tprocess, color = black, right of=fm, xshift=1.7cm] {\code{summary()}};
\node (anova) [tprocess, color = black, below of=summary, yshift = 0.4cm] {\code{anova()}};
\node (plot) [tprocess, color = black, above of=summary, yshift = -0.4cm] {\code{plot()}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow, dashed] (weights) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (plot);
\draw [arrow] (fm) -- (anova);
\draw [arrow] (fm) -- (summary);
\end{tikzpicture}
\end{small}
  \caption[Linear model fitting in \Rlang]{Linear model fitting in \Rlang is done in steps. The generic diagram from Figure \ref{fig:model:fit:diagram} redrawn to show a linear model fit. Non-filled boxes are shared with the fitting of other types of models, and filled ones are specific to \Rfunction{lm()}. Only the three most frequently used query methods are shown, while  both response and explanatory variables are under \textsl{observations}. Dashed boxes and arrows are optional as defaults are provided.}\label{fig:lm:fit:diagram}
\end{figure}

Figure \ref{fig:lm:fit:diagram} shows the steps needed to fit a linear model and extract the estimates and test results. The observations are stored in a data frame, one case or event per row, with values for both response and explanatory variables in variables or columns. The model formula is used to indicate which variables in the data frame are to be used and in which role: either
response or explanatory, and when explanatory how they contribute to the estimated response. The object containing the results from the fit is queried to assess validity and make conclusions or predictions.

\begin{explainbox}
Weights are multiplicative factors used to alter the \emph{weight} given to individual residuals when fitting a model to observations that are not equally informative. A frequent case is fitting a model to observations that are means of drastically different numbers of individual measurements. Some model fit functions compute the weights, but in most cases they are supplied as an argument to parameter \code{weights}. By default, \code{weights} have a value of \code{1} and thus do not affect the resulting model fit, when supplied or computed, the weights are saved to the model fit object.
\end{explainbox}

\subsection{Regression}\label{sec:stat:LM:regression}
%\index{linear regression}
\index{linear regression|see{linear models, linear regression}}%
\index{linear models!linear regression|(}%
The \Rdata{cars} data set, containing two \code{numeric} variables, is used in the examples.
A simple linear model $y = \alpha \cdot 1 + \beta \cdot x$ where $y$ corresponds to stopping distance (\code{dist}) and $x$ to initial speed (\code{speed}) is formulated in \Rlang as \code{dist \char"007E\ 1 + speed}. The fitted model object is assigned to variable \code{fm1} (a mnemonic for fitted-model one).\label{chunk:lm:models1}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm1} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlnum{1} \hlopt{+} \hlstd{speed,} \hlkwc{data}\hlstd{=cars)}
\hlkwd{class}\hlstd{(fm1)}
\end{alltt}
\begin{verbatim}
## [1] "lm"
\end{verbatim}
\end{kframe}
\end{knitrout}

The next step is diagnosis of the fit. Are assumptions of the linear model procedure used reasonably close to being fulfilled? In \Rlang it is most common to use plots to this end. We show here only one of the plots normally produced. This quantile vs.\ quantile plot is used to assess how much the distribution of the residuals deviates from the assumed Normal distribution.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(fm1,} \hlkwc{which} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-models-1a-1} 

}


\end{knitrout}

In the case of a regression, calling \Rfunction{summary()} with the fitted model object as argument is most useful as it provides a table of coefficient estimates and their errors. Remember that as is the case for most \Rlang functions, the value returned by \Rfunction{summary()} is printed when we call this method at the \Rlang prompt.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm1)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ 1 + speed, data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -29.069  -9.525  -2.272   9.215  43.201 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept) -17.5791     6.7584  -2.601   0.0123 *  
## speed         3.9324     0.4155   9.464 1.49e-12 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 15.38 on 48 degrees of freedom
## Multiple R-squared:  0.6511,	Adjusted R-squared:  0.6438 
## F-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12
\end{verbatim}
\end{kframe}
\end{knitrout}

The summary\index{linear models!summary table} is organised in sections. ``Call:'' shows \code{dist\ \char"007E\ 1 + speed} or the specification of the model fitted, plus the data used. ``Residuals:'' displays the extremes, quartiles and median of the residuals, or deviations between observations and the fitted line. ``Coefficients:'' contains estimates of the model parameters and their variation plus corresponding $t$-tests. In the last three lines, there is information on overall standard error and its degrees of freedom and overall coefficient of determination ($R^2$) and $F$-statistic.

Replacing $\alpha$ and $\beta$ in $y = \alpha \cdot 1 + \beta \cdot x$ by the estimates for the intercept, $a = -17.6$, and slope, $b = 3.93$, we obtain an estimate for the regression line $y = -17.6 + 3.93 x$. However, given the nature of the problem, we \emph{know based on first principles} that the stopping distance must be zero when speed is zero. This suggests that we should not estimate the value of $\alpha$ but instead set $\alpha = 0$, or in other words, fit the model $y = \beta \cdot x$.

In \Rlang models, the intercept is included by default, so the model fitted above can be formulated as \code{dist\ \char"007E\ speed}---i.e., the missing \code{+ 1} does not change the model. To exclude the intercept, we need to specify the model as \code{dist\ \char"007E\ speed - 1} (or its equivalent \code{dist\ \char"007E\ speed + 0}), for a straight line passing through the origin ($x = 0$, $y = 0$). In the summary for this model there is an estimate for the slope but not for the intercept.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm2} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{-} \hlnum{1}\hlstd{,} \hlkwc{data} \hlstd{= cars)}
\hlkwd{summary}\hlstd{(fm2)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed - 1, data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -26.183 -12.637  -5.455   4.590  50.181 
## 
## Coefficients:
##       Estimate Std. Error t value Pr(>|t|)    
## speed   2.9091     0.1414   20.58   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 16.26 on 49 degrees of freedom
## Multiple R-squared:  0.8963,	Adjusted R-squared:  0.8942 
## F-statistic: 423.5 on 1 and 49 DF,  p-value: < 2.2e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

The equation for \code{fm2} is $y = 2.91 x$. From the residuals, it can be seen that it is inadequate, as the straight line does not follow the curvature of the cloud of observations.

\begin{playground}
You will now fit a second-degree polynomial\index{linear models!polynomial regression}\index{polynomial regression}, a different linear model: $y = \alpha \cdot 1 + \beta_1 \cdot x + \beta_2 \cdot x^2$. The function used is the same as for linear regression, \Rfunction{lm()}. We only need to alter the formulation of the model. The identity function \Rfunction{I()} is used to protect its argument from being interpreted as part of the model formula. Instead, its argument is evaluated beforehand and the result is used as the, in this case second, explanatory variable.\label{chunk:stats:fm3}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{2}\hlstd{),} \hlkwc{data} \hlstd{= cars)}
\hlkwd{plot}\hlstd{(fm3,} \hlkwc{which} \hlstd{=} \hlnum{3}\hlstd{)}
\hlkwd{summary}\hlstd{(fm3)}
\end{alltt}
\end{kframe}
\end{knitrout}

The ``same'' fit using an orthogonal polynomial can be specified using function \Rfunction{poly()}. Polynomials of different degrees can be obtained by supplying as the second argument to \Rfunction{poly()} the corresponding positive integer value. In this case, the different terms of the polynomial are bulked together in the summary.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3a} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlkwd{poly}\hlstd{(speed,} \hlnum{2}\hlstd{),} \hlkwc{data} \hlstd{= cars)}
\hlkwd{summary}\hlstd{(fm3a)}
\end{alltt}
\end{kframe}
\end{knitrout}

It is possible to compare two model fits using \Rfunction{anova()}, testing whether one of the models describes the data better than the other. It is important in this case to take into consideration the nature of the difference between the model formulas, most importantly if they can be interpreted as nested---i.e., interpreted as a base model vs. the same model with additional terms.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2, fm1)}
\end{alltt}
\end{kframe}
\end{knitrout}

Three or more models can also be compared in a single call to \Rfunction{anova()}. However, care is needed, as the order of the arguments matters.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm2, fm3, fm3a)}
\hlkwd{anova}\hlstd{(fm2, fm3a, fm3)}
\end{alltt}
\end{kframe}
\end{knitrout}

\label{par:stats:AIC}%
\index{Akaike's An Information Criterion@Akaike's \emph{An Information Criterion}}%
\index{AIC|see{\emph{An Information Criterion}}}%
\index{Bayesian Information Criterion@\emph{Bayesian Information Criterion}}%
\index{BIC|see{\emph{Bayesian Information Criterion}}}%
\index{Schwarz's Bayesian Criterion@Schwarz's \emph{Bayesian criterion}|see{\emph{Bayesian Information Criterion}}}%
Different criteria can be used to choose the ``best'' model: significance based on $p$-values or information criteria (AIC, BIC). AIC (Akaike's ``An Information Criterion'') and BIC (``Bayesian Information Criterion'' = SBC, ``Schwarz's Bayesian criterion'') that penalise the resulting ``goodness'' based on the number of parameters in the fitted model. In the case of AIC and BIC, a smaller value is better, and values returned can be either positive or negative, in which case more negative is better. Estimates for both BIC and AIC are returned by \Rfunction{anova()}, and on their own by \Rfunction{BIC()} and \Rfunction{AIC()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{BIC}\hlstd{(fm2, fm1, fm3, fm3a)}
\hlkwd{AIC}\hlstd{(fm2, fm1, fm3, fm3a)}
\end{alltt}
\end{kframe}
\end{knitrout}

Once you have run the code in the chunks above, you will be able see that these three criteria do not necessarily agree on which is the ``best'' model. Find in the output $P$-value, BIC and AIC estimates, for the different models and conclude which model is favoured by each of the three criteria. In addition, you will notice that the two different formulations of the quadratic polynomial are equivalent.

\end{playground}

Additional query methods give easy access to different aspects of fitted models: \Rfunction{vcov()} returns the variance-covariance matrix, \Rfunction{coef()} and its alias \Rfunction{coefficients()} return the estimates for the fitted model coefficients, \Rfunction{fitted()} and its alias \Rfunction{fitted.values()} extract the fitted values, and \Rfunction{resid()} and its alias \Rfunction{residuals()} the corresponding residuals (or deviations) (Figure \ref{fig:lm:fit:query:more}). Less frequently used accessors are \Rfunction{getCall()}, \Rfunction{effects()}, \Rfunction{terms()}, \Rfunction{model.frame()}, and \Rfunction{model.matrix()}.

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model} $\to$ \code{formula}};
\node (data) [tprocess, below of=model, yshift = 0.4cm] {\textsl{observations} $\to$ \code{data}};
\node (weights) [tprocess, dashed, below of=data, fill=blue!1, yshift = 0.4cm] {\textsl{weights} $\to$ \code{weights}};
\node (fitfun) [tprocess, right of=data, xshift=2.5cm, fill=blue!5] {\code{lm()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.5cm, fill=blue!5] {\code{lm} \textsl{object}};
\node (fitted) [tprocess, color = black, right of=fm, xshift=1.7cm] {\code{fitted()}};
\node (resid) [tprocess, color = black, above of=fitted, yshift = -0.4cm] {\code{residuals()}};
\node (coef) [tprocess, color = black, above of=resid, yshift = -0.4cm] {\code{coef()}};
\node (aic) [tprocess, color = black, below of=fitted, yshift = 0.4cm] {\code{AIC()}; \code{BIC()}};
\node (predict) [tprocess, color = black, below of=aic, yshift = 0.4cm] {\code{predict()}};
\node (newdata) [tprocess, color = black, left of=predict, xshift = -2.4cm] {\textsl{expl.\ vars.} $\to$ \code{newdata}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow, dashed] (weights) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (coef);
\draw [arrow] (fm) -- (resid);
\draw [arrow] (fm) -- (fitted);
\draw [arrow] (fm) -- (aic);
\draw [arrow] (fm) -- (predict);
\draw [arrow] (newdata) -- (predict);
\end{tikzpicture}
\end{small}
  \caption[Linear model fitting, more query methods ]{Diagram including additional methods used to query fitted model objects using linear models as an example. For other details see the legend of Figure \ref{fig:lm:fit:diagram}.}\label{fig:lm:fit:query:more}
\end{figure}

\begin{playground}
Familiarise yourself with these extraction and summary methods by reading their documentation and use them to explore \code{fm1} fitted above or model fits to other data of your interest.
\end{playground}

It is usual\index{linear models!structure of summary object} to only look at the values returned by \Rfunction{anova()} and \Rfunction{summary()} as implicitly displayed by \code{print()}. However, both \Rfunction{anova()} and \Rfunction{summary()} return complex objects, derived from \code{list}, containing some members not displayed by \code{print()}. Access to members of these objects can be necessary to use them in further calculations or to print them in a format different to the default.

\begin{explainbox}\label{box:LM:fit:summary:object}
The class and structure of the objects returned by \Rmethod{summary()} depends on the class of the model fit object, i.e., \Rmethod{summary()} is a generic method with multiple specialisations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{summary}\hlstd{(fm1))}
\end{alltt}
\begin{verbatim}
## [1] "summary.lm"
\end{verbatim}
\end{kframe}
\end{knitrout}

One case where we need to extract individual members is when adding annotations to plots. Another case is when writing reports to include programmatically the computed values within the text. \Rfunction{str()} can be used to display the structure. Calling \Rfunction{str()} with \code{no.list = TRUE}, \code{give.attr = FALSE} and \code{vec.len = 2} as arguments restricts the output to an overview of the structure of \code{fm1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(}\hlkwd{summary}\hlstd{(fm1),} \hlkwc{no.list} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{give.attr} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{vec.len} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  $ call         : language lm(formula = dist ~ 1 + speed, data = cars)
##  $ terms        :Classes 'terms', 'formula'  language dist ~ 1 + speed
##  $ residuals    : Named num [1:50] 3.85 11.85 ...
##  $ coefficients : num [1:2, 1:4] -17.58 3.93 ...
##  $ aliased      : Named logi [1:2] FALSE FALSE
##  $ sigma        : num 15.4
##  $ df           : int [1:3] 2 48 2
##  $ r.squared    : num 0.651
##  $ adj.r.squared: num 0.644
##  $ fstatistic   : Named num [1:3] 89.6 1 ...
##  $ cov.unscaled : num [1:2, 1:2] 0.1931 -0.0112 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

Extraction of members follows the usual \Rlang rules using \Roperator{\$}, \Roperator{[ ]}, or \Roperator{[[ ]]}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm1)}\hlopt{$}\hlstd{adj.r.squared}
\end{alltt}
\begin{verbatim}
## [1] 0.6438102
\end{verbatim}
\end{kframe}
\end{knitrout}

Estimates of \code{coefficients} are accompanied by estimates of their standard errors, \emph{t}-values and \emph{P}-values, while in the model object \code{fm1} these are not included.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{coef}\hlstd{(fm1)}
\end{alltt}
\begin{verbatim}
## (Intercept)       speed 
##  -17.579095    3.932409
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(fm1}\hlopt{$}\hlstd{coefficients)}
\end{alltt}
\begin{verbatim}
##  Named num [1:2] -17.58 3.93
##  - attr(*, "names")= chr [1:2] "(Intercept)" "speed"
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(}\hlkwd{summary}\hlstd{(fm1)}\hlopt{$}\hlstd{coefficients)}
\end{alltt}
\begin{verbatim}
##               Estimate Std. Error   t value     Pr(>|t|)
## (Intercept) -17.579095  6.7584402 -2.601058 1.231882e-02
## speed         3.932409  0.4155128  9.463990 1.489836e-12
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(}\hlkwd{summary}\hlstd{(fm1)}\hlopt{$}\hlstd{coefficients)}
\end{alltt}
\begin{verbatim}
##  num [1:2, 1:4] -17.579 3.932 6.758 0.416 -2.601 ...
##  - attr(*, "dimnames")=List of 2
##   ..$ : chr [1:2] "(Intercept)" "speed"
##   ..$ : chr [1:4] "Estimate" "Std. Error" "t value" "Pr(>|t|)"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{explainbox}\label{box:LM:anova:object}
The class of the object returned by method \code{anova()} does not depend on the class of the model fit object, while its structure does depend.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm1)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: dist
##           Df Sum Sq Mean Sq F value   Pr(>F)    
## speed      1  21186 21185.5  89.567 1.49e-12 ***
## Residuals 48  11354   236.5                     
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{anova}\hlstd{(fm1))}
\end{alltt}
\begin{verbatim}
## [1] "anova"      "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(}\hlkwd{anova}\hlstd{(fm1))}
\end{alltt}
\begin{verbatim}
## Classes 'anova' and 'data.frame':	2 obs. of  5 variables:
##  $ Df     : int  1 48
##  $ Sum Sq : num  21185 11354
##  $ Mean Sq: num  21185 237
##  $ F value: num  89.6 NA
##  $ Pr(>F) : num  1.49e-12 NA
##  - attr(*, "heading")= chr [1:2] "Analysis of Variance Table\n" "Response: dist"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{explainbox}\label{box:stats:slope:ttest}
As\index{linear models!ad-hoc tests for parameters}\index{t-test@$t$-test|(}\index{calibration curves} an example of the use of values extracted from the \code{summary.lm} object, I show how to test if the slope from a linear regression fit deviates significantly from a constant value different from the usual zero, which tests for the presence of an ``effect'' of the explanatory variable. When testing for deviations from a calibration by comparing two instruments or an instrument and a reference, a null hypothesis of one for the slope tests for deviations from the true readings. In some cases, when comparing the effectiveness of interventions we may be interested to test if a new approach surpasses that in current use by at least a specific margin. There exist practical situations where testing if a response exceeds a threshold is of interest.

A \emph{t}-value can be computed for the slope as for the mean. When using \Rfunction{anova()} and \Rfunction{summary()} the null hypothesis is no effect or no response, i.e., slope = 0. The equivalent test with a null hypothesis of slope = 1 is easy to implement if we consider how we calculate a $t$-value (see section \ref{sec:stats:ttest} on page \pageref{sec:stats:ttest}). To compute the \emph{t}-value we need an estimate for the slope and an estimate of its standard error. To look up the $P$-value, we need the degrees of freedom. All these values are available as members of the summary object of a fitted model.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{est.slope.value} \hlkwb{<-} \hlkwd{summary}\hlstd{(fm1)}\hlopt{$}\hlstd{coefficients[}\hlstr{"speed"}\hlstd{,} \hlstr{"Estimate"}\hlstd{]}
\hlstd{est.slope.se} \hlkwb{<-} \hlkwd{summary}\hlstd{(fm1)}\hlopt{$}\hlstd{coefficients[}\hlstr{"speed"}\hlstd{,} \hlstr{"Std. Error"}\hlstd{]}
\hlstd{degrees.of.freedom} \hlkwb{<-} \hlkwd{summary}\hlstd{(fm1)}\hlopt{$}\hlstd{df[}\hlnum{2}\hlstd{]}
\end{alltt}
\end{kframe}
\end{knitrout}

The estimate of the $t$-value, or quantile, is computed based on the difference between the estimate for the slope and a null hypothesis used as reference, and the standard error of the estimated slope. A probability is obtained based on the computed $t$-value, or quantile, and the $t$ distribution with matching degrees of freedom with a call to \Rfunction{pt()} (see section \ref{sec:prob:dist} on page \pageref{sec:prob:dist}.) For a two-tail test we multiply by two the one-tail $P$ estimate.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hyp.null} \hlkwb{<-} \hlnum{1}
\hlstd{t.value} \hlkwb{<-} \hlstd{(est.slope.value} \hlopt{-} \hlstd{hyp.null)} \hlopt{/} \hlstd{est.slope.se}
\hlstd{p.value} \hlkwb{<-} \hlnum{2} \hlopt{*} \hlkwd{pt}\hlstd{(}\hlkwc{q} \hlstd{= t.value,} \hlkwc{df} \hlstd{= degrees.of.freedom,} \hlkwc{lower.tail} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\hlkwd{cat}\hlstd{(}\hlstr{"slope ="}\hlstd{,} \hlkwd{signif}\hlstd{(est.slope.value,} \hlnum{3}\hlstd{),}
    \hlstr{"with s.e. ="}\hlstd{,} \hlkwd{signif}\hlstd{(est.slope.se,} \hlnum{3}\hlstd{),}
    \hlstr{"\textbackslash{}nt.value ="}\hlstd{,} \hlkwd{signif}\hlstd{(t.value,} \hlnum{3}\hlstd{),}
    \hlstr{"and P-value ="}\hlstd{,} \hlkwd{signif}\hlstd{(p.value,} \hlnum{3}\hlstd{))}
\end{alltt}
\begin{verbatim}
## slope = 3.93 with s.e. = 0.416 
## t.value = 7.06 and P-value = 6.01e-09
\end{verbatim}
\end{kframe}
\end{knitrout}

This example is for a linear model fitted with function \Rfunction{lm()} but the same approach can be applied to other model fit procedures for which parameter estimates and their corresponding standard error estimates can be extracted or computed.
\end{explainbox}

\begin{advplayground}
Check that the computations above after replacing \code{hyp.null <- 1} by \code{hyp.null <- 0} agree with the output of printing \code{summary()}.

Modify the example above so as to test whether the intercept is significantly larger than 5 feet, doing a one-sided test.

\end{advplayground}
\index{t-test@$t$-test|)}

Method \Rfunction{predict()} uses the fitted model together with new data for the independent variables to compute predictions. As \Rfunction{predict()} accepts new data as input, it allows interpolation and extrapolation to values of the independent variables not present in the original data. In the case of fits of linear and some other models, method \Rfunction{predict()} returns, in addition to the prediction, estimates of the confidence and/or prediction intervals. The new data must be stored in a data frame with columns using the same names for the explanatory variables as in the data used for the fit, a response variable is not needed and additional columns are ignored. (The explanatory variables in the new data can be either continuous or factors, but they must match in this respect those in the original data.)

\begin{playground}
Predict using both \code{fm1} and \code{fm2} the distance required to stop cars moving at 0, 5, 10, 20, 30, and 40~mph. Study the help page for the \Rfunction{predict()} method for linear models (using \code{help(predict.lm)}). Explore the difference between \code{"prediction"} and \code{"confidence"} bands: why are they so different?
\end{playground}
\index{linear models!linear regression|)}%

\begin{explainbox}\label{box:LM:fit:object}
The\index{linear models!structure of model fit object} objects returned by model fitting functions contain the full information, including the data to which the model was fit to. Their structure resembles a nested list. In most cases, the class of the objects returned by model fit functions agrees in name with the name of the function (\code{"lm"} in this example) but is not derived from \code{"list"}. The query functions, either extract parts of the object or do additional calculations and formatting based on them. Different specialisations of these methods are called depending on the class of the model fit object. (See section \ref{sec:methods} on page \pageref{sec:methods}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(fm1)}
\end{alltt}
\begin{verbatim}
## [1] "lm"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(fm1)}
\end{alltt}
\begin{verbatim}
##  [1] "coefficients"  "residuals"     "effects"       "rank"         
##  [5] "fitted.values" "assign"        "qr"            "df.residual"  
##  [9] "xlevels"       "call"          "terms"         "model"
\end{verbatim}
\end{kframe}
\end{knitrout}

The structure of model fit objects is of interest only when the query or accessor functions do not provide the needed information and components have to be extracted using operator \Roperator{[[ ]]}. Exploring these objects is also a way of learning how model fitting works in \Rlang. As with any other objects, \Rfunction{str()} shows the structure.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(fm1,} \hlkwc{no.list} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{give.attr} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{vec.len} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  $ coefficients : Named num [1:2] -17.58 3.93
##  $ residuals    : Named num [1:50] 3.85 11.85 ...
##  $ effects      : Named num [1:50] -304 146 ...
##  $ rank         : int 2
##  $ fitted.values: Named num [1:50] -1.85 -1.85 ...
##  $ assign       : int [1:2] 0 1
##  $ qr           :List of 5
##   ..$ qr   : num [1:50, 1:2] -7.071 0.141 ...
##   ..$ qraux: num [1:2] 1.14 1.27
##   ..$ pivot: int [1:2] 1 2
##   ..$ tol  : num 1e-07
##   ..$ rank : int 2
##  $ df.residual  : int 48
##  $ xlevels      : Named list()
##  $ call         : language lm(formula = dist ~ 1 + speed, data = cars)
##  $ terms        :Classes 'terms', 'formula'  language dist ~ 1 + speed
##  $ model        :'data.frame':	50 obs. of  2 variables:
##   ..$ dist : num [1:50] 2 10 4 22 16 ...
##   ..$ speed: num [1:50] 4 4 7 7 8 ...
\end{verbatim}
\end{kframe}
\end{knitrout}

Member \code{call} contains the function call and arguments used to create object \code{fm1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(fm1}\hlopt{$}\hlstd{call)}
\end{alltt}
\begin{verbatim}
##  language lm(formula = dist ~ 1 + speed, data = cars)
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\subsection{Analysis of variance, ANOVA}\label{sec:anova}
%\index{analysis of variance}
\index{analysis of variance|see{linear models, analysis of variance}}%
\index{ANOVA|see{linear models, analysis of variance}}%
\index{linear models!analysis of variance|(}%
In ANOVA, the explanatory variable is categorical, and in \Rlang, must be a \code{factor} or \code{ordered} factor (see section \ref{sec:calc:factors} on page \pageref{sec:calc:factors}). As a linear model, the fitting approach is the same as for linear and polynomial regression (Figure \ref{fig:lm:fit:diagram}).
The \Rdata{InsectSprays} data set used in the next example gives insect counts in plots sprayed with different insecticides. In these data, \code{spray} is a factor with six levels.%
\label{xmpl:fun:lm:fm4}

What determines that this is an ANOVA is that \code{spray}, the explanatory variable, is a \code{factor}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(InsectSprays)}
\hlkwd{is.numeric}\hlstd{(InsectSprays}\hlopt{$}\hlstd{spray)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.factor}\hlstd{(InsectSprays}\hlopt{$}\hlstd{spray)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{levels}\hlstd{(InsectSprays}\hlopt{$}\hlstd{spray)}
\end{alltt}
\begin{verbatim}
## [1] "A" "B" "C" "D" "E" "F"
\end{verbatim}
\end{kframe}
\end{knitrout}

By using a factor instead of a numeric vector, a different model matrix is built from an equivalent formula.\label{chunk:stat:fm4}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm4} \hlkwb{<-} \hlkwd{lm}\hlstd{(count} \hlopt{~} \hlstd{spray,} \hlkwc{data} \hlstd{= InsectSprays)}
\end{alltt}
\end{kframe}
\end{knitrout}

Diagnostic plots are obtained in the same way as for linear regression. We show only the quantile-quantile plot for simplicity, but during data analysis it is very important to check all the diagnostics plots. As many of the residuals deviate from the one-to-one line we have to conclude the residuals do not follow the Normal distribution, and a different approach to model fitting should be used (see section \ref{sec:stat:GLM} on page \pageref{sec:stat:GLM}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(fm4,} \hlkwc{which} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-model-6a-1} 

}


\end{knitrout}

In ANOVA,\index{F-test@$F$-test} most frequently the interest is in testing hypotheses with function \Rfunction{anova()}, which implements the $F$-test for the main effects of factors and their interactions. In this example, with a single explanatory variable, there is only one effect of interest, that of \code{sprays}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm4)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: count
##           Df Sum Sq Mean Sq F value    Pr(>F)    
## spray      5 2668.8  533.77  34.702 < 2.2e-16 ***
## Residuals 66 1015.2   15.38                      
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{models!contrasts|(}
\begin{warningbox}
Function \Rfunction{summary()} can be used to extract parameter estimates informing of the size of the effects, but meaningfully only by using contrasts different to the default ones.
Function \Rfunction{aov()} is a wrapper on \Rfunction{lm()} that returns an object that by default displays the output of \Rfunction{anova()} also with \Rfunction{summary()}, but even in this case it can be preferable to change the default contrasts (see \code{help(aov)}).

The contrasts used affect the estimates returned by \Rfunction{coef()} and \Rfunction{summary()} applied to an ANOVA model fit. The default used in \Rlang, \Rfunction{contr.treatment()}, is different to that used in \Slang, \Rfunction{contr.helmert}. With \Rfunction{contr.treatment} the first level of the factor (assumed to be a control) is used as a reference for the estimation of coefficients for the remaining factor levels and testing of their significance. With \Rfunction{contr.helmert} the contrasts are of the second level with the first, the third with the average of the first two, and so on. These contrasts depend on the order of factor levels. Instead, \code{contr.sum} uses as reference the mean of all levels, i.e., using as a condition that the coefficient estimates add up to zero. Obviously what type of contrast is used changes what the coefficient estimates describe, and, consequently, how the $p$-values should be interpreted.
\end{warningbox}

\begin{explainbox}
The approach used by default for model fits and ANOVA calculations varies among programs. There exist different so-called ``types'' of sums of squares, usually called I, II, and III. In orthogonal designs, the choice is of no consequence, but differences can be important for unbalanced designs, even leading to different conclusions. \Rlang's default, type~I, is usually considered to suffer milder problems than type~III, the default used by \pgrmname{SPSS} and \pgrmname{SAS}. In any case, for unbalanced data it is preferable to use the approach implemented in package \pkgname{nlme}.
\end{explainbox}

\begin{explainbox}
The most straightforward way of setting a different default for contrasts for a whole series of model fits is by setting \Rlang option \code{contrasts}, which we here only print.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{options}\hlstd{(}\hlstr{"contrasts"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## $contrasts
##         unordered           ordered 
## "contr.treatment"      "contr.poly"
\end{verbatim}
\end{kframe}
\end{knitrout}

The option is set to a named character vector of length two, with the first value, named \code{unordered} giving the name of the function used when the explanatory variable is an unordered \code{factor} (created with \Rfunction{factor()}) and the second value, named \code{ordered}, giving the name of the function used when the explanatory variable is an \code{ordered} factor (created with \Rfunction{ordered()}).

It is also possible to select the contrast to be used in the call to \code{aov()} or \code{lm()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm4trea} \hlkwb{<-} \hlkwd{lm}\hlstd{(count} \hlopt{~} \hlstd{spray,} \hlkwc{data} \hlstd{= InsectSprays,}
              \hlkwc{contrasts} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{spray} \hlstd{= contr.treatment))}
\hlstd{fm4sum}  \hlkwb{<-} \hlkwd{lm}\hlstd{(count} \hlopt{~} \hlstd{spray,} \hlkwc{data} \hlstd{= InsectSprays,}
              \hlkwc{contrasts} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{spray} \hlstd{= contr.sum))}
\end{alltt}
\end{kframe}
\end{knitrout}

In \code{fm4trea} we used \Rfunction{contr.treatment()}, thus contrasts for individual treatments are done against \code{Spray1} taking it as the control or reference, as can be inferred from the generated contrasts matrix. For this reason, there is no row for \code{Spray1} in the summary table. Each of the rows \code{Spray2} to \code{Spray6} is a test comparing these treatments individually against \code{Spray1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{contr.treatment}\hlstd{(}\hlkwd{length}\hlstd{(}\hlkwd{levels}\hlstd{(InsectSprays}\hlopt{$}\hlstd{spray)))}
\end{alltt}
\begin{verbatim}
##   2 3 4 5 6
## 1 0 0 0 0 0
## 2 1 0 0 0 0
## 3 0 1 0 0 0
## 4 0 0 1 0 0
## 5 0 0 0 1 0
## 6 0 0 0 0 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm4trea)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = count ~ spray, data = InsectSprays, contrasts = list(spray = contr.treatment))
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -8.333 -1.958 -0.500  1.667  9.333 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)  14.5000     1.1322  12.807  < 2e-16 ***
## sprayB        0.8333     1.6011   0.520    0.604    
## sprayC      -12.4167     1.6011  -7.755 7.27e-11 ***
## sprayD       -9.5833     1.6011  -5.985 9.82e-08 ***
## sprayE      -11.0000     1.6011  -6.870 2.75e-09 ***
## sprayF        2.1667     1.6011   1.353    0.181    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 3.922 on 66 degrees of freedom
## Multiple R-squared:  0.7244,	Adjusted R-squared:  0.7036 
## F-statistic:  34.7 on 5 and 66 DF,  p-value: < 2.2e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

In \code{fm4sum} we used \Rfunction{contr.sum()} with the sum constrained to be zero, thus estimates for the last treatment level are determined by the sum of the previous ones, and not tested for significance.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{contr.sum}\hlstd{(}\hlkwd{length}\hlstd{(}\hlkwd{levels}\hlstd{(InsectSprays}\hlopt{$}\hlstd{spray)))}
\end{alltt}
\begin{verbatim}
##   [,1] [,2] [,3] [,4] [,5]
## 1    1    0    0    0    0
## 2    0    1    0    0    0
## 3    0    0    1    0    0
## 4    0    0    0    1    0
## 5    0    0    0    0    1
## 6   -1   -1   -1   -1   -1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm4sum)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = count ~ spray, data = InsectSprays, contrasts = list(spray = contr.sum))
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -8.333 -1.958 -0.500  1.667  9.333 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)   9.5000     0.4622  20.554  < 2e-16 ***
## spray1        5.0000     1.0335   4.838 8.22e-06 ***
## spray2        5.8333     1.0335   5.644 3.78e-07 ***
## spray3       -7.4167     1.0335  -7.176 7.87e-10 ***
## spray4       -4.5833     1.0335  -4.435 3.57e-05 ***
## spray5       -6.0000     1.0335  -5.805 2.00e-07 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 3.922 on 66 degrees of freedom
## Multiple R-squared:  0.7244,	Adjusted R-squared:  0.7036 
## F-statistic:  34.7 on 5 and 66 DF,  p-value: < 2.2e-16
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

\begin{advplayground}
  Explore how taking the last level as reference in \Rfunction{contr.SAS()} instead of the first one as in \Rfunction{contr.treatment()} affects the estimates. Reorder the levels of factor \code{spray} so that the test using \Rfunction{contr.SAS()} becomes equivalent to that obtained above with \Rfunction{contr.treatment()}. Consider why \Rfunction{contr.poly()} is the default for ordered factors and when \Rfunction{contr.helmert()} could be  most useful.
\end{advplayground}

Contrasts, on the other hand, do not affect the table returned by \Rfunction{anova()} as this table does not deal with the effects of individual factor levels. The overall estimates shown at the bottom of the summary table remain unchanged. In other words, when using different contrasts what changes is how the total variation explained by the fitted model is partitioned into components to be tested for specific contributions to the overall model fit.

\begin{explainbox}
\index{tests!adjusted P-values@{adjusted $P$-values}}%
  Post-hoc tests based on specific contrasts\index{tests!post-hoc} and multiple comparisons\index{tests!multiple comparisons} tests are most frequently applied after an ANOVA to test for differences among pairs of treatments or specific combinations of treatments. \Rlang function \Rfunction{Tukey.test()} implements Tukey's HSD\index{tests!Tukey's HSD} (honestly significant difference) test for pairwise tests. Function \Rfunction{pairwise.t.test()} supports different correction methods for the $P$-values from simultaneous $t$-tests. Function \Rfunction{p.adjust()} applies adjustments to $P$-values and can be used when the test procedure does not apply them. The most comprehensive implementation of multiple comparisons is available in package \pkgname{multcomp}. Function \Rfunction{glht()} (general linear hypothesis testing) from this package supports different contrasts and adjustment methods.
\end{explainbox}

Contrasts and their interpretation are discussed in detail by \citeauthor{Venables2002} (\citeyear{Venables2002}) and \citeauthor{Crawley2012} (\citeyear{Crawley2012}).
\index{models!contrasts|)}
\index{linear models!analysis of variance|)}%

\subsection{Analysis of covariance, ANCOVA}
%\index{analysis of covariance}
\index{analysis of covariance|see{linear models, analysis of covariance}}
\index{linear models!analysis of covariance}
\index{ANCOVA|see{linear models, analysis of covariance}}

When a linear model includes both explanatory factors and continuous explanatory variables, we may call it \emph{analysis of covariance} (ANCOVA). The formula syntax is the same for all linear models and, as mentioned in previous sections, what determines the type of analysis is the nature of the explanatory variable(s). As the formulation remains the same, no specific example is given. The main difficulty of ANCOVA is in the selection of the covariate and the interpretation of the results of the analysis, especially, when the covariate is not independent of the treatment described by the factor \autocite[e.g.][]{Smith1957}.
\index{linear models|)}

\subsection{Model update and selection}\label{sec:stat:update:step}
\index{models!updating|(}
Model fit objects can be updated, i.e., modified, because they contain not only the results of the fit but also the data to which the model was fit (see page \pageref{box:LM:fit:object}). Given that the call is also stored, all the information needed to recalculate the same fit is available. Method \Rfunction{update()} makes it possible to recalculate the fit with changes to the call, without passing again all the arguments to a new call to \Rfunction{lm()} (Figure \ref{fig:lm:update:diagram}). We can modify different arguments, including selecting part of the data by passing a new argument to formal parameter \code{subset}.

\begin{figure}
  \centering
 \begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model}};
\node (data) [tprocess, below of=model, yshift=-0.4cm] {\textsl{observations}};
\node (fitfun) [tprocess, right of=model, yshift=-0.9cm, xshift=1cm] {\code{lm()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.8cm] {\code{lm} \textsl{object} $\to$ \code{object}};
\node (update) [tprocess, color = black, right of=fm, xshift = 1.8cm, fill=blue!5] {\code{update()}};
\node (newmodel) [tprocess, above of=fm, fill=blue!5, yshift=-0.3cm] {\textsl{new model} $\to$ \code{formula}};
\node (newdata) [tprocess, below of=fm, fill=blue!5, yshift=0.3cm] {\textsl{new observs.} $\to$ \code{data}};
\node (newfm) [tprocess, color = black, right of=update, xshift=1.5cm, fill=blue!5] {\code{lm} \textsl{object}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (update);
\draw [arrow] (newmodel) -- (update);
\draw [arrow] (newdata) -- (update);
\draw [arrow] (update) -- (newfm);
\end{tikzpicture}
\end{small}
  \caption[Updating a fitted model]{Diagram showing the steps for updating a fitted model (in filled boxes) together with the previous steps in unfilled boxes. Please, see Figure \ref{fig:lm:fit:diagram} for other details.}\label{fig:lm:update:diagram}
\end{figure}

Method \Rfunction{update()} retrieves the call from the model fit object using \Rfunction{getCall()}, modifies it and, by default, evaluates it. The default \Rfunction{update()} method works as long as the model-fit object contains a member named \code{call} or if a specialisation of \Rfunction{getCall()} is available. Thus, method \Rfunction{update()} can be used with models fitted with other functions in addition to \Rfunction{lm()}.

For the next example, we recreate the model fit object \code{fm4} from page \pageref{chunk:stat:fm4}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm4} \hlkwb{<-} \hlkwd{lm}\hlstd{(count} \hlopt{~} \hlstd{spray,} \hlkwc{data} \hlstd{= InsectSprays)}
\hlkwd{anova}\hlstd{(fm4)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: count
##           Df Sum Sq Mean Sq F value    Pr(>F)    
## spray      5 2668.8  533.77  34.702 < 2.2e-16 ***
## Residuals 66 1015.2   15.38                      
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\begin{alltt}
\hlstd{fm4a} \hlkwb{<-} \hlkwd{update}\hlstd{(fm4,} \hlkwc{formula} \hlstd{=} \hlkwd{log10}\hlstd{(count} \hlopt{+} \hlnum{1}\hlstd{)} \hlopt{~} \hlstd{spray)}
\hlkwd{anova}\hlstd{(fm4a)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: log10(count + 1)
##           Df Sum Sq Mean Sq F value    Pr(>F)    
## spray      5 7.2649 1.45297  46.007 < 2.2e-16 ***
## Residuals 66 2.0844 0.03158                      
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Print \code{fm4\$call} and \code{fm4a\$call}. These two calls differ in the argument to \code{formula}. What other members have been updated in \code{fm4a} compared to \code{fm4}?
\end{playground}

In the chunk above we replaced the argument passed to \code{formula}. This is a frequent use, but, for example, to fit the same model to a subset of the data, we can pass a suitable argument to parameter \code{subset}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm4b} \hlkwb{<-} \hlkwd{update}\hlstd{(fm4,} \hlkwc{subset} \hlstd{=} \hlopt{!}\hlstd{spray} \hlopt{%in%} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\hlkwd{anova}\hlstd{(fm4b)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
## Response: count
##           Df Sum Sq Mean Sq F value    Pr(>F)    
## spray      3 1608.4  536.14  41.422 7.119e-13 ***
## Residuals 44  569.5   12.94                      
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
When having many treatments with long names, which is not the case here, instead of listing the factor levels for which to subset the data, it can be convenient to use regular expressions for pattern matching (see section \ref{sec:calc:regex} on page \pageref{sec:calc:regex}). Run the code below, and investigate why \code{anova(fm4b)} and \code{anova(fm4c)} produce the same ANOVA table printout, but the fit model objects are not identical. You can use \code{str()} to explore if any members differ between the two objects.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm4c} \hlkwb{<-} \hlkwd{update}\hlstd{(fm4,} \hlkwc{subset} \hlstd{=} \hlopt{!}\hlkwd{grepl}\hlstd{(}\hlstr{"[AB]"}\hlstd{, spray))}
\hlkwd{anova}\hlstd{(fm4c)}
\hlkwd{identical}\hlstd{(fm4b, fm4c)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{advplayground}

\begin{explainbox}
Method \Rfunction{update()} plays an additional role when the fitting is done by numerical approximation, as the previously computed estimates are used as the starting values for the numerical calculations required for fitting the updated model (see section \ref{sec:stat:NLS} on page \pageref{sec:stat:NLS} as an example). This can drastically decrease computation time, or even easy the task of finding suitable starting values for parameter estimates by fitting increasingly more complex nested models.
\end{explainbox}

\index{models!updating|)}

\index{models!stepwise selection|(}\index{linear models!stepwise model selection|(}
Method \Rfunction{update()} used together with \Rfunction{AIC()} (or \Rfunction{anova()}) gives us the tools to compare nested models, and select one out of a group as shown above. When comparing several models doing the comparisons manually is tedious, and in scripts, in many cases difficult to write code that is flexible (or abstract) enough.  Method \Rfunction{step()} automates stepwise selection of nested models such as the selection among polynomials of different degrees or which variables to retain in multiple regression. After fitting a model, method \Rfunction{step()} is used to update this model using an automatic stopping criterion (Figure \ref{fig:lm:step:diagram}).

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model}};
\node (data) [tprocess, below of=model, yshift=-0.4cm] {\textsl{observations}};
\node (fitfun) [tprocess, right of=model, yshift=-0.9cm, xshift=1cm] {\code{lm()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.8cm] {\code{lm} \textsl{object} $\to$ \code{object}};
\node (step) [tprocess, color = black, right of=fm, xshift = 1.8cm, fill=blue!5] {\code{step()}};
\node (newmodels) [tprocess, dashed, above of=fm, fill=blue!5, yshift=-0.3cm] {\textsl{new model(s)} $\to$ \code{scope}};
\node (newfm) [tprocess, color = black, right of=update, xshift=1.5cm, fill=blue!5] {\code{lm} \textsl{object}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (update);
\draw [arrow, dashed] (newmodels) -- (step);
\draw [arrow] (step) -- (newfm);
\end{tikzpicture}
\end{small}
  \caption[Stepwise model selection]{Diagram showing the steps used for stepwise model selection among nested models (in filled boxes) together with the previous steps in unfilled boxes. The range of models to select from can be set by the user. See Figure \ref{fig:lm:fit:diagram} for other details.}\label{fig:lm:step:diagram}
\end{figure}

Stepwise model selection---either in the \emph{forward} direction from simpler to more complex models, in the backward direction from more complex to simpler models or in both directions---is implemented in base \Rlang's \emph{method} \Rfunction{step()} using Akaike's information criterion (AIC)\index{Akaike's An Information Criterion@Akaike's \emph{An Information Criterion}} as the selection criterion. Use of method \Rfunction{step()} from \Rlang is possible, for example, with \code{lm()} and \code{glm} fits. AIC is described on page \pageref{par:stats:AIC}.

For the next example, we use \code{fm3} from page \pageref{chunk:stats:fm3}, a linear model for a polynomial regression. If, as shown here, no models are passed through formal parameter \code{scope}, the previously fit model will be simplified, if possible. Method \Rfunction{step()} by default prints to the console a trace of the models tried and the corresponding AIC estimates.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3} \hlkwb{<-} \hlkwd{lm}\hlstd{(dist} \hlopt{~} \hlstd{speed} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{2}\hlstd{),} \hlkwc{data} \hlstd{= cars)}
\hlstd{fm3a} \hlkwb{<-} \hlkwd{step}\hlstd{(fm3)}
\end{alltt}
\begin{verbatim}
## Start:  AIC=274.88
## dist ~ speed + I(speed^2)
## 
##              Df Sum of Sq   RSS    AIC
## - speed       1     46.42 10871 273.09
## <none>                    10825 274.88
## - I(speed^2)  1    528.81 11354 275.26
## 
## Step:  AIC=273.09
## dist ~ I(speed^2)
## 
##              Df Sum of Sq   RSS    AIC
## <none>                    10871 273.09
## - I(speed^2)  1     21668 32539 325.91
\end{verbatim}
\end{kframe}
\end{knitrout}

Method \Rfunction{summary()} reveals the differences between the original and updated models.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm3)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ speed + I(speed^2), data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -28.720  -9.184  -3.188   4.628  45.152 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)
## (Intercept)  2.47014   14.81716   0.167    0.868
## speed        0.91329    2.03422   0.449    0.656
## I(speed^2)   0.09996    0.06597   1.515    0.136
## 
## Residual standard error: 15.18 on 47 degrees of freedom
## Multiple R-squared:  0.6673,	Adjusted R-squared:  0.6532 
## F-statistic: 47.14 on 2 and 47 DF,  p-value: 5.852e-12
\end{verbatim}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm3a)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ I(speed^2), data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -28.448  -9.211  -3.594   5.076  45.862 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)  8.86005    4.08633   2.168   0.0351 *  
## I(speed^2)   0.12897    0.01319   9.781  5.2e-13 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 15.05 on 48 degrees of freedom
## Multiple R-squared:  0.6659,	Adjusted R-squared:  0.6589 
## F-statistic: 95.67 on 1 and 48 DF,  p-value: 5.2e-13
\end{verbatim}
\end{kframe}
\end{knitrout}

If we pass a model with additional terms through parameter \code{scope} this model will be taken as the most complex model to be assessed. If, instead of one model, we pass two nested models in a list and name them \code{lower} and \code{upper}, they will delimit the scope of the stepwise search. In the next example, we see that first a backward search is done and term \code{speed} is removed because it removal decreases (= improves) AIC. Subsequently, a forward search is done unsuccessfully, as AIC increases.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3b} \hlkwb{<-}
  \hlkwd{step}\hlstd{(fm3,}
       \hlkwc{scope} \hlstd{= dist} \hlopt{~} \hlstd{speed} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{2}\hlstd{)} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{3}\hlstd{)} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{4}\hlstd{))}
\end{alltt}
\begin{verbatim}
## Start:  AIC=274.88
## dist ~ speed + I(speed^2)
## 
##              Df Sum of Sq   RSS    AIC
## - speed       1     46.42 10871 273.09
## <none>                    10825 274.88
## - I(speed^2)  1    528.81 11354 275.26
## + I(speed^4)  1    233.62 10591 275.79
## + I(speed^3)  1    190.35 10634 275.99
## 
## Step:  AIC=273.09
## dist ~ I(speed^2)
## 
##              Df Sum of Sq   RSS    AIC
## <none>                    10871 273.09
## + speed       1      46.4 10825 274.88
## + I(speed^3)  1       5.6 10866 275.07
## + I(speed^4)  1       0.0 10871 275.09
## - I(speed^2)  1   21667.8 32539 325.91
\end{verbatim}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm3b)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## lm(formula = dist ~ I(speed^2), data = cars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -28.448  -9.211  -3.594   5.076  45.862 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)  8.86005    4.08633   2.168   0.0351 *  
## I(speed^2)   0.12897    0.01319   9.781  5.2e-13 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 15.05 on 48 degrees of freedom
## Multiple R-squared:  0.6659,	Adjusted R-squared:  0.6589 
## F-statistic: 95.67 on 1 and 48 DF,  p-value: 5.2e-13
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Explain why the stepwise model selection in the code below differs from those in the two previous examples. Consult \code{help(step)} is necessary.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm3c} \hlkwb{<-}
  \hlkwd{step}\hlstd{(fm3,}
       \hlkwc{scope} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{lower} \hlstd{= dist} \hlopt{~} \hlstd{speed,}
                    \hlkwc{upper} \hlstd{= dist} \hlopt{~} \hlstd{speed} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{2}\hlstd{)} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{3}\hlstd{)} \hlopt{+} \hlkwd{I}\hlstd{(speed}\hlopt{^}\hlnum{4}\hlstd{)))}
\hlkwd{summary}\hlstd{(fm3c)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

Functions \Rfunction{update()} and \Rfunction{step()} are \emph{convenience functions} as they provide direct and/or simpler access to operations available through other functions or combined use of multiple functions.
\index{linear models!stepwise model selection|)}\index{models!stepwise selection|)}

\section{Generalised Linear Models}\label{sec:stat:GLM}
\index{generalised linear models|(}\index{models!generalised linear|see{generalised linear models}}
\index{GLM|see{generalised linear models}}

Linear models make the assumption of normally distributed residuals. Generalised linear models, fitted with function \Rfunction{glm()}, are more flexible, and allow the assumed distribution to be selected as well as the link function (defaults are as in \code{lm()}). Figure \ref{fig:glm:fit:diagram} shows that the steps used to fit a model with \Rfunction{glm()} are the same as with \code{lm()} except that we can select the probability distribution assumed to describe the variation among observations. Frequently used probability distributions are binomial and Poisson (see \code{help(family)} for the variations and additional ones).\index{models!for binomial outcomes data}\index{models!for counts data}

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model} $\to$ \code{formula}};
\node (data) [tprocess, below of=model, yshift = 0.4cm] {\textsl{observations} $\to$ \code{data}};
\node (weights) [tprocess, dashed, below of=data, fill=blue!1, yshift = 0.4cm] {\textsl{weights} $\to$ \code{weights}};
\node (family) [tprocess, below of=weights, fill=blue!5, yshift = 0.4cm] {\textsl{distribution} $\to$ \code{family}};
\node (fitfun) [tprocess, right of=data, xshift=2.5cm, yshift = -0.4cm,fill=blue!5] {\code{glm()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.5cm, fill=blue!5] {\code{glm} \textsl{object}};
\node (summary) [tprocess, color = black, right of=fm, xshift=1.7cm] {\code{summary()}};
\node (anova) [tprocess, color = black, below of=summary, yshift = 0.4cm] {\code{anova()}};
\node (plot) [tprocess, color = black, above of=summary, yshift = -0.4cm] {\code{plot()}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow, dashed] (weights) -- (fitfun);
\draw [arrow] (family) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (plot);
\draw [arrow] (fm) -- (anova);
\draw [arrow] (fm) -- (summary);
\end{tikzpicture}
\end{small}
  \caption[Generalised linear model fitting in \Rlang]{Generalised linear model fitting in \Rlang is done in steps similar to those used for linear models. Generic diagram from Figure \ref{fig:model:fit:diagram} redrawn to show a generalised linear model fit. Non-filled boxes are shared with fitting of other types of models, and filled ones are specific to \Rfunction{glm()}. Only the three most frequently used query methods are shown, while  both response and explanatory variables are under \textsl{observations}. Dashed boxes and arrows are optional as defaults are provided.}\label{fig:glm:fit:diagram}
\end{figure}

For count data, GLMs are preferred over LMs. In the example below, we fit the same model as above, but  assuming a quasi-Poisson distribution instead of the Normal. An argument passed to \code{family} selects the assumed error distribution. The \Rdata{InsectSprays} data set used in the next example, gives insect counts in plots sprayed with different insecticides. In these data, spray is a factor with six levels.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm10} \hlkwb{<-} \hlkwd{glm}\hlstd{(count} \hlopt{~} \hlstd{spray,} \hlkwc{data} \hlstd{= InsectSprays,} \hlkwc{family} \hlstd{= quasipoisson)}
\end{alltt}
\end{kframe}
\end{knitrout}

Method \Rfunction{plot()} as for linear-model fits, produces diagnosis plots. We show, as before, the quantile--quantile plot of residuals. The Normal distribution assumed above in the linear model fit was not a good approximation (section \ref{sec:anova} on page \pageref{sec:anova}), as count data are known to follow a different distribution. This is clear by comparing the quantile--quantile plot for \code{fm4} (page \pageref{sec:anova}) and the plot below for the model fit under the assumption of a Quasi-Poisson distribution.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(fm10,} \hlkwc{which} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-model-11-1} 

}


\end{knitrout}

The printout from the \Rfunction{anova()} method for GLM fits has some differences to that for LM fits. In \Rlang versions previous to 4.4.0, no test statistics or $P$-values were computed unless requested by passing an argument to parameter \code{test}. In later versions of \Rlang, either a chi-squared test or an $F$-test are computed by default depending on whether the dispersion is fixed or free. We here use \code{"F"} as an argument to request an $F$-test.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anova}\hlstd{(fm10,} \hlkwc{test} \hlstd{=} \hlstr{"F"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## Analysis of Deviance Table
## 
## Model: quasipoisson, link: log
## 
## Response: count
## 
## Terms added sequentially (first to last)
## 
## 
##       Df Deviance Resid. Df Resid. Dev      F    Pr(>F)    
## NULL                     71     409.04                     
## spray  5   310.71        66      98.33 41.216 < 2.2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

We can extract different components similarly as described for linear models (see section \ref{sec:stat:LM} on page \pageref{sec:stat:LM}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(fm10)}
\end{alltt}
\begin{verbatim}
## [1] "glm" "lm"
\end{verbatim}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm10)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## glm(formula = count ~ spray, family = quasipoisson, data = InsectSprays)
## 
## Coefficients:
##             Estimate Std. Error t value Pr(>|t|)    
## (Intercept)  2.67415    0.09309  28.728  < 2e-16 ***
## sprayB       0.05588    0.12984   0.430    0.668    
## sprayC      -1.94018    0.26263  -7.388 3.30e-10 ***
## sprayD      -1.08152    0.18499  -5.847 1.70e-07 ***
## sprayE      -1.42139    0.21110  -6.733 4.82e-09 ***
## sprayF       0.13926    0.12729   1.094    0.278    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for quasipoisson family taken to be 1.507713)
## 
##     Null deviance: 409.041  on 71  degrees of freedom
## Residual deviance:  98.329  on 66  degrees of freedom
## AIC: NA
## 
## Number of Fisher Scoring iterations: 5
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{residuals}\hlstd{(fm10))}
\end{alltt}
\begin{verbatim}
##          1          2          3          4          5          6 
## -1.2524891 -2.1919537  1.3650439 -0.1320721 -0.1320721 -0.6768988
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{fitted}\hlstd{(fm10))}
\end{alltt}
\begin{verbatim}
##    1    2    3    4    5    6 
## 14.5 14.5 14.5 14.5 14.5 14.5
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
If we use \code{str()} or \code{names()} we can see that there are some differences with respect to linear model fits. The returned object is of a different class and contains some members not present in linear models. Two of these have to do with the iterative approximation method used, \code{iter} contains the number of iterations used  and \code{converged} the success or not in finding a solution.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(fm10)}
\end{alltt}
\begin{verbatim}
## [1] "glm" "lm"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(fm10)}
\end{alltt}
\begin{verbatim}
##  [1] "coefficients"      "residuals"         "fitted.values"    
##  [4] "effects"           "R"                 "rank"             
##  [7] "qr"                "family"            "linear.predictors"
## [10] "deviance"          "aic"               "null.deviance"    
## [13] "iter"              "weights"           "prior.weights"    
## [16] "df.residual"       "df.null"           "y"                
## [19] "converged"         "boundary"          "model"            
## [22] "call"              "formula"           "terms"            
## [25] "data"              "offset"            "control"          
## [28] "method"            "contrasts"         "xlevels"
\end{verbatim}
\begin{alltt}
\hlstd{fm10}\hlopt{$}\hlstd{converged}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlstd{fm10}\hlopt{$}\hlstd{iter}
\end{alltt}
\begin{verbatim}
## [1] 5
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

Methods \code{update()} and \code{step()}, described for \code{lm()} in section \ref{sec:stat:update:step} on page \pageref{sec:stat:update:step}, can be also used with models fitted with \code{glm()}.

\index{generalised linear models|)}

\section{Non-Linear Regression}\label{sec:stat:NLS}
\index{non-linear models|(}%
\index{models!non-linear|see{non-linear models}}%
\index{NLS|see{non-linear models}}

By \emph{non-linear} it is meant non-linear \emph{in the parameters} whose values are being estimated through fitting the model to observations. This is different from the shape of the function when plotted---i.e., polynomials of any degree are linear models. In contrast, the Michaelis-Menten equation used in chemistry and the Gompertz equation used to describe growth are models that are non-linear in their parameters.

While analytical algorithms exist for finding estimates for the parameters of linear models, in the case of non-linear models, the estimates are obtained by approximation. For analytical solutions, estimates can always be obtained (except in pathological cases affected by the limitations of floating point numbers described on page \pageref{box:integer:float}). For approximations obtained through iteration, cases when the algorithm fails to \emph{converge} onto an answer are relatively common. Iterative algorithms attempt to improve an initial guess for the values of the parameters to be estimated, a guess frequently supplied by the user. In each iteration, the estimate obtained in the previous iteration is used as the starting value, and this process is repeated one time after another. The expectation is that after a finite number of iterations the algorithm will converge into a solution that ``cannot'' be improved further. In real life, we stop iteration when the improvement in the fit is smaller than a certain threshold, or when no convergence has been achieved after a certain maximum number of iterations. In the first case, we usually obtain good estimates; in the second case, we do not obtain usable estimates and need to look for different ways of obtaining them.

When convergence fails, the first thing to do is to try different starting values and if this also fails, switch to a different computational algorithm. These steps usually help, but not always. Good starting values are in many cases crucial and in some cases ``guesses'' can be obtained using either graphical or analytical approximations.

Function \Rfunction{nls()} is \Rlang's workhorse for fitting non-linear models. The steps for its use are similar to those for LM and GLM (Figure \ref{fig:nls:fit:diagram}). One difference is that starting values are needed, and another difference is in how the model to be fitted is specified: the user provides the names of the parameters and a model equation that includes in the \emph{rhs} a call to an \Rlang function.

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model} $\to$ \code{formula}};
\node (data) [tprocess, below of=model, yshift = 0.4cm] {\textsl{observations} $\to$ \code{data}};
\node (weights) [tprocess, dashed, below of=data, yshift = 0.4cm, fill=blue!1] {\textsl{weights} $\to$ \code{weights}};
\node (guess) [tprocess, below of=weights, fill=blue!5, yshift = 0.4cm] {\textsl{guesses} $\to$ \code{start}};
\node (fitfun) [tprocess, right of=data, xshift=2.5cm, yshift = -0.4cm, fill=blue!5] {\code{nls()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.5cm, fill=blue!5] {\code{nls} \textsl{object}};
\node (summary) [tprocess, color = black, right of=fm, xshift=1.7cm] {\code{summary()}};
\node (anova) [tprocess, color = black, below of=summary, yshift = 0.4cm] {\code{anova()}};
\node (plot) [tprocess, color = black, above of=summary, yshift = -0.4cm] {\code{plot()}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow, dashed] (weights) -- (fitfun);
\draw [arrow] (guess) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (plot);
\draw [arrow] (fm) -- (anova);
\draw [arrow] (fm) -- (summary);
\end{tikzpicture}
\end{small}
  \caption[Non-linear model fitting in \Rlang]{Non-linear model fitting in \Rlang is done in steps. Generic diagram from Figure \ref{fig:model:fit:diagram} redrawn to show a non-linear model fit. Non-filled boxes are shared with fitting of other types of models, and filled ones are specific to \Rfunction{nls()}. Only the three most frequently used query methods are shown, while  both response and explanatory variables are under \textsl{observations}. Dashed boxes and arrows are optional as defaults are provided.}\label{fig:nls:fit:diagram}
\end{figure}

In cases when algorithms exist for ``guessing'' suitable starting values, \Rlang provides a mechanism for packaging the \Rlang function to be fitted together with the \Rlang function generating the starting values. These functions go by the name of \emph{self-starting functions} and relieve the user from the burden of guessing and supplying suitable starting values. The\index{self-starting functions} self-starting functions available in \Rlang are \code{SSasymp()}, \code{SSasympOff()}, \code{SSasympOrig()}, \code{SSbiexp()}, \code{SSfol()}, \code{SSfpl()}, \code{SSgompertz()}, \code{SSlogis()}, \code{SSmicmen()}, and \code{SSweibull()}. Function \code{selfStart()} can be used to define new ones. All these functions can be used when fitting models with \Rfunction{nls} or \Rfunction{nlme}. The respective help pages give the details.

\begin{warningbox}
In calls to \Rfunction{nls()}, the rhs of the model \code{formula} is a function call. The names of its arguments if not present in \code{data} are assumed to be parameters to be fitted. Below, a named function
\end{warningbox}

As example the Michaelis-Menten equation\index{Michaelis-Menten equation} describing reaction kinetics\index{chemical reaction kinetics} in biochemistry and chemistry is fitted to the \Rdata{Puromycin} data set. The mathematical formulation is given by

\begin{equation}\label{eq:michaelis:menten}
v = \frac{\mathrm{d} [P]}{\mathrm{d} t} = \frac{V_{\mathrm{max}} [S]}{K_{\mathrm{M}} + [S]}
\end{equation}

\noindent
and is implemented in \Rlang under the name \Rfunction{SSmicmen()} as a self-starting function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(Puromycin)}
\hlkwd{names}\hlstd{(Puromycin)}
\end{alltt}
\begin{verbatim}
## [1] "conc"  "rate"  "state"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm21} \hlkwb{<-} \hlkwd{nls}\hlstd{(rate} \hlopt{~} \hlkwd{SSmicmen}\hlstd{(conc, Vm, K),} \hlkwc{data} \hlstd{= Puromycin,}
            \hlkwc{subset} \hlstd{= state} \hlopt{==} \hlstr{"treated"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

As for other fitted models we use query methods (see section \ref{sec:stat:LM} on page \pageref{sec:stat:LM}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(fm21)}
\end{alltt}
\begin{verbatim}
## [1] "nls"
\end{verbatim}
\begin{alltt}
\hlkwd{summary}\hlstd{(fm21)}
\end{alltt}
\begin{verbatim}
## 
## Formula: rate ~ SSmicmen(conc, Vm, K)
## 
## Parameters:
##     Estimate Std. Error t value Pr(>|t|)    
## Vm 2.127e+02  6.947e+00  30.615 3.24e-11 ***
## K  6.412e-02  8.281e-03   7.743 1.57e-05 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 10.93 on 10 degrees of freedom
## 
## Number of iterations to convergence: 0 
## Achieved convergence tolerance: 1.929e-06
\end{verbatim}
\begin{alltt}
\hlkwd{residuals}\hlstd{(fm21)}
\end{alltt}
\begin{verbatim}
##  [1]  25.4339971  -3.5660029  -5.8109605   4.1890395 -11.3616075   4.6383925
##  [7]  -5.6846886 -12.6846886   0.1670798  10.1670798   6.0311723  -0.9688277
## attr(,"label")
## [1] "Residuals"
\end{verbatim}
\begin{alltt}
\hlkwd{fitted}\hlstd{(fm21)}
\end{alltt}
\begin{verbatim}
##  [1]  50.5660  50.5660 102.8110 102.8110 134.3616 134.3616 164.6847 164.6847
##  [9] 190.8329 190.8329 200.9688 200.9688
## attr(,"label")
## [1] "Fitted values"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Methods \code{str()} and \code{names()} can reveal differences with respect to linear and generalised linear models. The fitted model object is of class \code{nls} contains additional members but lacks others. Two members are related to the iterative approximation method used, \code{control} containing nested members holding iteration settings, and \code{convInfo} (convergence information) with nested members with information on the outcome of the iterative algorithm.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(fm21)}
\end{alltt}
\begin{verbatim}
## [1] "nls"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(fm21)}
\end{alltt}
\begin{verbatim}
## [1] "m"           "convInfo"    "data"        "call"        "dataClasses"
## [6] "control"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fm21}\hlopt{$}\hlstd{convInfo}
\end{alltt}
\begin{verbatim}
## $isConv
## [1] TRUE
## 
## $finIter
## [1] 0
## 
## $finTol
## [1] 1.928554e-06
## 
## $stopCode
## [1] 0
## 
## $stopMessage
## [1] "converged"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

Method \code{update()}, described for \code{lm()} in section \ref{sec:stat:update:step} on page \pageref{sec:stat:update:step}, can be also used with models fitted with \code{nls()}. The use of previous estimates as guesses for updates is an important feature.

\index{non-linear models|)}

\section{Splines and Local Regression}\label{sec:stat:splines}
\index{smoothing splines|(}\index{local polynomial regression|(}%
\index{LOESS|see{local polynomial regression}}%
The name ``spline'' derives from the tool used by draftsmen to draw smooth curves. Originally, a spline of soft wood was used as a flexible guide to draw arbitrary curves. Later the wood splines were replaced by a rod of flexible metal, such as lead, encased in plastic or similar material but the original name persisted. In mathematics, splines are functions that describe smooth and flexible curves.

Most of the model fits given above as examples produce estimates for parameters that are interpretable in the real world, directly in the case of mechanistic models like the estimate of reaction constants or at least indicating broadly a relationship between two variables as in the case of linear regression. In the case of polynomials with degree higher than 2, parameter estimates no longer directly describe features of the data.

Splines take this a step farther and parameter estimates have no practical interest. The interest resides in the overall shape and position of the predicted curve. Splines consist of knots (or connection points) joined by straight or curved fitted lines, i.e., they are functions that are \emph{piecewise}. The simplest splines, are piece-wise linear, given by chained straight line segments connecting knots.

In more complex splines, the segments are polynomials, frequently cubic polynomials, that fulfil certain constraints at the knots. For example, that the slope or first derivative is the same for the two connected curve ``pieces'' at the knot where they are connected. This constraint ensures that the curve is smooth. In some cases, similar constraints are imposed on higher order derivatives, for example, to the second derivative to ensure that the curve of the first derivative is also smooth at the knots.

Splines are used in free-hand drawing with computers to draw arbitrary smooth curves. They are also be used for interpolation, in which case observations, assumed to be error-free, become the knots of a spline used to approximate intermediate values. Finally, splines can be used as models to be fit to observations subject to random variation. In this case splines fulfil the role of smoothers, as a curve that broadly describes a relationship among variables.

Splines are frequently used as smooth curves in plots as described in section \ref{sec:plot:smoothers} on page \pageref{sec:plot:smoothers}. Function \Rfunction{spline()} is used for interpolation and function \Rfunction{smooth.spline()} for smoothing by fitting a cubic spline (a spline where the knots are connected by third degree polynomials). Function \Rfunction{smooth.spline()} has a different user interface than that we used for model fit functions described above, as it only accepts \code{numeric} vectors as arguments to parameters \code{x} and \code{y} (Figure \ref{fig:spline:fit:diagram}). Additional parameters make it possible to override the defaults for number of knots and adjust the stiffness or tendency towards a straight line. The \code{plot()} method for splines, differently to the methods for other fit functions, produces a plot of the prediction. As no model formula is used, only one curve at a time is fitted and no statistical tests involving groups are possible. The most commonly used query functions are thus not the same as for linear and non-linear models.

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (x) [tprocess, fill=blue!5] {\textsl{obs.} $\to$ \code{x}};
\node (y) [tprocess, below of=model, fill=blue!5] {\textsl{obs.} $\to$ \code{y}};
\node (fitfun) [tprocess, right of=model, yshift=-0.7cm, xshift=2cm, fill=blue!5] {\code{smooth.spline()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=2.3cm, fill=blue!5] {\code{smooth.spline} \textsl{obj.}};
\node (pred) [tprocess, color = black, right of=fm, xshift=2.3cm] {\code{predict()}};
\node (fitted) [tprocess, color = black, above of=pred, yshift = -0.4cm] {\code{fitted()}};
\node (resid) [tprocess, color = black, below of=pred, yshift = +0.4cm] {\code{residuals()}};
\draw [arrow] (x) -- (fitfun);
\draw [arrow] (y) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (pred);
\draw [arrow] (fm) -- (fitted);
\draw [arrow] (fm) -- (resid);
\end{tikzpicture}
\end{small}
  \caption[Fitting smooth splines in \Rlang]{Fitting of smooth splines in \Rlang. Generic diagram from Figure \ref{fig:model:fit:diagram} redrawn to show the fitting of splines. Non-filled boxes are shared with fitting of other types of models, and filled ones are specific to \Rfunction{smooth.spline()}. Only the three most frequently used query methods are shown, while response and explanatory variables are passed separately to \textsl{x} and \textsl{y}.}\label{fig:spline:fit:diagram}
\end{figure}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fs1} \hlkwb{<-} \hlkwd{smooth.spline}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist)}
\hlkwd{print}\hlstd{(fs1)}
\end{alltt}
\begin{verbatim}
## Call:
## smooth.spline(x = cars$speed, y = cars$dist)
## 
## Smoothing Parameter  spar= 0.7801305  lambda= 0.1112206 (11 iterations)
## Equivalent Degrees of Freedom (Df): 2.635278
## Penalized Criterion (RSS): 4187.776
## GCV: 244.1044
\end{verbatim}
\begin{alltt}
\hlkwd{plot}\hlstd{(fs1,} \hlkwc{type} \hlstd{=} \hlstr{"l"}\hlstd{)}
\hlkwd{points}\hlstd{(}\hlkwc{x} \hlstd{= cars}\hlopt{$}\hlstd{speed,} \hlkwc{y} \hlstd{= cars}\hlopt{$}\hlstd{dist)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-spline-01-1} 

}


\end{knitrout}

Function \Rfunction{loess} implements \emph{local polynomial regression}. It fits a polynomial curve or surface (i.e., more than one explanatory variable can be included in the model formula) using local-weighted fitting. Its user interface is rather similar to that of \code{glm()} with \code{formula}, \code{family} and \code{data} formal parameters (Figure \ref{fig:loess:fit:diagram}). Additional parameters control ``stiffness'' or the extent of the local data used for fitting (how much weight is given to observations as a function of their distance). The type of fit local or not used for individual explanatory variables can be controlled through parameter \code{parametric}.

\begin{figure}
  \centering
\begin{small}
\begin{tikzpicture}[node distance=1.4cm, scale=0.5]
\node (model) [tprocess] {\textsl{model} $\to$ \code{formula}};
\node (data) [tprocess, below of=model, yshift = 0.4cm] {\textsl{observations} $\to$ \code{data}};
\node (weights) [tprocess, dashed, below of=data, fill=blue!1, yshift = 0.4cm] {\textsl{weights} $\to$ \code{weights}};
\node (family) [tprocess, below of=weights, fill=blue!5, yshift = 0.4cm] {\textsl{distribution} $\to$ \code{family}};
\node (fitfun) [tprocess, right of=data, xshift=2.5cm, yshift = -0.4cm, fill=blue!5] {\code{loess()}};
\node (fm) [tprocess, color = black, right of=fitfun, xshift=1.5cm, fill=blue!5] {\code{loess} \textsl{object}};
\node (pred) [tprocess, color = black, right of=fm, xshift=1.7cm] {\code{predict()}};
\node (fitted) [tprocess, color = black, above of=pred, yshift = -0.4cm] {\code{fitted()}};
\node (resid) [tprocess, color = black, below of=pred, yshift = +0.4cm] {\code{residuals()}};
\draw [arrow] (model) -- (fitfun);
\draw [arrow] (data) -- (fitfun);
\draw [arrow, dashed] (weights) -- (fitfun);
\draw [arrow] (family) -- (fitfun);
\draw [arrow] (fitfun) -- (fm);
\draw [arrow] (fm) -- (pred);
\draw [arrow] (fm) -- (fitted);
\draw [arrow] (fm) -- (resid);
\end{tikzpicture}
\end{small}
  \caption[Loess model fitting in \Rlang]{Loess model fitting in \Rlang is done in steps. Generic diagram from Figure \ref{fig:model:fit:diagram} redrawn to show local polynomial regression model fitting. Non-filled boxes are shared with fitting of other types of models, and filled ones are specific to \Rfunction{loess()}. Only the three most frequently used query methods are shown, while  both response and explanatory variables are under \textsl{observations}. Dashed boxes and arrows are optional as defaults are provided.}\label{fig:loess:fit:diagram}
\end{figure}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{floc} \hlkwb{<-} \hlkwd{loess}\hlstd{(dist} \hlopt{~} \hlstd{speed,} \hlkwc{data} \hlstd{= cars)}
\hlkwd{class}\hlstd{(floc)}
\end{alltt}
\begin{verbatim}
## [1] "loess"
\end{verbatim}
\begin{alltt}
\hlkwd{summary}\hlstd{(floc)}
\end{alltt}
\begin{verbatim}
## Call:
## loess(formula = dist ~ speed, data = cars)
## 
## Number of Observations: 50 
## Equivalent Number of Parameters: 4.78 
## Residual Standard Error: 15.29 
## Trace of smoother matrix: 5.24  (exact)
## 
## Control settings:
##   span     :  0.75 
##   degree   :  2 
##   family   :  gaussian
##   surface  :  interpolate	  cell = 0.2
##   normalize:  TRUE
##  parametric:  FALSE
## drop.square:  FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
  Function \Rfunction{anova()} can be used to compare two or more loess fits, but not on a single one.
\end{warningbox}

\begin{explainbox}
  Several modern approaches to data analysis, which do provide estimates of effects' significance and sizes, are based on the use of splines to describe the responses and even variance. Among them are additive models such as GAM and related methods \autocite[see][]{Wood2017} and functional data analysis (FDA) \autocite{Ramsay2009}. These methods are implemented in specialised extension packages and fall outside the scope of this book.
\end{explainbox}
\index{smoothing splines|)}\index{local polynomial regression|)}\index{models!fitting|)}%

\section{Model Formulas}\label{sec:stat:formulas}
\index{model formulas|(}\index{models!specification|see{model formulas}}%
Model formulas, such as \code{y\,\char"007E\,x} are widely used in \Rlang, both in model fitting as exemplified in previous sections of this chapter and in plotting when using base \Rlang \Rmethod{plot()} methods.

\Rlang is consistent and flexible in how it treats various objects, to an extent that can be surprising to those familiar with other computer languages. Model formulas are objects of class \Rclass{formula} and mode \Rclass{call} and can be manipulated and stored similarly to objects of other \Rlang classes.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(y} \hlopt{~} \hlstd{x)}
\end{alltt}
\begin{verbatim}
## [1] "formula"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(y} \hlopt{~} \hlstd{x)}
\end{alltt}
\begin{verbatim}
## [1] "call"
\end{verbatim}
\end{kframe}
\end{knitrout}

Like any other \Rlang object formulas can be assigned to variables and be members of lists and vectors. Consequently, the first linear model fit example from page \pageref{chunk:lm:models1} can be rewritten as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.formula} \hlkwb{<-} \hlstd{dist} \hlopt{~} \hlnum{1} \hlopt{+} \hlstd{speed}
\hlstd{fm1} \hlkwb{<-} \hlkwd{lm}\hlstd{(my.formula,} \hlkwc{data}\hlstd{=cars)}
\end{alltt}
\end{kframe}
\end{knitrout}

In some situations, e.g., calculation of correlations, models lacking a \emph{lhs} term (a term on the left-hand side of \code{\,\char"007E\,}) are used. At least one term must be present in the \emph{rhs} of model formulas, as an expression ending in \code{\,\char"007E\,} is syntactically incomplete.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlopt{~} \hlstd{x} \hlopt{+} \hlstd{y)}
\end{alltt}
\begin{verbatim}
## [1] "formula"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlopt{~} \hlstd{x} \hlopt{+} \hlstd{y)}
\end{alltt}
\begin{verbatim}
## [1] "call"
\end{verbatim}
\begin{alltt}
\hlkwd{is.empty.model}\hlstd{(}\hlopt{~} \hlstd{x} \hlopt{+} \hlstd{y)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Some details of \Rlang formulas can be important in advanced scripts. Two kinds of ``emptiness'' are possible for formulas. As with other classes, empty objects or vectors of length zero are valid and can be created with the class constructor. In the case of formulas, there is an additional kind of emptiness, a formula describing a model with no explanatory terms on its \emph{rhs}.

An ``empty'' object of class \Rclass{formula} can be created by a call to \code{formula()} with no arguments, similarly as a numeric vector of length zero is created by the call \code{numeric()}. The last, commented out, statement in the code below triggers an error as the argument passed to \Rfunction{is.empty.model()} is of length zero. (This behaviour is not consistent with \Rclass{numeric} vectors of length zero; see for example the value returned by \code{is.finite(numeric())}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{formula}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] "formula"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(}\hlkwd{formula}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] "list"
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{formula}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlcom{# is.empty.model(formula())}
\end{alltt}
\end{kframe}
\end{knitrout}

A model formula describing a model with no explanatory terms on the rhs, is considered empty even if it is a valid object of class \Rclass{formula} and, thus, not missing. While \code{y\ \char"007E\ 1} describes a model with only an intercept (estimating $a = \bar{x}$), \code{y\ \char"007E\ 0} or its equivalent \code{y\ \char"007E\ -1}, describes an empty model that cannot be fitted to data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(y} \hlopt{~} \hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "formula"
\end{verbatim}
\begin{alltt}
\hlkwd{mode}\hlstd{(y} \hlopt{~} \hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "call"
\end{verbatim}
\begin{alltt}
\hlkwd{is.empty.model}\hlstd{(y} \hlopt{~} \hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is.empty.model}\hlstd{(y} \hlopt{~} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{is.empty.model}\hlstd{(y} \hlopt{~} \hlstd{x)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

The value returned by \Rmethod{length()} on a single formula is not always 1, the number of formulas in the vector of formulas, but instead the number of components in the formula. For longer vectors, it does return the number of member formulae. Because of this, it is better to store model formulas in objects of class \Rclass{list} than in vectors, as \Rfunction{length()} consistently returns the expected value on lists.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{formula}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(y} \hlopt{~} \hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(y} \hlopt{~} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(y} \hlopt{~} \hlstd{x)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{c}\hlstd{(y} \hlopt{~} \hlnum{1}\hlstd{, y} \hlopt{~} \hlstd{x))}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{list}\hlstd{(y} \hlopt{~} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{list}\hlstd{(y} \hlopt{~} \hlnum{1}\hlstd{, y} \hlopt{~} \hlstd{x))}
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}

As described above, \Rfunction{length()} applied to a single formula and to a list of formulas behaves differently. To call \Rfunction{length()} on each member of a list of formulas, we can use \code{sapply()} (see section \ref{sec:data:apply} on page \pageref{sec:data:apply}). As function \Rfunction{is.empty.model()} is not vectorised, we also have to use \code{sapply()} with a list of formulas.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sapply}\hlstd{(}\hlkwd{list}\hlstd{(y} \hlopt{~} \hlnum{0}\hlstd{, y} \hlopt{~} \hlnum{1}\hlstd{, y} \hlopt{~} \hlstd{x), length)}
\end{alltt}
\begin{verbatim}
## [1] 3 3 3
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(}\hlkwd{list}\hlstd{(y} \hlopt{~} \hlnum{0}\hlstd{, y} \hlopt{~} \hlnum{1}\hlstd{, y} \hlopt{~} \hlstd{x), is.empty.model)}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{explainbox}

In the examples in previous sections, we fitted simple models. More complex ones can be easily formulated using the same syntax. First of all, one can avoid using of operator \code{*} by explicitly defining all individual main effects and interactions using operators \code{+} and \code{:}\,. The syntax implemented in base \Rlang allows grouping by means of parentheses, so it is also possible to exclude some interactions by combining the use of \code{*} and parentheses.

The same symbols as for arithmetic operators are used for model formulas. Within a formula, symbols are interpreted according to formula syntax. When we mean an arithmetic operation that could be interpreted as being part of the model formula we need to ``protect'' it by means of the identity function \Rfunction{I()}. The next two examples define formulas for models with only one explanatory variable. With formulas like these, the explanatory variable will be computed on the fly when fitting the model to data. In the first case below, we need to explicitly protect the addition of the two variables into their sum, because otherwise they would be interpreted as two separate explanatory variables in the model. In the second case, \Rfunction{log()} cannot be interpreted as part of the model formula, and consequently does not require additional protection, neither does the expression passed as its argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlkwd{I}\hlstd{(x1} \hlopt{+} \hlstd{x2)}
\hlstd{y} \hlopt{~} \hlkwd{log}\hlstd{(x1} \hlopt{+} \hlstd{x2)}
\end{alltt}
\end{kframe}
\end{knitrout}

\Rlang formula syntax allows alternative ways for specifying interaction terms. They allow ``abbreviated'' ways of entering formulas, which for complex experimental designs saves typing and can improve clarity. As seen above, operator \code{*} saves us from having to explicitly indicate all the interaction terms in a full factorial model.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x2} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x3} \hlopt{+} \hlstd{x2}\hlopt{:}\hlstd{x3} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x2}\hlopt{:}\hlstd{x3}
\end{alltt}
\end{kframe}
\end{knitrout}

Can be replaced by a concise equivalent.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{*} \hlstd{x2} \hlopt{*} \hlstd{x3}
\end{alltt}
\end{kframe}
\end{knitrout}

When the model to be specified does not include all possible interaction terms, we can combine the concise notation with parentheses. Below, equivalent formulas are shown using concise and verbose notation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{(x2} \hlopt{*} \hlstd{x3)}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3} \hlopt{+} \hlstd{x2}\hlopt{:}\hlstd{x3}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{*} \hlstd{(x2} \hlopt{+} \hlstd{x3)}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x2} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x3}
\end{alltt}
\end{kframe}
\end{knitrout}

The \code{\textasciicircum{}} operator provides a concise notation to limit the order of the interaction terms included in a formula.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{(x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3)}\hlopt{^}\hlnum{2}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x2} \hlopt{+} \hlstd{x1}\hlopt{:}\hlstd{x3} \hlopt{+} \hlstd{x2}\hlopt{:}\hlstd{x3}
\end{alltt}
\end{kframe}
\end{knitrout}

Operator \code{\%in\%} can also be used as a shortcut for including only some of all the possible interaction terms in a formula.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x1} \hlopt{%in%} \hlstd{x2}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Whether the two model formulas above are equivalent or not, can be investigated using function \Rfunction{terms()}.

% knitr bug??
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{terms}\hlstd{(y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{(x2} \hlopt{*} \hlstd{x3))}
\hlkwd{terms}\hlstd{(y} \hlopt{~} \hlstd{x1} \hlopt{*} \hlstd{(x2} \hlopt{+} \hlstd{x3))}
\hlkwd{terms}\hlstd{(y} \hlopt{~} \hlstd{(x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3)}\hlopt{^}\hlnum{2}\hlstd{)}
\hlkwd{terms}\hlstd{(y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x1} \hlopt{%in%} \hlstd{x2)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\begin{advplayground}
For operator \code{\textasciicircum{}} to behave as expected, its first operand should be a formula with no interactions!  Compare the result of expanding these two formulas with \Rfunction{terms()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{(x1} \hlopt{+} \hlstd{x2} \hlopt{+} \hlstd{x3)}\hlopt{^}\hlnum{2}
\hlstd{y} \hlopt{~} \hlstd{(x1} \hlopt{*} \hlstd{x2} \hlopt{*} \hlstd{x3)}\hlopt{^}\hlnum{2}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

\begin{advplayground}
Run the code examples below using the \Rdata{npk} data set from \Rlang. They demonstrate the use of different model formulas in ANOVA\index{analysis of variance!model formula}. Use these examples plus your own variations on the same theme to build your understanding of the syntax of model formulas. Based on the terms displayed in the ANOVA tables, first work out what models are being fitted in each case. In a second step, write the mathematical formulation of each of the models. Finally, think how model choice may affect the conclusions from an analysis of variance.

% runs fine but crashes LaTeX
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(npk)}
\hlkwd{anova}\hlstd{(}\hlkwd{lm}\hlstd{(yield} \hlopt{~} \hlstd{N} \hlopt{*} \hlstd{P} \hlopt{*} \hlstd{K,} \hlkwc{data} \hlstd{= npk))}
\hlkwd{anova}\hlstd{(}\hlkwd{lm}\hlstd{(yield} \hlopt{~} \hlstd{(N} \hlopt{+} \hlstd{P} \hlopt{+} \hlstd{K)}\hlopt{^}\hlnum{2}\hlstd{,} \hlkwc{data} \hlstd{= npk))}
\hlkwd{anova}\hlstd{(}\hlkwd{lm}\hlstd{(yield} \hlopt{~} \hlstd{N} \hlopt{+} \hlstd{P} \hlopt{+} \hlstd{K} \hlopt{+} \hlstd{P} \hlopt{%in%} \hlstd{N} \hlopt{+} \hlstd{K} \hlopt{%in%} \hlstd{N,} \hlkwc{data} \hlstd{= npk))}
\hlkwd{anova}\hlstd{(}\hlkwd{lm}\hlstd{(yield} \hlopt{~} \hlstd{N} \hlopt{+} \hlstd{P} \hlopt{+} \hlstd{K} \hlopt{+} \hlstd{N} \hlopt{%in%} \hlstd{P} \hlopt{+} \hlstd{K} \hlopt{%in%} \hlstd{P,} \hlkwc{data} \hlstd{= npk))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

Nesting of factors in experiments using hierarchical designs such as split-plots or repeated measures, results in the need to compute additional error terms, differing in their degrees of freedom. In a nested design with fixed effects, effects are tested based on different error terms depending on the design of an experiment, i.e., depending on the randomisation of the assignment of treatments to experimental units. In base-\Rlang model-formulas, nesting is described by explicit definition of error terms by means of \code{Error()} within the formula.

The syntax described above does not support complex statistical models as implemented in extension packages. For example, Nowadays, fitting linear mixed-effects (LME) models is the preferred approach for the analysis of data from experiments and surveys based on hierarchical designs. These methods are implemented in packages \pkgname{nlme} \autocite{Pinheiro2000} and \pkgname{lme4} \autocite{Bates2015} that define extensions to the model formula syntax. The extensions make it possible to describe nesting and distinguish fixed and random effects. Packages implementing fitting of additive models have needed other extensions to the formula syntax. Additive model methods are described by \citeauthor{Wood2017} (\citeyear{Wood2017}) and \citeauthor{Zuur2012} (\citeyear{Zuur2012}). Although the overall approach and syntax are followed in most contributed packages, different packages have extended the formula syntax in different ways. These extensions fall outside the scope of this book.

\begin{warningbox}
  \Rlang will accept any syntactically correct model formula, even when the results of the fit are not interpretable. It is \emph{the responsibility of the user to ensure that models are meaningful}\index{models!nesting of factors}. The most common, and dangerous, mistake is specifying for factorial experiments, models that are missing lower-order terms.

  Fitting models like those below to data from an experiment based on a three-way factorial design should be avoided. In both cases, simpler terms are missing, while higher-order interaction(s) that include the missing term are included in the model. Such models are not interpretable, as the variation from the missing term(s) ends being ``disguised'' within the remaining terms, distorting their apparent significance and parameter estimates.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{A} \hlopt{+} \hlstd{B} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{B} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{C} \hlopt{+} \hlstd{B}\hlopt{:}\hlstd{C}
\hlstd{y} \hlopt{~} \hlstd{A} \hlopt{+} \hlstd{B} \hlopt{+} \hlstd{C} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{B} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{C} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{B}\hlopt{:}\hlstd{C}
\end{alltt}
\end{kframe}
\end{knitrout}

  In contrast to those above, the models below are interpretable, even if not ``full'' models (not including all possible interactions).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{y} \hlopt{~} \hlstd{A} \hlopt{+} \hlstd{B} \hlopt{+} \hlstd{C} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{B} \hlopt{+} \hlstd{A}\hlopt{:}\hlstd{C} \hlopt{+} \hlstd{B}\hlopt{:}\hlstd{C}
\hlstd{y} \hlopt{~} \hlstd{(A} \hlopt{+} \hlstd{B} \hlopt{+} \hlstd{C)}\hlopt{^}\hlnum{2}
\hlstd{y} \hlopt{~} \hlstd{A} \hlopt{+} \hlstd{B} \hlopt{+} \hlstd{C} \hlopt{+} \hlstd{B}\hlopt{:}\hlstd{C}
\hlstd{y} \hlopt{~} \hlstd{A} \hlopt{+} \hlstd{B} \hlopt{*} \hlstd{C}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{warningbox}

\begin{explainbox}
\index{model formulas!manipulation}\textbf{Manipulation of model formulas.} Because this is a book about the \Rlang language, it is pertinent to describe how formulas can be manipulated. Formulas, as any other \Rlang objects, can be saved in variables including lists. Why is this useful? For example, if we want to fit several different models to the same data, we can write a \code{for} loop that walks through a list of model formulas (see section \ref{sec:R:faces:of:loops} on page \pageref{sec:R:faces:of:loops}). Obviously, user-defined functions can accept formulas as arguments as \code{lm()} and other model-fitting functions do. In addition, it is relatively simple for user code to programmatically create and edit \Rlang formulas, in the same way as functions \code{update()} and \code{step()} do under the hood.

A conversion constructor is available under the name \Rfunction{as.formula()}. It is useful when formulas are input interactively by the user or read from text files. With \Rfunction{as.formula()} we can convert a character string into a formula.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.formula}\hlstd{(}\hlstr{"y ~ x"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## y ~ x
\end{verbatim}
\end{kframe}
\end{knitrout}

As\index{model formulas!conversion from character strings} there are many functions for the manipulation of \code{character} strings available in base \Rlang and through extension packages, it is easiest to build model formulas as strings. We can use functions like \code{paste()} to assemble a formula as text, and then use \Rfunction{as.formula()} to convert it to an object of class \code{formula}, usable for fitting a model.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{paste}\hlstd{(}\hlstr{"y"}\hlstd{,} \hlstr{"x"}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{"~"}\hlstd{) |>} \hlkwd{as.formula}\hlstd{()}
\end{alltt}
\begin{verbatim}
## y ~ x
\end{verbatim}
\end{kframe}
\end{knitrout}

For\index{model formulas!conversion into character strings} the reverse operation of converting a formula into a string, we have available methods \code{as.character()} and \code{format()}. The first of these methods returns a character vector containing the components of the formula as individual strings, while \code{format()} returns a single character string with the formula formatted for printing.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.character}\hlstd{(y} \hlopt{~} \hlstd{x)}
\end{alltt}
\begin{verbatim}
## [1] "~" "y" "x"
\end{verbatim}
\begin{alltt}
\hlkwd{format}\hlstd{(y} \hlopt{~} \hlstd{x)}
\end{alltt}
\begin{verbatim}
## [1] "y ~ x"
\end{verbatim}
\end{kframe}
\end{knitrout}

This conversion makes it possible to edit a formula as a character string.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{format}\hlstd{(y} \hlopt{~} \hlstd{x) |>} \hlkwd{gsub}\hlstd{(}\hlstr{"x"}\hlstd{,} \hlstr{"x + z"}\hlstd{,} \hlkwc{x} \hlstd{= _) |>} \hlkwd{as.formula}\hlstd{()}
\end{alltt}
\begin{verbatim}
## y ~ x + z
\end{verbatim}
\end{kframe}
\end{knitrout}

It\index{model formulas!updating} is also possible to \emph{edit} formula objects with method \Rfunction{update()}. In the replacement formula, a dot can replace either the left-hand side (lhs) or the right-hand side (rhs) of the existing formula. We can also remove terms as can be seen below. In some cases, the dot corresponding to the lhs can be omitted, but including it makes the syntax clearer.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.formula} \hlkwb{<-} \hlstd{y} \hlopt{~} \hlstd{x1} \hlopt{+} \hlstd{x2}
\hlkwd{update}\hlstd{(my.formula, .} \hlopt{~} \hlstd{.} \hlopt{+} \hlstd{x3)}
\end{alltt}
\begin{verbatim}
## y ~ x1 + x2 + x3
\end{verbatim}
\begin{alltt}
\hlkwd{update}\hlstd{(my.formula, .} \hlopt{~} \hlstd{.} \hlopt{-} \hlstd{x1)}
\end{alltt}
\begin{verbatim}
## y ~ x2
\end{verbatim}
\begin{alltt}
\hlkwd{update}\hlstd{(my.formula, .} \hlopt{~} \hlstd{x3)}
\end{alltt}
\begin{verbatim}
## y ~ x3
\end{verbatim}
\begin{alltt}
\hlkwd{update}\hlstd{(my.formula, z} \hlopt{~} \hlstd{.)}
\end{alltt}
\begin{verbatim}
## z ~ x1 + x2
\end{verbatim}
\begin{alltt}
\hlkwd{update}\hlstd{(my.formula, .} \hlopt{+} \hlstd{z} \hlopt{~} \hlstd{.)}
\end{alltt}
\begin{verbatim}
## y + z ~ x1 + x2
\end{verbatim}
\end{kframe}
\end{knitrout}

As \Rlang provides high-level functions for model selection editing model formulas is not very frequently needed for model fitting.
\end{explainbox}

A model matrix of dummy coefficients is used in the actual computations. This matrix can be derived from a model formula, a contrast name, and the data for the explanatory variables using function \Rfunction{model.matrix()}.
\index{model formulas|)}

\section{Time Series}\label{sec:stat:time:series}
\index{time series|(}
Longitudinal data consist of repeated measurements, usually done over time, on the same experimental units. Longitudinal data, when replicated on several experimental units at each time point, are called repeated measurements, while when not replicated, they are called time series. Base \Rlang provides special support for the analysis of time series data, while repeated measurements can be analysed with nested linear models, mixed-effects models, and additive models.

Time series data are data collected in such a way that there is only one observation, possibly of multiple variables, available at each point in time. This brief section introduces only the most basic aspects of time-series analysis. In most cases, time steps are of uniform duration and occur regularly, which simplifies data handling and storage. \Rlang not only provides methods for the analysis and manipulation of time-series, but also a specialised class for their storage, \Rclass{"ts"}. Regular time steps allow more compact storage---e.g., a \code{ts} object does not need to store time values for each observation but instead a combination of two of start time, step size and end time. When analysing time-series data, it is frequently necessary to convert time data between one of the special \Rlang classes and \Rclass{character} strings, and to operate on dates and times (see section \ref{sec:data:datetime} on page \pageref{sec:data:datetime}).

By now, you surely guessed that to create an object of class \Rclass{"ts"} one needs to use a constructor called \Rfunction{ts()} or a conversion constructor called \Rfunction{as.ts()} and that you can look up the arguments they accept by consulting help using \code{help(ts)}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.ts} \hlkwb{<-} \hlkwd{ts}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{start} \hlstd{=} \hlnum{2019}\hlstd{,} \hlkwc{deltat} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{12}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

The \code{print()} method for \code{ts} objects is special, and adjusts the printout according to the time step or \code{deltat} of the series.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(my.ts)}
\end{alltt}
\begin{verbatim}
##      Jan Feb Mar Apr May Jun Jul Aug Sep Oct
## 2019   1   2   3   4   5   6   7   8   9  10
\end{verbatim}
\end{kframe}
\end{knitrout}

The structure of the \code{ts} object is simple. Its mode is \code{numeric} but its class is \code{ts}. It is similar to a numeric vector with the addition of one attribute named \code{tsp} describing the time steps, as a numeric vector of length 3, giving start and end time and the size of the steps.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mode}\hlstd{(my.ts)}
\end{alltt}
\begin{verbatim}
## [1] "numeric"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(my.ts)}
\end{alltt}
\begin{verbatim}
## [1] "ts"
\end{verbatim}
\begin{alltt}
\hlkwd{is.ts}\hlstd{(my.ts)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(my.ts)}
\end{alltt}
\begin{verbatim}
##  Time-Series [1:10] from 2019 to 2020: 1 2 3 4 5 6 7 8 9 10
\end{verbatim}
\begin{alltt}
\hlkwd{attributes}\hlstd{(my.ts)}
\end{alltt}
\begin{verbatim}
## $tsp
## [1] 2019.00 2019.75   12.00
## 
## $class
## [1] "ts"
\end{verbatim}
\end{kframe}
\end{knitrout}

Data set \Rdata{nottem}, included in \Rlang, contains meteorological data for Nottingham. The annual cycle of mean air temperatures (in degrees Fahrenheit) as well as variation among years are clear when data are plotted.

\begin{explainbox}
Reexpression of the temperatures in the time-series from degrees Fahrenheit into degrees Celsius can be achieved as in \code{numeric} vectors using vectorised arithmetic and recycling.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nottem.celcius} \hlkwb{<-} \hlstd{(nottem} \hlopt{-} \hlnum{32}\hlstd{)} \hlopt{*} \hlnum{5} \hlopt{/} \hlnum{9}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{is.ts}\hlstd{(nottem.celcius)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(nottem.celcius)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ts-03plot-1} 

}


\end{knitrout}

\begin{playground}
Explore the structure of the \code{nottem.celcius} object (or the \code{nottem} object), and consider how and why it differs or not from that of the object \code{my.ts} that we created above. Similarly explore time series \code{ausres}, another of the data sets included in \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(nottem.celcius)}
\hlkwd{attributes}\hlstd{(nottem.celcius)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{playground}

Many time series of observations display cyclic variation at different frequencies. Outdoors, air temperature varies cyclically between day and night and throughout the year. Superimposed on these regular cycles there can be faster random variation and long-term trends. One approach to the analysis of time series data is to estimate the separate contribution of these components.

An efficient approach to time series decomposition, based on LOESS\index{time series!decomposition}\index{STL|see{time series decomposition}} (see section \ref{sec:stat:splines} on \pageref{sec:stat:splines}), is STL (Seasonal and Trend decomposition using Loess).\qRfunction{decompose()}\qRfunction{stl()} A seasonal window of 7 months, the minimum accepted, allows the extraction of the annual cycles and a long-term trend leaving  as a remainder some unexplained variation. In the plot, is important to be aware that the scale limits in the different panels are different, and re-set for each plot.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nottem.stl} \hlkwb{<-} \hlkwd{stl}\hlstd{(nottem.celcius,} \hlkwc{s.window} \hlstd{=} \hlnum{7}\hlstd{)}
\hlkwd{plot}\hlstd{(nottem.stl)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ts-05-1} 

}


\end{knitrout}

It is interesting to explore the class and structure of the object returned by \Rfunction{stl()}, as we may want to extract components. We can see that the structure of this object is rather similar to model-fit objects of classes \code{lm} and \code{glm}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(nottem.stl)}
\end{alltt}
\begin{verbatim}
## [1] "stl"
\end{verbatim}
\begin{alltt}
\hlkwd{str}\hlstd{(nottem.stl,} \hlkwc{no.list} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{give.attr} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{vec.len} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  $ time.series: Time-Series [1:240, 1:3] from 1920 to 1940: -4.4 -5.08 ...
##  $ weights    : num [1:240] 1 1 1 1 1 ...
##  $ call       : language stl(x = nottem.celcius, s.window = 7)
##  $ win        : Named num [1:3] 7 23 13
##  $ deg        : Named int [1:3] 0 1 1
##  $ jump       : Named num [1:3] 1 3 2
##  $ inner      : int 2
##  $ outer      : int 0
\end{verbatim}
\end{kframe}
\end{knitrout}

As with other fit methods, method \Rfunction{summary()} is available. However, this method for class \code{stl} returns unchanged the \code{stl} object received as an argument and displays a summary. In other words, it behaves similarly to \code{print()} methods with respect to the returned object, but produces a different printout than \code{print()} as its side effect.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(nottem.stl)}
\end{alltt}
\begin{verbatim}
##  Call:
##  stl(x = nottem.celcius, s.window = 7)
## 
##  Time.series components:
##     seasonal             trend             remainder         
##  Min.   :-6.693714   Min.   : 8.548340   Min.   :-2.5950749  
##  1st Qu.:-4.413237   1st Qu.: 9.201837   1st Qu.:-0.6907277  
##  Median :-0.650109   Median : 9.456694   Median : 0.0593786  
##  Mean   : 0.001867   Mean   : 9.462835   Mean   : 0.0017326  
##  3rd Qu.: 4.595458   3rd Qu.: 9.779625   3rd Qu.: 0.6445627  
##  Max.   : 8.215818   Max.   :10.424848   Max.   : 2.6914745  
##  IQR:
##      STL.seasonal STL.trend STL.remainder data  
##      9.0087       0.5778    1.3353        8.5833
##    % 105.0          6.7      15.6         100.0 
## 
##  Weights: all == 1
## 
##  Other components: List of 5
##  $ win  : Named num [1:3] 7 23 13
##  $ deg  : Named int [1:3] 0 1 1
##  $ jump : Named num [1:3] 1 3 2
##  $ inner: int 2
##  $ outer: int 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Consult \code{help(stl)} and \code{help(plot.stl)} and create different plots and decompositions by passing different arguments to the formal parameters of these methods.

Method \code{print()} shows the different components. Extract the seasonal component and plot is on its own against time.
\end{playground}

In the Nottingham temperature time series, the period of the variation is clearly annual, but for many other time series an interesting feature to characterise is autocorrelation and its periodicity. Function \Rfunction{acf()} computes and plots the autocorrelation function (ACF) vs. the lag. The time series has monthly data, while the scale for lag in the plot below is in years. The autocorrelation is one at zero lag, and slightly less with a lag of one year, while its is negative between winter and summer temperatures.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{acf}\hlstd{(nottem)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-ts-08-1} 

}


\end{knitrout}

More advanced time-series analysis and forecasting methods are implemented in contributed packages and fall outside the scope of this book. The textbook \citetitle{Hyndman2021} \autocite{Hyndman2021} is comprehensive, starting with an introduction to time series and continuing all the way to the description of modern forecasting methods, using \Rlang throughout.
\index{time series|)}

\section{Multivariate Statistics}\label{sec:stat:MV}
\index{multivariate statistics|(}
All the methods presented above are univariate, as even if in some cases we considered multiple explanatory variables on the rhs of model formulas, the lhs contained at most one response variable. There are many different multivariate methods available, and a few of them are implemented in base \Rlang functions. The current section does not describe these methods in depth, it only provides a few simple examples for some of the frequently used ones.

\subsection{Multivariate analysis of variance}
\index{multivariate analysis of variance|(}
\index{MANOVA|see{multivariate analysis of variance}}
Multivariate methods take into account several response variables simultaneously, as part of a single analysis. In practice, it is usual to use contributed packages for multivariate data analysis in \Rlang, except for simple cases. We will look first at \emph{multivariate} ANOVA or MANOVA. In the same way as \Rfunction{aov()} is a wrapper that uses internally \Rfunction{lm()}, \Rfunction{manova()} is a wrapper that uses internally \Rfunction{aov()}.

Multivariate model formulas in base \Rlang require the use of column binding (\code{cbind()}) on the left-hand side (lhs) of the model formula. The well-known \Rdata{iris} data set, containing size measurements for flowers of three species of \emph{Iris}, is used in the examples below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mmf2} \hlkwb{<-} \hlkwd{manova}\hlstd{(}\hlkwd{cbind}\hlstd{(Petal.Length, Petal.Width)} \hlopt{~}  \hlstd{Species,} \hlkwc{data} \hlstd{= iris)}
\hlkwd{anova}\hlstd{(mmf2)}
\end{alltt}
\begin{verbatim}
## Analysis of Variance Table
## 
##              Df  Pillai approx F num Df den Df    Pr(>F)    
## (Intercept)   1 0.98786   5939.2      2    146 < 2.2e-16 ***
## Species       2 1.04645     80.7      4    294 < 2.2e-16 ***
## Residuals   147                                             
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\begin{alltt}
\hlkwd{summary}\hlstd{(mmf2)}
\end{alltt}
\begin{verbatim}
##            Df Pillai approx F num Df den Df    Pr(>F)    
## Species     2 1.0465   80.661      4    294 < 2.2e-16 ***
## Residuals 147                                            
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Modify the example above to use \code{aov()} instead of \code{manova()} and save the result to a variable named \code{mmf3}.
Use \code{class()}, \code{attributes()}, \code{names()}, \code{str()} and extraction of members to explore objects \code{mmf1}, \code{mmf2} and \code{mmf3}. Are they different?
\end{advplayground}

\index{multivariate analysis of variance|)}

\subsection{Principal components analysis}\label{sec:stat:PCA}
\index{principal components analysis|(}\index{PCA|see {principal components analysis}}

Principal components analysis (PCA) is used to simplify a data set by combining variables with similar and ``mirror'' behaviour into principal components. At a later stage, we frequently try to interpret these components in relation to known and/or assumed independent variables. Base \Rlang's function \Rfunction{prcomp()} computes the principal components and accepts additional arguments for centring and scaling.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pc} \hlkwb{<-} \hlkwd{prcomp}\hlstd{(iris[}\hlkwd{c}\hlstd{(}\hlstr{"Sepal.Length"}\hlstd{,} \hlstr{"Sepal.Width"}\hlstd{,}
                    \hlstr{"Petal.Length"}\hlstd{,} \hlstr{"Petal.Width"}\hlstd{)],}
             \hlkwc{center} \hlstd{=} \hlnum{TRUE}\hlstd{,}
             \hlkwc{scale} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

By printing the returned object, we can see the loadings of each variable in the principal components \code{P1} to \code{P4}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(pc)}
\end{alltt}
\begin{verbatim}
## [1] "prcomp"
\end{verbatim}
\begin{alltt}
\hlstd{pc}
\end{alltt}
\begin{verbatim}
## Standard deviations (1, .., p=4):
## [1] 1.7083611 0.9560494 0.3830886 0.1439265
## 
## Rotation (n x k) = (4 x 4):
##                     PC1         PC2        PC3        PC4
## Sepal.Length  0.5210659 -0.37741762  0.7195664  0.2612863
## Sepal.Width  -0.2693474 -0.92329566 -0.2443818 -0.1235096
## Petal.Length  0.5804131 -0.02449161 -0.1421264 -0.8014492
## Petal.Width   0.5648565 -0.06694199 -0.6342727  0.5235971
\end{verbatim}
\end{kframe}
\end{knitrout}

In the summary, the rows ``Proportion of Variance'' and ``Cumulative Proportion'' are most informative of the contribution of each principal component (PC) to explaining the variation among observations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(pc)}
\end{alltt}
\begin{verbatim}
## Importance of components:
##                           PC1    PC2     PC3     PC4
## Standard deviation     1.7084 0.9560 0.38309 0.14393
## Proportion of Variance 0.7296 0.2285 0.03669 0.00518
## Cumulative Proportion  0.7296 0.9581 0.99482 1.00000
\end{verbatim}
\end{kframe}
\end{knitrout}

Method \code{plot()} generates a bar plot of variances corresponding to the different components.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(pc)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-pca-04-1} 

}


\end{knitrout}



Method \Rfunction{biplot()} produces a plot with one principal component (PC) on each axis, plus arrows for the loadings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{biplot}\hlstd{(pc)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-pca-05-1} 

}


\end{knitrout}



Visually more elaborate plots of the principal components and their loadings can be obtained using package \pkgnameNI{ggplot} described in chapter \ref{chap:R:plotting} on page \pageref{chap:R:plotting}. Package \pkgnameNI{ggfortify} extends \pkgnameNI{ggplot} so as to make it easy to plot principal components and their loadings.

\begin{playground}
For growth and morphological data, a log-transformation can be suitable given that variance is frequently proportional to the magnitude of the values measured. We leave it as an exercise to repeat the above analysis using transformed values for the dimensions of petals and sepals. How much does the use of transformations change the outcome of the analysis?
\end{playground}

\begin{advplayground}
As for other fitted models, the object returned by function \Rfunction{prcomp()} is list-like with multiple components and belongs to a class of the same name as the function, not derived from class \code{"list"}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(pc)}
\hlkwd{str}\hlstd{(pc,} \hlkwc{max.level} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{advplayground}

\index{principal components analysis|)}

\subsection{Multidimensional scaling}\label{sec:stat:MDS}
\index{multidimensional scaling|(}\index{MDS|see {multidimensional scaling}}

The aim of multidimensional scaling (MDS) is to visualise in 2D space the similarity between pairs of observations. The values for the observed variable(s) are used to compute a measure of distance among pairs of observations. The nature of the data will influence what distance metric is most informative.
For MDS we start with a matrix of distances among observations. We will use, for the next examples, distances in kilometres between geographic locations in Europe from the data set \Rdata{eurodist}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{loc} \hlkwb{<-} \hlkwd{cmdscale}\hlstd{(eurodist)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can see that the returned object \code{loc} is a \code{matrix}, with names for one of the dimensions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(loc)}
\end{alltt}
\begin{verbatim}
## [1] "matrix" "array"
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(loc)}
\end{alltt}
\begin{verbatim}
## [1] 21  2
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(loc,} \hlnum{8}\hlstd{)}
\end{alltt}
\begin{verbatim}
##                   [,1]       [,2]
## Athens     2290.274680  1798.8029
## Barcelona  -825.382790   546.8115
## Brussels     59.183341  -367.0814
## Calais      -82.845973  -429.9147
## Cherbourg  -352.499435  -290.9084
## Cologne     293.689633  -405.3119
## Copenhagen  681.931545 -1108.6448
## Geneva       -9.423364   240.4060
\end{verbatim}
\end{kframe}
\end{knitrout}

To make the code easier to read, two vectors are first extracted from the matrix and named \code{x} and \code{y}. We force aspect to equality so that distances on both axes are comparable.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlstd{loc[,} \hlnum{1}\hlstd{]}
\hlstd{y} \hlkwb{<-} \hlopt{-}\hlstd{loc[,} \hlnum{2}\hlstd{]} \hlcom{# change sign so North is at the top}
\hlkwd{plot}\hlstd{(x, y,} \hlkwc{type} \hlstd{=} \hlstr{"n"}\hlstd{,} \hlkwc{asp} \hlstd{=} \hlnum{1}\hlstd{,}
     \hlkwc{main} \hlstd{=} \hlstr{"cmdscale(eurodist)"}\hlstd{)}
\hlkwd{text}\hlstd{(x, y,} \hlkwd{rownames}\hlstd{(loc),} \hlkwc{cex} \hlstd{=} \hlnum{0.6}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-mds-03-1} 

}


\end{knitrout}
\pagebreak

\begin{advplayground}
  Find data on the mean annual temperature, mean annual rainfall and mean number of sunny days at each of the locations in the \code{eurodist} data set. Next, compute suitable distance metrics, for example, using function \Rfunction{dist}. Finally, use MDS to visualise how similar the locations are with respect to each of the three variables. Devise a measure of distance that takes into account the three climate variables and use MDS to find how distant the different locations are.
\end{advplayground}

\index{multidimensional scaling|)}

\subsection{Cluster analysis}\label{sec:stat:cluster}
\index{cluster analysis|(}

In cluster analysis, the aim is to group observations into discrete groups with maximal internal homogeneity and maximum group-to-group differences. In the next example, we use function \Rfunction{hclust()} from the base-\Rlang package \pkgname{stats}. We use, as above, the \Rdata{eurodist} data which directly provides distances. In other cases, a matrix of distances between pairs of observations needs to be first calculated with function \Rfunction{dist} which supports several methods.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hc} \hlkwb{<-} \hlkwd{hclust}\hlstd{(eurodist)}
\hlkwd{print}\hlstd{(hc)}
\end{alltt}
\begin{verbatim}
## 
## Call:
## hclust(d = eurodist)
## 
## Cluster method   : complete 
## Number of objects: 21
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(hc)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-cluster-02-1} 

}


\end{knitrout}

We can use \Rfunction{cutree()} to limit the number of clusters by directly passing as an argument the desired number of clusters or the height at which to cut the tree.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{cutree}\hlstd{(hc,} \hlkwc{k} \hlstd{=} \hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
##          Athens       Barcelona        Brussels          Calais       Cherbourg 
##               1               2               3               3               3 
##         Cologne      Copenhagen          Geneva       Gibraltar         Hamburg 
##               3               4               2               5               4 
## Hook of Holland          Lisbon           Lyons          Madrid      Marseilles 
##               3               5               2               5               2 
##           Milan          Munich           Paris            Rome       Stockholm 
##               2               3               3               1               4 
##          Vienna 
##               3
\end{verbatim}
\end{kframe}
\end{knitrout}

The object returned by \Rfunction{hclust()} contains details of the result of the clustering, which allows further manipulation and plotting.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(hc)}
\end{alltt}
\begin{verbatim}
## List of 7
##  $ merge      : int [1:20, 1:2] -8 -3 -6 -4 -16 -17 -5 -7 -2 -12 ...
##  $ height     : num [1:20] 158 172 269 280 328 428 460 460 521 668 ...
##  $ order      : int [1:21] 1 19 9 12 14 20 7 10 16 8 ...
##  $ labels     : chr [1:21] "Athens" "Barcelona" "Brussels" "Calais" ...
##  $ method     : chr "complete"
##  $ call       : language hclust(d = eurodist)
##  $ dist.method: NULL
##  - attr(*, "class")= chr "hclust"
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{cluster analysis|)}

%\subsection{Discriminant analysis}\label{sec:stat:DA}
%\index{discriminant analysis|(}
%
%In discriminant analysis the categories or groups to which objects belong are known \emph{a priori} for a training data set. The aim is to fit/build a classifier that will allow us to assign future observations to the different non-overlapping groups with as few mistakes as possible.
%
%
%\index{discriminant analysis|)}
\index{multivariate statistics|)}

\section{Further Reading}\label{sec:stat:further:reading}

\Rlang\index{further reading!statistics with R} and its extension packages provide implementations of most known statistical methods. For some methods, alternative implementations exist in different packages. The present chapter only attempts to show how some of the most frequently used implementations are used, as this knowledge is frequently taken for granted in specialised books, several of which I list here. Two recent text books on statistics, following a modern approach, and using \Rlang for examples, are \citetitle{Diez2019} \autocite{Diez2019} and \citetitle{Holmes2019} \autocite{Holmes2019}. They differ in the subjects emphasised, with the second one focusing more on genetic and molecular biology. Three examples of books introducing statistical computations in \Rlang are \citetitle{Dalgaard2008} \autocite{Dalgaard2008}, \citetitle{Everitt2010} \autocite{Everitt2010} and \citetitle{Zuur2009} \autocite{Zuur2009}. The book \citetitle{Mehtatalo2020} \autocite{Mehtatalo2020} presents both the statistical theory and code examples. The comprehensive \citebooktitle{Crawley2012} \autocite{Crawley2012} and the classic reference \citebooktitle{Venables2002} \autocite{Venables2002} both present statistical theory in parallel with the \Rlang code examples. More specific books are also available from which a few suggestions for further reading are \citebooktitle{Everitt2011} \autocite{Everitt2011}, \citebooktitle{Faraway2004} \autocite{Faraway2004}, \citebooktitle{Faraway2006} \autocite{Faraway2006}, \citebooktitle{Hyndman2021} \autocite{Hyndman2021}, \citebooktitle{James2013} \autocite{James2013}, \citebooktitle{Pinheiro2000} \autocite{Pinheiro2000} and \citebooktitle{Wood2017} \autocite{Wood2017}.




% !Rnw root = appendix.main.Rnw



\chapter{\Rlang Extensions: Data Wrangling}\label{chap:R:data}

\begin{VF}
Essentially everything in S[R], for instance, a call to a function, is an S[R] object. One viewpoint is that S[R] has self-knowledge. This self-awareness makes a lot of things possible in S[R] that are not in other languages.

\VA{Patrick J. Burns}{\emph{S Poetry}, 1998}\nocite{Burns1998}
\end{VF}

\section{Aims of This Chapter}

Base \Rlang and the recommended extension packages (installed by default) include many functions for manipulating data. The \Rlang distribution supplies a complete set of functions and operators that allow all the usual data manipulation operations. These functions have stable and well-described behaviour, so in my view, they should be preferred unless some of their limitations justify the use of alternatives defined in contributed packages. In the present chapter, I describe the new syntax introduced by the most popular contributed \Rlang extension packages aiming at changing (usually improving one aspect at the expense of another) in various ways how we can manipulate data in \Rlang. These independently developed packages extend the \Rlang language not only by adding new ``words'' to it but by supporting new ways of meaningfully connecting ``words''---i.e., providing new ``grammars'' for data manipulation. While at the current stage of development of base \Rlang not breaking existing code has been the priority, several of the still ``young'' packages in the \pkgname{tidyverse} have prioritised experimentation with enhanced features over backwards compatibility. The development of \pkgname{tidyverse} packages seems to have initially emphasised users' convenience more than encouraging safe/error-free user code. The design of package \pkgname{data.table} has prioritised performance at the expense of easy of use. I do not describe in depth these new approaches but instead only briefly compare them to base \Rlang highlighting the most important differences.

\section{Introduction}

By reading previous chapters, you have already become familiar with base \Rlang classes, methods, functions, and operators for storing and manipulating data. Most of these had been originally designed to perform optimally on rather small data sets \autocite[see][]{Matloff2011}. The performance of these functions has improved significantly over the years and random-access memory in computers has become cheaper, making constraints imposed by the original design of \Rpgrm less limiting. On the other hand, the size of data sets has also increased.

Some contributed packages have aimed at improving performance by relying on different compromises between usability, speed, and reliability than used for base \Rlang.
Package \pkgname{data.table} is the best example of an alternative implementation of data storage and manipulation that maximises the speed of processing for large data sets using a new semantics and requiring a new syntax. We could say that package \pkgname{data.table} is based on a theoretical abstraction, or ``grammar of data'', that is different from that in the \Rlang language. The compromise in this case has been the use of a less intuitive syntax, and by defaulting to passing arguments by reference instead of by copy, increasing the ``responsibility'' of the programmer or data analyst with respect to not overwriting or corrupting data. This focus on performance has made obvious the performance bottlenecks present in base \Rpgrm, which have been subsequently alleviated while maintaining backwards compatibility for users' code.

Another recent development is the \pkgname{tidyverse}, which is a formidable effort to redefine how data analysis operations are expressed in \Rlang code and scripts. In many ways, it is also a new abstraction, or ``grammar of data''. With respect to its implementation, it can also be seen as a new language built on-top of the \Rlang language. It is still young and evolving, and the developers from Posit still remain relentless about fixing what they consider earlier misguided decisions in the design of the packages comprising the \pkgname{tidyverse}. This is a wise decision for the future, but can be annoying to occasional users who may not be aware of the changes that have taken place between uses. As a user I highly value long-term stability and backwards compatibility of software. Older systems like base \Rlang provide this, but their long development history shows up as occasional inconsistencies and quirks. The \pkgname{tidyverse} as a paradigm is nowadays popular among data analysts while among users for whom data analysis is not the main focus, it is more common to make use of only individual packages as the need arises, e.g., using the new grammar only for some stages of the data analysis workflow.

When a computation included a chain of sequential operations, until \Rlang 4.1.0, using base \Rlang by itself we could either store the returned value in a temporary variable at each step in the computation, or nest multiple function calls. The first approach is verbose, but allows readable scripts, especially if the names used for temporary variables are wisely chosen. The second approach becomes very difficult to read as soon as there is more than one nesting level. Attempts to find an alternative syntax have borrowed the concept of data \emph{pipes} from Unix shells \autocite{Kernigham1981}. Interestingly, that it has been possible to write packages that define the operators needed to ``add'' this new syntax to \Rlang is a testimony to its flexibility and extensibility. Two packages, \pkgname{magrittr} and \pkgname{wrapr}, define operators for pipe-based syntax. In year 2021, a pipe operator was added to the \Rlang language itself and more recently its features enhanced.

In much of my work I emphasise reproducibility and reliability, preferring base \Rlang over extension packages, except for plotting, whenever practical. For run once and delete or quick-and-dirty data analyses, I tend to use the \emph{tidyverse}. However, with modern computers and some understanding of what are the performance bottlenecks in \Rlang code, I have rarely found it worthwhile the effort needed for improved performance by using extension packages. The benefit to effort balance will be different for those readers who analyse huge data sets.

The definition of the \emph{tidyverse} is rather vague, as package \pkgname{tidyverse} loads and attaches a set of packages of which most but not all follow a consistent design and support this new grammar. The packages that are attached by package \pkgname{tidyverse} has changed over time. Package \pkgname{tidyverse}, however, defines a function that lists them.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tidyverse}\hlopt{::}\hlkwd{tidyverse_packages}\hlstd{()}
\end{alltt}
\begin{verbatim}
##  [1] "broom"         "conflicted"    "cli"           "dbplyr"       
##  [5] "dplyr"         "dtplyr"        "forcats"       "ggplot2"      
##  [9] "googledrive"   "googlesheets4" "haven"         "hms"          
## [13] "httr"          "jsonlite"      "lubridate"     "magrittr"     
## [17] "modelr"        "pillar"        "purrr"         "ragg"         
## [21] "readr"         "readxl"        "reprex"        "rlang"        
## [25] "rstudioapi"    "rvest"         "stringr"       "tibble"       
## [29] "tidyr"         "xml2"          "tidyverse"
\end{verbatim}
\end{kframe}
\end{knitrout}

In this chapter, you will become familiar with packages \pkgname{tibble}, \pkgname{dplyr}, \pkgname{tidyr}, and \pkgname{lubridate}. Package \pkgnameNI{ggplot2} will be described in chapter \ref{chap:R:plotting} as it implements the grammar of graphics and has little in common with other members of the \pkgname{tidyverse}. As many of the functions in the \emph{tidyverse} can be substituted by existing base \Rlang functions, recognising similarities and differences between them has become important since both approaches are now in common use, and frequently even coexist within \Rlang scripts.

\begin{explainbox}
In any design, there is a tension between opposing goals. In software for data analysis, a key pair of opposed goals are usability, including concise but expressive code, and avoidance of ambiguity. Base \Rlang function \Rfunction{subset()} has an unusual syntax, as it evaluates the expression passed as the second argument within the namespace of the data frame passed as its first argument (see section \ref{sec:calc:df:with} on page \pageref{sec:calc:df:with}). This saves typing, enhancing usability, at the expense of increasing the risk of bugs, as by reading the call to subset, it is not obvious which names are resolved in the environment of the call to \code{subset()} and which ones within its first argument---i.e., as column names in the data frame. In addition, changes elsewhere in a script can change how a call to subset is interpreted. In reality, subset is a wrapper function built on top of the extraction operator \code{[ ]} (see section \ref{sec:calc:indexing} on page \pageref{sec:calc:indexing}). It is a convenience function, mostly intended to be used at the console, rather than in scripts or package code. To extract columns or rows from a data frame, it is always safer to use the \Roperator{[ , ]} or \Roperator{[[ ]]} operators at the expense of some verbosity.

Package \pkgname{dplyr}, and much of the \pkgname{tidyverse}, relies on a similar approach as subset to enhance convenience at the expense of ambiguity. Package \pkgname{dplyr} has undergone quite drastic changes during its development history with respect to how to handle the dilemma caused by ``guessing'' of the environment where names should be looked up. There is no easy answer; a simplified syntax leads to ambiguity, and a fully specified syntax is verbose. Recent versions of the package introduced a terse syntax to achieve a concise way of specifying where to look up names. I do appreciate the advantages of the grammar of data that is implemented in the \pkgname{tidyverse}. However, the actual implementation, can result in ambiguities and subtleties that are even more difficult to deal by inexperienced or occasional users than those caused by inconsistencies in base \Rlang. My opinion is that for code that needs to be highly reliable and produce reproducible results in the future, we should for the time being prefer base \Rlang constructs. For code that is to be used once, or for which reproducibility can depend on the use of a specific (old or soon to become old) version of packages like \pkgname{dplyr}, or which is not a burden to thoroughly test and update regularly, the conciseness and power of the new syntax can be an advantage.
\end{explainbox}

Package \pkgname{poorman} re-implements many of the functions in \pkgname{dplyr} and a few from \pkgname{tidyr} using pure \Rlang code instead of compiled \Cpplang code and with no dependencies on other extension packages. This light-weight approach can be useful when \Rlang's data frames rather than tibbles are preferred or when the possible enhanced performance with large data sets is not needed.

\section{Packages Used in This Chapter}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(learnrbook}\hlopt{::}\hlstd{pkgs_ch_data)}
\end{alltt}
\end{kframe}
\end{knitrout}

To run the examples included in this chapter, you need first to load and attach some packages from the library (see section \ref{sec:script:packages} on page \pageref{sec:script:packages} for details on the use of packages).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(learnrbook)}
\hlkwd{library}\hlstd{(tibble)}
\hlkwd{library}\hlstd{(magrittr)}
\hlkwd{library}\hlstd{(wrapr)}
\hlkwd{library}\hlstd{(stringr)}
\hlkwd{library}\hlstd{(dplyr)}
\hlkwd{library}\hlstd{(tidyr)}
\hlkwd{library}\hlstd{(lubridate)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section[Replacements for \texttt{data.frame}]{Replacements for \code{data.frame}}
\index{data frame!replacements|(}
\subsection{Package \pkgname{data.table}}
The function call semantics of the \Rlang language is that arguments are passed to functions by copy (see section \ref{sec:script:functions} on page \pageref{sec:script:functions}). Functions and methods from package \pkgname{data.table} pass arguments by reference, avoiding making copies. In base \Rlang, if the arguments are modified within the code of a function, these changes are local to the function. However, any assignments within the functions and methods defined in package \pkgname{data.table} modify the variables passed as their arguments.

If implemented naively, the copy semantics used in base \Rlang would impose a huge toll on performance. However, \Rlang in most situations only makes a copy in memory if and when the value changes. Consequently, for modern versions of \Rlang, which are good at avoiding unnecessary copying of objects, the normal \Rlang semantics has only a moderate negative impact on performance. However, this impact can still be a problem as modification is detected at the object level, and consequently, \Rlang can make copies of large objects such as a whole data frame when only values in a single column or even just an attribute have changed.

Passing arguments by reference, as in \pkgname{data.table}, simplifies the needed tests for delayed copying and by avoiding the need to copy arguments, achieves the best possible performance. This is a specialised package but extremely useful when dealing with very large data sets. Writing user code, such as scripts, with \pkgname{data.table} requires a good understanding of the pass-by-reference semantics. Obviously, package \pkgname{data.table} makes no attempt at backwards compatibility with base-\Rlang \code{data.frame}.

In contrast to the design of package \pkgname{data.table}, the focus of the \pkgname{tidyverse} is not only performance. The design of this grammar has also considered usability. Design compromises have been resolved differently than in base \Rlang or \pkgname{data.table} and in some cases code written using base \Rlang can significantly outperform the \pkgname{tidyverse} and vice versa. There exist packages that implement a translation layer from the syntax of the \pkgname{tidyverse} into that of \pkgname{data.table} or relational database queries.

\subsection{Package \pkgname{tibble}}\label{sec:data:tibble}
\index{tibble!differences with data frames|(}

Package \pkgname{tibble} aimed at enhanced performance, like \pkgname{data.table}, but not at the expense of usability. The \Rfunction{tibble()} constructor supports semantics that allow more concise code compared to the \Rfunction{data.frame()} constructor. The \code{print()} method for tibbles displays them concisely and provides additional information. With small data sets, differences in performance are in most cases irrelevant. Early on, package \Rfunction{tibble()} was consistently faster than base \Rlang data frames, but the performance of \Rlang has improved over the years. Nowadays, there is no clear winner. The decision to use package \Rfunction{tibble()} depends mostly on whether one uses the other packages from the \pkgname{tidyverse}, mainly \pkgname{dplyr} and \pkgname{tidyr}, or not.

The authors of package \pkgname{tibble} describe their \Rclass{tbl} class as nearly backwards compatible with \Rclass{data.frame} and make it a derived class. This backwards compatibility is only partial so in some situations data frames and tibbles are not equivalent.

The class and methods that package \pkgname{tibble} defines lift some of the restrictions imposed by the design of base \Rlang data frames at the cost of creating some incompatibilities due to changed (improved) syntax for member extraction. Tibbles simplify the creation of ``columns'' of class \Rclass{list} and remove support for columns of class \Rclass{matrix}. Handling of attributes is also different, with no row names added by default. There are also differences in default behaviour of both constructors and methods.

\emph{Although, objects of class \Rclass{tbl} can be passed as arguments to functions that expect data frames as input, these functions are not guaranteed to work correctly with tibbles as a result of the differences in syntax of some methods.}

\begin{warningbox}
It is easy to write code that will work correctly both with data frames and tibbles by avoiding constructs that behave differently. However, code that is syntactically correct according to the \Rlang language may fail to work as expected if a tibble is used in place of a data frame. Only functions tested to work correctly with both tibbles and data frames can be relied upon as compatible.
\end{warningbox}

\begin{explainbox}
That it has been possible to define tibbles as objects of a class derived from \Rclass{data.frame} reveals one of the drawbacks of the simple implementation of S3 object classes in \Rlang. Allowing this is problematic because the promise of compatibility implicit in a derived class is not always fulfilled. An independently developed method designed for data frames will not necessarily work correctly with tibbles, but in the absence of a specialised method for tibbles it will be used (dispatched) when the generic method is called with a tibble as argument.
\end{explainbox}

\begin{warningbox}
One should be aware that although the constructor \Rfunction{tibble()} and conversion function \Rfunction{as\_tibble()}, as well as the test \Rfunction{is\_tibble()} use the name \Rclass{tibble}, the class attribute is named \code{tbl}. This is inconsistent with base \Rlang conventions, as it is the use of an underscore instead of a dot in the name of these methods.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.tb} \hlkwb{<-} \hlkwd{tibble}\hlstd{(}\hlkwc{numbers} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{)}
\hlkwd{is_tibble}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{inherits}\hlstd{(my.tb,} \hlstr{"tibble"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

Furthermore, to support tibbles based on different underlying data sources such as \code{data.table} objects or databases, a further derived class is needed. In our example, as our tibble has an underlying \code{data.frame} class, the most derived class of \code{my.tb} is \Rclass{tbl\_df}.
\end{warningbox}

Function \code{show\_classes()}, defined below, concisely reports the class of the object passed as an argument and of its members (\emph{apply} functions are described in section \ref{sec:data:apply} on page \pageref{sec:data:apply}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{show_classes} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}
  \hlkwd{cat}\hlstd{(}
    \hlkwd{paste}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlkwd{class}\hlstd{(x)[}\hlnum{1}\hlstd{],}
    \hlstr{"containing:"}\hlstd{),}
    \hlkwd{paste}\hlstd{(}\hlkwd{names}\hlstd{(x),}
          \hlkwd{sapply}\hlstd{(x, class),} \hlkwc{collapse} \hlstd{=} \hlstr{", "}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{": "}\hlstd{),}
    \hlkwc{sep} \hlstd{=} \hlstr{"\textbackslash{}n"}\hlstd{)}
    \hlstd{)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The \Rfunction{tibble()} constructor by default does not convert character data into factors, while the \Rfunction{data.frame()} constructor did before \Rlang version 4.0.0. The default can be overridden through an argument passed to these constructors, and in the case of \Rfunction{data.frame()} also by setting an \Rlang option. This new behaviour extends to function \Rfunction{read.table()} and its wrappers (see section \ref{sec:files:txt} on page \pageref{sec:files:txt}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{codes} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{),} \hlkwc{numbers} \hlstd{=} \hlopt{-}\hlnum{1}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwc{integers} \hlstd{=} \hlnum{1L}\hlopt{:}\hlnum{3L}\hlstd{)}
\hlkwd{is.data.frame}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is_tibble}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{show_classes}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## data.frame containing:
## codes: character, numbers: integer, integers: integer
\end{verbatim}
\end{kframe}
\end{knitrout}

Tibbles are, or pretend to be (see above), data frames---or more formally class \Rclass{tibble} is derived from class \code{data.frame}. However, data frames are not tibbles.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.tb} \hlkwb{<-} \hlkwd{tibble}\hlstd{(}\hlkwc{codes} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{),} \hlkwc{numbers} \hlstd{=} \hlopt{-}\hlnum{1}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwc{integers} \hlstd{=} \hlnum{1L}\hlopt{:}\hlnum{3L}\hlstd{)}
\hlkwd{is.data.frame}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is_tibble}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{show_classes}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## tbl_df containing:
## codes: character, numbers: integer, integers: integer
\end{verbatim}
\end{kframe}
\end{knitrout}

The \Rmethod{print()} method for tibbles differs from that for data frames in that it outputs a header with the text ``A tibble:'' followed by the dimensions (number of rows $\times$ number of columns), adds under each column name an abbreviation of its class and instead of printing all rows and columns, a limited number of them are displayed. In addition, individual values are formatted more compactly and using colour to highlight, for example, negative numbers in red.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
##   codes numbers integers
## 1     A      -1        1
## 2     B       0        2
## 3     C       1        3
\end{verbatim}
\begin{alltt}
\hlkwd{print}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## # A tibble: 3 x 3
##   codes numbers integers
##   <chr>   <int>    <int>
## 1 A          -1        1
## 2 B           0        2
## 3 C           1        3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
The default number of rows printed depends on \Rlang option \code{tibble.print\_max} that can be set with a call to \Rfunction{options()}. This option plays for tibbles a similar role as option \code{max.print} plays for base \Rlang \Rmethod{print()} methods.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{options}\hlstd{(}\hlkwc{tibble.print_max} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{tibble.print_min} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{playground}
Print methods for tibbles and data frames differ in their behaviour when not all columns fit in a printed line. 1) Construct a data frame and an equivalent tibble with at least 50 rows and then test how the output looks when they are printed. 2) Construct a data frame and an equivalent tibble with more columns than will fit in the width of the \Rlang console and then test how the output looks when they are printed.
\end{playground}

Data frames can be converted into tibbles with \code{as\_tibble()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_conv.tb} \hlkwb{<-} \hlkwd{as_tibble}\hlstd{(my.df)}
\hlkwd{is.data.frame}\hlstd{(my_conv.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is_tibble}\hlstd{(my_conv.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{show_classes}\hlstd{(my_conv.tb)}
\end{alltt}
\begin{verbatim}
## tbl_df containing:
## codes: character, numbers: integer, integers: integer
\end{verbatim}
\end{kframe}
\end{knitrout}

Tibbles can be converted into ``real'' data.frames with \code{as.data.frame()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_conv.df} \hlkwb{<-} \hlkwd{as.data.frame}\hlstd{(my.tb)}
\hlkwd{is.data.frame}\hlstd{(my_conv.df)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{is_tibble}\hlstd{(my_conv.df)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{show_classes}\hlstd{(my_conv.df)}
\end{alltt}
\begin{verbatim}
## data.frame containing:
## codes: character, numbers: integer, integers: integer
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
  When dealing with tibbles, column- and row binding should be done with functions \Rfunction{bind\_rows()} and \Rfunction{bind\_cols()} from \pkgname{dplyr}, not with functions \Rfunction{rbind()} and \Rfunction{cbind()} from \Rlang. See explanation below.
\end{warningbox}

\begin{explainbox}
Not all conversion functions work consistently when converting from a derived class into its parent. The reason for this is disagreement between authors on what the \emph{correct} behaviour is based on logic and theory. You are not likely to be hit by this problem frequently, but it can be difficult to diagnose.

We have already seen that calling \Rfunction{as.data.frame()} on a tibble strips the derived class attributes, returning a data frame. We will look at the whole character vector stored in the \code{"class"} attribute to demonstrate the difference. We also test the two objects for equality, in two different ways. Using the operator \code{==} tests for equivalent objects. Objects that contain the same data. Using \Rfunction{identical()} tests that objects are exactly the same, including attributes such as \code{"class"}, which we retrieve using \Rfunction{class()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(my_conv.df)}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlstd{my.tb} \hlopt{==} \hlstd{my_conv.df}
\end{alltt}
\begin{verbatim}
##      codes numbers integers
## [1,]  TRUE    TRUE     TRUE
## [2,]  TRUE    TRUE     TRUE
## [3,]  TRUE    TRUE     TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(my.tb, my_conv.df)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Now we derive from a tibble, and then attempt a conversion back into a tibble.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.xtb} \hlkwb{<-} \hlstd{my.tb}
\hlkwd{class}\hlstd{(my.xtb)} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"xtb"}\hlstd{,} \hlkwd{class}\hlstd{(my.xtb))}
\hlkwd{class}\hlstd{(my.xtb)}
\end{alltt}
\begin{verbatim}
## [1] "xtb"        "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\begin{alltt}
\hlstd{my_conv_x.tb} \hlkwb{<-} \hlkwd{as_tibble}\hlstd{(my.xtb)}
\hlkwd{class}\hlstd{(my_conv_x.tb)}
\end{alltt}
\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\begin{alltt}
\hlstd{my.xtb} \hlopt{==} \hlstd{my_conv_x.tb}
\end{alltt}
\begin{verbatim}
##      codes numbers integers
## [1,]  TRUE    TRUE     TRUE
## [2,]  TRUE    TRUE     TRUE
## [3,]  TRUE    TRUE     TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(my.xtb, my_conv_x.tb)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

The two viewpoints on conversion functions are as follows. If the argument passed to a conversion function is an object of a derived class, 1) it should be returned after stripping the derived class, or 2) it should be returned as is, without stripping the derived class. Base \Rlang follows, as far as I have been able to work out, approach 1). Some packages in the \pkgname{tidyverse} sometimes follow, or have followed in the past, approach 2). If in doubt about the behaviour of some function, then you will need to do a test similar to the one used above.

As tibbles have been defined as a class derived from \code{data.frame}, if methods have not been explicitly defined for tibbles, the methods defined for data frames are called, and these are likely to return a data frame rather than a tibble. Even a frequent operation like column binding is affected, at least at the time of writing.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(my.df)}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{cbind}\hlstd{(my.df, my.tb))}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{cbind}\hlstd{(my.tb, my.df))}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{cbind}\hlstd{(my.df,} \hlkwc{added} \hlstd{=} \hlopt{-}\hlnum{3}\hlopt{:-}\hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{cbind}\hlstd{(my.tb,} \hlkwc{added} \hlstd{=} \hlopt{-}\hlnum{3}\hlopt{:-}\hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(}\hlkwd{cbind}\hlstd{(my.tb,} \hlkwc{added} \hlstd{=} \hlopt{-}\hlnum{3}\hlopt{:-}\hlnum{1}\hlstd{),} \hlkwd{cbind}\hlstd{(my.df,} \hlkwc{added} \hlstd{=} \hlopt{-}\hlnum{3}\hlopt{:-}\hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

There are additional important differences between the constructors \Rfunction{tibble()} and \code{data.frame()}. One of them is that in a call to \Rfunction{tibble()}, member variables (``columns'')  being defined can be used in the definition of subsequent member variables.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tibble}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{5}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwc{c} \hlstd{= a} \hlopt{+} \hlstd{b,} \hlkwc{d} \hlstd{= letters[a} \hlopt{+} \hlnum{1}\hlstd{])}
\end{alltt}
\begin{verbatim}
## # A tibble: 5 x 4
##       a     b     c d    
##   <int> <int> <int> <chr>
## 1     1     5     6 b    
## 2     2     4     6 c    
## 3     3     3     6 d    
## # i 2 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
What is the behaviour if you replace \Rfunction{tibble()} by \Rfunction{data.frame()} in the statement above?
\end{playground}

\begin{warningbox}
While objects passed directly as arguments to the \Rfunction{data.frame()} constructor to be included as ``columns'' can be factors, vectors or matrices (with the same number of rows as the data frame), arguments passed to the \Rfunction{tibble()} constructor can be factors, vectors or lists (with the same number of members as rows in the tibble). As we saw in section \ref{sec:R:data:frames} on page \pageref{sec:R:data:frames}, base \Rlang's data frames can contain columns of classes \code{list} and \code{matrix}. The difference is in the need to use \Rfunction{I()}, the identity function, to protect these variables during construction and assignment to true \code{data.frame} objects as otherwise list members and matrix columns will be assigned to multiple individual columns in the data frame.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tibble}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{5}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwc{c} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{5}\hlstd{))}
\end{alltt}
\begin{verbatim}
## # A tibble: 5 x 3
##       a     b c        
##   <int> <int> <list>   
## 1     1     5 <chr [1]>
## 2     2     4 <dbl [1]>
## 3     3     3 <dbl [1]>
## # i 2 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

A list of lists or a list of vectors can be directly passed to the constructor.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tibble}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{5}\hlopt{:}\hlnum{1}\hlstd{,} \hlkwc{c} \hlstd{=} \hlkwd{list}\hlstd{(}\hlstr{"a"}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{2}\hlstd{,} \hlnum{0}\hlopt{:}\hlnum{3}\hlstd{, letters[}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{], letters[}\hlnum{3}\hlopt{:}\hlnum{1}\hlstd{]))}
\end{alltt}
\begin{verbatim}
## # A tibble: 5 x 3
##       a     b c        
##   <int> <int> <list>   
## 1     1     5 <chr [1]>
## 2     2     4 <int [2]>
## 3     3     3 <int [4]>
## # i 2 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

\index{tibble!differences with data frames|)}
\index{data frame!replacements|)}

\section{Data Pipes}\label{sec:data:pipes}
\index{chaining statements with \emph{pipes}|(}
The first obvious difference between scripts using \pkgname{tidyverse} packages is the frequent use of \emph{pipes}. This is, however, mostly a question of preferences, as pipes can be as well used with base \Rlang functions. In addition, since version 4.0.0, \Rlang has a native pipe operator \Roperator{\textbar >}, described in section \ref{sec:script:pipes} on page \pageref{sec:script:pipes}. Here I describe other earlier implementations of pipes, and the differences among these and \Rlang's pipe operator.

\subsection{\pkgname{magrittr}}
\index{pipes!tidyverse|(}
\index{pipe operator}
A set of operators for constructing pipes of \Rlang functions is implemented in package \pkgname{magrittr}. It preceded the native \Rlang pipe by several years. The pipe operator defined in package \pkgname{magrittr}, \Roperator{\%>\%}, is imported and re-exported by package \pkgname{dplyr}, which in turn defines functions that work well in data pipes.

Operator \Roperator{\%>\%} plays a similar role as \Rlang's \Roperator{\textbar >}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlnum{10}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%>%} \hlkwd{sqrt}\hlstd{()} \hlopt{%>%} \hlkwd{sum}\hlstd{()} \hlkwb{->} \hlstd{data0.out}
\end{alltt}
\end{kframe}
\end{knitrout}

The value passed can be made explicit using a dot as placeholder passed as an argument by name and by position to the function on the \emph{rhs} of the \Roperator{\%>\%} operator. Thus \code{.} in \pkgname{magrittr} plays a similar but not identical role as \code{\_} in base \Rlang pipes.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%>%} \hlkwd{sqrt}\hlstd{(}\hlkwc{x} \hlstd{= .)} \hlopt{%>%} \hlkwd{sum}\hlstd{(.)} \hlkwb{->} \hlstd{data1.out}
\hlkwd{all.equal}\hlstd{(data0.out, data1.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\Rlang's native pipe operator requires, consistently with \Rlang in all other situations, that functions that are to be evaluated use the parenthesis syntax, while \pkgname{magrittr} allows the parentheses to be missing when the piped argument is the only one passed to the function call on \textit{rhs}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%>%} \hlstd{sqrt} \hlopt{%>%} \hlstd{sum} \hlkwb{->} \hlstd{data5.out}
\hlkwd{all.equal}\hlstd{(data0.out, data5.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Package \pkgname{magrittr} provides additional pipe operators, such as ``tee'' (\Roperator{\%T>\%}) to create a branch in the pipe, and \Roperator{\%<>\%} to apply the pipe by reference. These operators are much less frequently used than \Roperator{\%>\%}.
\index{pipes!tidyverse|)}

\subsection{\pkgname{wrapr}}
\index{pipes!wrapr|(}
\index{dot-pipe operator}
The \Roperator{\%.>\%}, or ``dot-pipe'', operator from package \pkgname{wrapr}, allows expressions both on the rhs and lhs, and \emph{enforces the use of the dot} (\code{.}), as placeholder for the piped object. Given the popularity of \pkgname{dplyr} the pipe operator from \pkgname{magrittr} has been the most used.

Rewritten using the dot-pipe operator, the pipe in the previous chunk becomes

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%.>%} \hlkwd{sqrt}\hlstd{(.)} \hlopt{%.>%} \hlkwd{sum}\hlstd{(.)} \hlkwb{->} \hlstd{data2.out}
\hlkwd{all.equal}\hlstd{(data0.out, data2.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

However, as operator \Roperator{\%>\%} from \pkgname{magrittr} recognises the \code{.} placeholder without enforcing its use, the code below where \Roperator{\%.>\%} is replaced by \Roperator{\%>\%} returns the same value as that above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%>%} \hlkwd{sqrt}\hlstd{(.)} \hlopt{%>%} \hlkwd{sum}\hlstd{(.)} \hlkwb{->} \hlstd{data3.out}
\hlkwd{all.equal}\hlstd{(data0.out, data3.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

To use operator \Roperator{\textbar >} from \Rlang, we need to edit the code using (\code{\_}) as placeholder and passing it as an argument to parameters by name in the function calls on the \textit{rhs}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in |>} \hlkwd{sqrt}\hlstd{(}\hlkwc{x} \hlstd{= _) |>} \hlkwd{sum}\hlstd{(}\hlkwc{x} \hlstd{= _)} \hlkwb{->} \hlstd{data4.out}
\hlkwd{all.equal}\hlstd{(data0.out, data4.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

We can, in this case, simply use no placeholder, and pass the arguments by position to the first parameter of the functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in |>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{sum}\hlstd{()} \hlkwb{->} \hlstd{data4.out}
\hlkwd{all.equal}\hlstd{(data0.out, data4.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

The \index{pipes!expressions in rhs} dot-pipe operator \Roperator{\%.>\%} from \pkgname{wrapr} allows us to use the placeholder \code{.} in expressions on the \emph{rhs} of operators in addition to in function calls.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%.>%} \hlstd{(.}\hlopt{^}\hlnum{2}\hlstd{)} \hlkwb{->} \hlstd{data7.out}
\end{alltt}
\end{kframe}
\end{knitrout}

In contrast, operator \Roperator{\%>\%} does not support expressions, only function call syntax on the \textit{rhs}, forcing calling of operators with parenthesis syntax

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%>%} \hlkwd{`^`}\hlstd{(}\hlkwc{e1} \hlstd{= .,} \hlkwc{e2} \hlstd{=} \hlnum{2}\hlstd{)} \hlkwb{->} \hlstd{data9.out}
\hlkwd{all.equal}\hlstd{(data7.out, data9.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

In conclusion, \Rlang syntax for expressions is preserved when using the dot-pipe operator from \pkgname{wrapr}, with the only caveat that because of the higher precedence of the \Roperator{\%.>\%} operator, we need to ``protect'' bare expressions containing other operators by enclosing them in parentheses. In the examples above, we showed a simple expression so that it could be easily converted into a function call. The \Roperator{\%.>\%} operator supports also more complex expressions, even with multiple uses of the placeholder.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%.>%} \hlstd{(.}\hlopt{^}\hlnum{2} \hlopt{+} \hlkwd{sqrt}\hlstd{(.} \hlopt{+} \hlnum{1}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1]   2.414214   5.732051  11.000000  18.236068  27.449490  38.645751
##  [7]  51.828427  67.000000  84.162278 103.316625
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Comparing pipes}

Under-the-hood, the implementations of operators  \Roperator{\textbar >}, \Roperator{\%>\%} and \Roperator{\%.>\%} are different, with \Roperator{\textbar >} expected to have the best performance, followed by \Roperator{\%.>\%} and \Roperator{\%>\%} being slowest. As implementations evolve, performance may vary among versions. However, \Roperator{\textbar >} being part of \Rlang is likely to remain the fastest.

Being part of the \Rlang language, \Roperator{\textbar >} will remain available and most likely also backwards compatible, while packages could be abandoned or redesigned by their maintainers. For this reason, it is preferable to use the \Roperator{\textbar >} in scripts or code expected to be reused, unless compatibility with \Rlang versions earlier than 4.2.0 is needed. Elsewhere in the book I have used \Rlang's pipe operator \Roperator{\textbar >}.

Pipes can be used with any \Rlang function, but how elegant can be their use depends on the order of formal parameters. This is especially the case when passing arguments implicitly to the first parameter of the function on the \emph{rhs}. Several of the functions and methods defined in \pkgnameNI{tidyr}, \pkgnameNI{dplyr}, and a few other packages from the \pkgname{tidyverse} fit this need.

Writing a series of statements and saving intermediate results in temporary variables makes debugging easiest.  Debugging pipes is not as easy, as this usually requires splitting them, with one approach being the insertion of calls to \Rfunction{print()}. This is possible, because \Rfunction{print()} returns its input invisibly in addition to displaying it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in |>} \hlkwd{print}\hlstd{() |>} \hlkwd{sqrt}\hlstd{() |>} \hlkwd{print}\hlstd{() |>} \hlkwd{sum}\hlstd{() |>} \hlkwd{print}\hlstd{()} \hlkwb{->} \hlstd{data10.out}
\end{alltt}
\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
## [1] 22.46828
\end{verbatim}
\begin{alltt}
\hlstd{data10.out}
\end{alltt}
\begin{verbatim}
## [1] 22.46828
\end{verbatim}
\end{kframe}
\end{knitrout}

Debugging nested function calls is difficult. So, in general, it is preferable to use pipes instead of deeply nested function calls. However, it is best to avoid very long pipes. Normally, while writing scripts or analysing data it is important to check the correctness of intermediate results, so saving them to variables can save time and effort.

\begin{explainbox}
The design of \Rlang's native pipes has benefited from the experience gathered by earlier implementations and being now part of the language, we can expect it to become the reference one once its implementation is stable. The designers of the three implementations have to some extent disagreed in their design decisions. Consequently, some differences are more than aesthetic. \Rlang pipes are simpler, easier to use and expected to be fastest. Those from \pkgname{magrittr} are the most feature rich, but not as safe to use, and purportedly given a more complex implementation, the slowest. Package \pkgname{wrapr} is an attempt to enhance pipes compared to \pkgname{magrittr} focusing in syntactic simplicity and performance. \Rlang's \Roperator{\textbar >} operator has been enhanced since its addition in \Rlang only two years ago. These enhancements have all been backwards compatible.

The syntax of operators \Roperator{\textbar >} and \Roperator{\%>\%} is not identical. With \Rlang's \Roperator{\textbar >}, (as of \Rpgrm 4.3.0) the placeholder \code{\_} can be only passed to parameters by name, while with operator \Roperator{\%>\%} from \pkgname{magrittr} the placeholder \code{.} can be used to pass arguments both by name and by position. With operator \Roperator{\%.>\%} the use of the placeholder \code{.} is mandatory, and it can be passed by name or by position to the function call on the \textit{rhs}. Other differences are deeper like those related to the use of the extraction operator in the \emph{rhs} or support or not for expressions that are not explicit function calls.
\end{explainbox}

In the case of \Rlang, the \Roperator{\textbar >} pipe is conceptually a substitution with no alteration of the syntax or evaluation order. This avoids \emph{surprising} the user and simplifies implementation. In other words, \Rlang pipes are an alternative way of writing nested function calls. Quoting \Rlang documentation:

\begin{quotation}
  Currently, pipe operations are implemented as syntax transformations. So an expression written as \code{x |> f(y)} is parsed as \code{f(x, y)}. It is worth emphasising that while the code in a pipeline is written sequentially, regular \Rlang semantics for evaluation apply and so piped expressions will be evaluated only when first used in the rhs expression.
\end{quotation}

\begin{warningbox}
While frequently the different pipe operators can substitute for each other by adjusting the syntax, in some cases the differences among them in the order and timing of evaluation of the terms needs to be taken into account.

In some situations, operator \Roperator{\%>\%} from package \pkgname{magrittr} can behave unexpectedly. One example is the use of \Rfunction{assign()} in a pipe. With \Rlang's operator \Roperator{\textbar >} assignment takes place as expected.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in |>} \hlkwd{assign}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"data6.out"}\hlstd{,} \hlkwc{value} \hlstd{= _)}
\hlkwd{all.equal}\hlstd{(data.in, data6.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Named arguments are also supported with the dot-pipe operator from \pkgname{wrapr}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%.>%} \hlkwd{assign}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"data7.out"}\hlstd{,} \hlkwc{value} \hlstd{= .)}
\hlkwd{all.equal}\hlstd{(data.in, data7.out)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

However, the pipe operator (\Roperator{\%>\%}) from package \pkgname{magrittr} silently and unexpectedly fails to assign the value to the name.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{data.in} \hlopt{%>%} \hlkwd{assign}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"data8.out"}\hlstd{,} \hlkwc{value} \hlstd{= .)}
\hlkwa{if} \hlstd{(}\hlkwd{exists}\hlstd{(}\hlstr{"data8.out"}\hlstd{)) \{}
  \hlkwd{all.equal}\hlstd{(data.in, data8.out)}
\hlstd{\}} \hlkwa{else} \hlstd{\{}
  \hlkwd{print}\hlstd{(}\hlstr{"'data8.out' not found!"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] "'data8.out' not found!"
\end{verbatim}
\end{kframe}
\end{knitrout}

Although there are usually alternatives to get the computations done correctly, unexpected silent behaviour can be confusing.
\end{warningbox}

\index{pipes!wrapr|)}
\index{chaining statements with \emph{pipes}|)}

\section{Reshaping with \pkgname{tidyr}}\label{sec:data:reshape}
\index{reshaping tibbles|(}
\index{long-form- and wide-form tabular data}
Data stored in table-like formats can be arranged in different ways, wide and long (Figure \ref{fig:wide:long:data}). In base \Rlang, most model fitting functions, and the \Rfunction{plot()} method using (model) formulas, expect data to be arranged in ``long form'' so that each row in a data frame corresponds to a single observation (or measurement) event on a subject. Each column corresponds to a different measured feature, or ancillary information like the time of measurement, or a factor describing a classification of subjects according to treatments or features of the experimental design (e.g., blocks). Covariates measured on the same subject at an earlier point in time may also be stored in a column. Data arranged in \emph{long form} has been nicknamed as ``tidy'' and this is reflected in the name given to the \pkgname{tidyverse} suite of packages. However, this longitudinal arrangement of data has been the preferred format since the inception of \Slang and \Rlang. Data in which columns correspond to measurement events are described as being in a \emph{wide form}.

\begin{figure}
\begin{footnotesize}
\parbox{.55\linewidth}{
 \begin{tabular}{lp{1.25cm}p{1.25cm}p{1.25cm}}
  \toprule
  Subject & Height January & Height February & Height March \\
  \midrule
  A & 5 & 7 & 9 \\
  B & 4 & 7 & 9 \\
  C & 6 & 7 & 8 \\
  \bottomrule
\end{tabular}}
\hfill
\parbox{.4\linewidth}{
\begin{tabular}{lll}
  \toprule
  Subject & Date & Height \\
  \midrule
  A & January & 5 \\
  B & January & 4 \\
  C & January & 6 \\
  A & February & 7 \\
  B & February & 7 \\
  C & February & 7 \\
  A & March & 9 \\
  B & March & 9 \\
  C & March & 8 \\
  \bottomrule
\end{tabular}}
\end{footnotesize}
\caption{Wide (left) and long (right) data formats.}\label{fig:wide:long:data}
\end{figure}

It is rather frequently used when observations in each subject are repeated in time. In this case, there is one row per subject and one column for each combination of response variable and time of measurement. Real-world data at the time of acquisition are rather frequently stored in the wide format, or even in ad-hoc non-rectangular formats, so in many cases the first task in data analysis is to reshape the data. Package \pkgname{tidyr} provides functions for reshaping data from wide to long form and \emph{vice versa}.

\begin{warningbox}
Package \pkgname{tidyr} replaced package \pkgname{reshape2}, which in turn replaced package \pkgname{reshape}, while additionally the functions implemented in \pkgname{tidyr} have been recently replaced by new ones with different syntax and name. If a data analyst uses these functions every day, the cost involved is frequently tolerable or even desirable given the improvements. However, for \Rlang users in applied fields, to whom this book is targeted, in the long run using function \Rfunction{reshape()} from base \Rlang can be better, even when its syntax is not as straightforward (see section \ref{sec:calc:reshape} on page \pageref{sec:calc:reshape}). This does not detract from the advantages of using a clear workflow as emphasised by the proponents of the \emph{tidyverse}. Here I only want to emphasise that using some of the packages from the \pkgname{tidyverse} as with any software with an evolving user interface can have in some cases a cost that needs to be taken into consideration.
\end{warningbox}

I use in examples below the \Rdata{iris} data set included in base \Rlang. Some operations on \Rlang \code{data.frame} objects with functions and operators from the \pkgname{tidyverse} packages will return \code{data.frame} objects while others will return tibbles---i.e., \Rclass{"tb"} objects. Consequently, it is safer to first convert into tibbles the data frames we will work with.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{iris.tb} \hlkwb{<-} \hlkwd{as_tibble}\hlstd{(iris)}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{pivot\_longer()} from \pkgname{tidyr} converts data from wide form into long form (or ''tidy''). We use it here to obtain a long-form tibble. By comparing \code{iris.tb} with \code{long\_iris.tb} we can appreciate how \Rfunction{pivot\_longer()} reshaped its input.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{long_iris.tb} \hlkwb{<-}
  \hlkwd{pivot_longer}\hlstd{(iris.tb,}
               \hlkwc{cols} \hlstd{=} \hlopt{-}\hlstd{Species,}
               \hlkwc{names_to} \hlstd{=} \hlstr{"part"}\hlstd{,}
               \hlkwc{values_to} \hlstd{=} \hlstr{"dimension"}\hlstd{)}
\hlstd{long_iris.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 600 x 3
##   Species part         dimension
##   <fct>   <chr>            <dbl>
## 1 setosa  Sepal.Length       5.1
## 2 setosa  Sepal.Width        3.5
## 3 setosa  Petal.Length       1.4
## # i 597 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
  Differently to base \Rlang, in most functions from the \pkgname{tidyverse} packages we can use bare column names preceded by a minus sign to signify ``all other columns''.
\end{warningbox}

Function \Rfunction{pivot\_wider()} does not directly implement the exact inverse operation of \Rfunction{pivot\_longer()}. With multiple rows with shared codes, i.e., replication, in our case within each species and flower part, the returned tibble has columns that are lists of vectors. We need to expand these columns with function \Rfunction{unnest()} in a second step.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{wide_iris.tb} \hlkwb{<-}
  \hlkwd{pivot_wider}\hlstd{(long_iris.tb,}
              \hlkwc{names_from} \hlstd{=} \hlstr{"part"}\hlstd{,}
              \hlkwc{values_from} \hlstd{=} \hlstr{"dimension"}\hlstd{,}
              \hlkwc{values_fn} \hlstd{= list) |>}
  \hlkwd{unnest}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlopt{-}\hlstd{Species)}
\hlstd{wide_iris.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 150 x 5
##   Species Sepal.Length Sepal.Width Petal.Length Petal.Width
##   <fct>          <dbl>       <dbl>        <dbl>       <dbl>
## 1 setosa           5.1         3.5          1.4         0.2
## 2 setosa           4.9         3            1.4         0.2
## 3 setosa           4.7         3.2          1.3         0.2
## # i 147 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Is \code{wide\_iris.tb} equal to \code{iris.tb}, the tibble we converted into long shape and back into wide shape? Run the comparisons below, and print the tibbles to find out.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{identical}\hlstd{(iris.tb, wide_iris.tb)}
\hlkwd{all.equal}\hlstd{(iris.tb, wide_iris.tb)}
\hlkwd{all.equal}\hlstd{(iris.tb, wide_iris.tb[ ,} \hlkwd{colnames}\hlstd{(iris.tb)])}
\end{alltt}
\end{kframe}
\end{knitrout}

What has changed? Would it matter if our code used indexing with a numeric vector to extract columns? or if it used column names as character strings?

\end{playground}

\begin{warningbox}
  Starting from version 1.0.0 of \pkgname{tidyr}, functions \Rfunction{gather()} and \Rfunction{spread()} are deprecated and replaced by functions \Rfunction{pivot\_longer()} and \Rfunction{pivot\_wider()}. These new functions, described above, use a different syntax than the old ones.
\end{warningbox}

%Base \Rlang function \Rfunction{reshape()} can do both operations, selected by passing it an argument. The names of the parameters are different and the manipulation of names is not built in as in the \pkgname{tidyr} functions.  Package \pkgname{poorman} provides a light-weight and dependency-free implementation of the core functions of package \pkgname{dplyr} and well as its own versions of functions \Rfunction{pivot\_longer()} and \Rfunction{pivot\_wider()}.
%
\begin{advplayground}
  Functions \Rfunction{pivot\_longer()} and \Rfunction{pivot\_wider()} from package \pkgname{poorman} attempt to replicate the behaviour of the same name functions from package \pkgname{tidyr}. In some edge cases, the behaviour differs. Test if the two code chunks above return identical or equal values when \code{poorman::}  is prepended to the names of these two functions. First, ensure that package \pkgname{poorman} is installed, then run the code below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{poor_long_iris.tb} \hlkwb{<-}
  \hlstd{poorman}\hlopt{::}\hlkwd{pivot_longer}\hlstd{(}
    \hlstd{iris,}
    \hlkwc{cols} \hlstd{=} \hlopt{-}\hlstd{Species,}
    \hlkwc{names_to} \hlstd{=} \hlstr{"part"}\hlstd{,}
    \hlkwc{values_to} \hlstd{=} \hlstr{"dimension"}\hlstd{)}
\hlkwd{identical}\hlstd{(long_iris.tb, poor_long_iris.tb)}
\hlkwd{all.equal}\hlstd{(long_iris.tb, poor_long_iris.tb)}
\hlkwd{class}\hlstd{(long_iris.tb)}
\hlkwd{class}\hlstd{(poor_long_iris.tb)}
\end{alltt}
\end{kframe}
\end{knitrout}

What is the difference between the values returned by the two functions? Could switching from package \pkgname{tidyr} to package \pkgname{poorman} affect code downstream of pivoting?
\end{advplayground}
\index{reshaping tibbles|)}

\section{Data Manipulation with \pkgname{dplyr}}\label{sec:dplyr:manip}
\index{data manipulation in the tidyverse|(}

The first advantage a user of the \pkgname{dplyr} functions and methods sees is the completeness of the set of operations supported and the symmetry and consistency among the different functions. A second advantage is that almost all the functions are defined not only for objects of class \Rclass{tibble}, but also for objects of class \code{data.table} (package \pkgname{dtplyr}) and for SQL databases (package \pkgname{dbplyr}), with consistent syntax (see also section \ref{sec:data:db} on page \pageref{sec:data:db}). As discussed above, using a code base that is not yet fully stable has a cost that needs to be balanced against the gain obtained from its use.

\subsection{Row-wise manipulations}
\index{row-wise operations on data|(}

Assuming that the data are stored in long form, row-wise operations are operations combining values from the same observation event---i.e., calculations within a single row of a data frame or tibble (see section \ref{sec:calc:df:with} on page \pageref{sec:calc:df:with} for the base \Rlang approach). Using functions \Rfunction{mutate()} and \Rfunction{transmute()} we can obtain derived quantities by combining different variables, or variables and constants, or applying a mathematical transformation. We add new variables (columns) retaining existing ones using \Rfunction{mutate()} or we assemble a new tibble containing only the columns we explicitly specify using \Rfunction{transmute()}.

\begin{explainbox}
Different from usual \Rlang syntax, with \Rfunction{tibble()}, \Rfunction{mutate()} and \Rfunction{transmute()} we can use values passed as arguments, in the statements computing the values passed as later arguments. In many cases, this allows more concise and easier to understand code.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tibble}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{2} \hlopt{*} \hlstd{a)}
\end{alltt}
\begin{verbatim}
## # A tibble: 5 x 2
##       a     b
##   <int> <dbl>
## 1     1     2
## 2     2     4
## 3     3     6
## # i 2 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

Continuing with the example from the previous section, a likely next step would be to split the values in variable \code{part} into \code{plant\_part} and \code{part\_dim}. We use \code{mutate()} from \pkgname{dplyr} and \Rfunction{str\_extract()} from \pkgname{stringr} (a package included in the \pkgname{tidyverse}, aimed at the manipulation of character strings). We use regular expressions (see section \ref{sec:calc:regex} on page \pageref{sec:calc:regex}) as arguments passed to \code{pattern}.  We do not show it here, but \Rfunction{mutate()} can be used with variables of any \code{mode}, and calculations can involve values from several columns. It is even possible to operate on values applying a lag or, in other words, using rows displaced relative to the current one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{long_iris.tb |>}
  \hlkwd{mutate}\hlstd{(}\hlkwc{plant_part} \hlstd{=} \hlkwd{str_extract}\hlstd{(part,} \hlstr{"^[:alpha:]*"}\hlstd{),}
         \hlkwc{part_dimension} \hlstd{=} \hlkwd{str_extract}\hlstd{(part,} \hlstr{"[:alpha:]*$"}\hlstd{))} \hlkwb{->} \hlstd{long_iris.tb}
\hlstd{long_iris.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 600 x 5
##   Species part         dimension plant_part part_dimension
##   <fct>   <chr>            <dbl> <chr>      <chr>         
## 1 setosa  Sepal.Length       5.1 Sepal      Length        
## 2 setosa  Sepal.Width        3.5 Sepal      Width         
## 3 setosa  Petal.Length       1.4 Petal      Length        
## # i 597 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

In the next few chunks, returned values are displayed, while in normal use they would assigned to variables or passed to the next function in a pipe using \Roperator{\textbar >}.
Function \Rfunction{arrange()} is used to sort rows---it makes sorting a data frame or tibble simpler than when using \Rfunction{sort()} or \Rfunction{order()}. Below, \code{long\_iris.tb} rows are sorted based on the values in three of its columns.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{arrange}\hlstd{(long_iris.tb, Species, plant_part, part_dimension)}
\end{alltt}
\begin{verbatim}
## # A tibble: 600 x 5
##   Species part         dimension plant_part part_dimension
##   <fct>   <chr>            <dbl> <chr>      <chr>         
## 1 setosa  Petal.Length       1.4 Petal      Length        
## 2 setosa  Petal.Length       1.4 Petal      Length        
## 3 setosa  Petal.Length       1.3 Petal      Length        
## # i 597 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{filter()} can be used to extract a subset of rows---similar to \Rfunction{subset()} but with a syntax consistent with that of other functions in the \pkgname{tidyverse}. In this case, 300 out of the original 600 rows are retained.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{filter}\hlstd{(long_iris.tb, plant_part} \hlopt{==} \hlstr{"Petal"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # A tibble: 300 x 5
##   Species part         dimension plant_part part_dimension
##   <fct>   <chr>            <dbl> <chr>      <chr>         
## 1 setosa  Petal.Length       1.4 Petal      Length        
## 2 setosa  Petal.Width        0.2 Petal      Width         
## 3 setosa  Petal.Length       1.4 Petal      Length        
## # i 297 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{slice()} can be used to extract a subset of rows based on their positions---an operation that in base \Rlang would use positional (numeric) indexes with the \code{[ , ]} operator: \code{long\_iris.tb[1:5, ]}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{slice}\hlstd{(long_iris.tb,} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # A tibble: 5 x 5
##   Species part         dimension plant_part part_dimension
##   <fct>   <chr>            <dbl> <chr>      <chr>         
## 1 setosa  Sepal.Length       5.1 Sepal      Length        
## 2 setosa  Sepal.Width        3.5 Sepal      Width         
## 3 setosa  Petal.Length       1.4 Petal      Length        
## # i 2 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{select()} can be used to extract a subset of columns---this would be done with positional (numeric) indexes with \code{[ , ]}, passing them to the second argument as numeric indexes or column names in a vector. It is also possible to use function \Rfunction{subset()} from base \Rlang (see section \ref{sec:calc:df:subset} on page \pageref{sec:calc:df:subset}). Negative indexes in base \Rlang can only be numeric, while \Rfunction{select()} accepts bare column names prepended with a minus for exclusion.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{select}\hlstd{(long_iris.tb,} \hlopt{-}\hlstd{part)}
\end{alltt}
\begin{verbatim}
## # A tibble: 600 x 4
##   Species dimension plant_part part_dimension
##   <fct>       <dbl> <chr>      <chr>         
## 1 setosa        5.1 Sepal      Length        
## 2 setosa        3.5 Sepal      Width         
## 3 setosa        1.4 Petal      Length        
## # i 597 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

In addition, \Rfunction{select()} as other functions in \pkgname{dplyr} accepts ``selectors'' returned by functions \Rfunction{starts\_with()}, \Rfunction{ends\_with()}, \Rfunction{contains()}, and \Rfunction{matches()} to extract or retain columns. For this example, we use the wide-shaped \code{iris.tb} instead of \code{long\_iris.tb}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{select}\hlstd{(iris.tb,} \hlopt{-}\hlkwd{starts_with}\hlstd{(}\hlstr{"Sepal"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## # A tibble: 150 x 3
##   Petal.Length Petal.Width Species
##          <dbl>       <dbl> <fct>  
## 1          1.4         0.2 setosa 
## 2          1.4         0.2 setosa 
## 3          1.3         0.2 setosa 
## # i 147 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{select}\hlstd{(iris.tb, Species,} \hlkwd{matches}\hlstd{(}\hlstr{"pal"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## # A tibble: 150 x 3
##   Species Sepal.Length Sepal.Width
##   <fct>          <dbl>       <dbl>
## 1 setosa           5.1         3.5
## 2 setosa           4.9         3  
## 3 setosa           4.7         3.2
## # i 147 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{rename()} can be used to rename columns, whereas base \Rlang requires the use of both \Rfunction{names()} and \Rfunction{names()<-} and \emph{ad hoc} code to match new and old names. As shown below, the syntax for each column name to be changed is \code{<new name> = <old name>}. The two names can be given either as bare names as below or as character strings.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{long_iris.tb |>}
\hlkwd{select}\hlstd{(}\hlopt{-}\hlstd{part) |>}
\hlkwd{rename}\hlstd{(}\hlkwc{part} \hlstd{= plant_part,} \hlkwc{size} \hlstd{= dimension,} \hlkwc{dimension} \hlstd{= part_dimension)}
\end{alltt}
\begin{verbatim}
## # A tibble: 600 x 4
##   Species  size part  dimension
##   <fct>   <dbl> <chr> <chr>    
## 1 setosa    5.1 Sepal Length   
## 2 setosa    3.5 Sepal Width    
## 3 setosa    1.4 Petal Length   
## # i 597 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}
\index{row-wise operations on data|)}

\begin{explainbox}
  Several of the functions described in this section were needed because operator \Roperator{\%>\%}) from package \pkgname{magrittr} did not support the use of the extraction operators in the rhs using operator syntax. Operator \Roperator{\textbar >} starting from \Rlang version 4.3.0 does not have this limitation (see section \ref{sec:script:pipes} on page \pageref{sec:script:pipes}), however, the functions from \pkgname{dplyr} remain useful as they allow more concise and clear coding of complex conditions.
\end{explainbox}

\subsection{Group-wise manipulations}\label{sec:dplyr:group:wise}
\index{group-wise operations on data|(}

Another important operation is to summarise quantities by groups of rows. Contrary to base \Rlang, the grammar of data manipulation as implemented in \pkgname{dplyr}, makes it possible to split this operation into two steps: the setting of the grouping, and the calculation of summaries. This simplifies the code, making it more easily understandable when using pipes compared to the approach of base \Rlang \Rfunction{aggregate()} (see section \ref{sec:calc:df:aggregate} on page \pageref{sec:calc:df:aggregate}).

\begin{warningbox}
  In early 2023, package \pkgname{dplyr} version 1.1.0 added support for per-operation grouping by adding to functions a new parameter (\code{by} or \code{.by}). This is still considered an experimental feature that may change. Anyway, it is important to keep in mind that this new approach to grouping is not persistent like that described above. Depending on the circumstances, persistence can simplify the code but also create bugs when not taken into account.
\end{warningbox}

When using persistent grouping, the first step is to use \Rfunction{group\_by()} to ``tag'' a tibble with the grouping. We create a \emph{tibble} and then convert it into a \emph{grouped tibble}. Once we have a grouped tibble, function \Rfunction{summarise()} will recognise the grouping and use it when the summary values are calculated.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tibble}\hlstd{(}\hlkwc{numbers} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{9}\hlstd{,} \hlkwc{Letters} \hlstd{=} \hlkwd{rep}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],} \hlnum{3}\hlstd{)) |>}
  \hlkwd{group_by}\hlstd{(Letters) |>}
  \hlkwd{summarise}\hlstd{(}\hlkwc{mean_num} \hlstd{=} \hlkwd{mean}\hlstd{(numbers),}
            \hlkwc{median_num} \hlstd{=} \hlkwd{median}\hlstd{(numbers),}
            \hlkwc{n} \hlstd{=} \hlkwd{n}\hlstd{()) |>}
  \hlkwd{ungroup}\hlstd{()} \hlcom{# not always needed but safer}
\end{alltt}
\begin{verbatim}
## # A tibble: 3 x 4
##   Letters mean_num median_num     n
##   <chr>      <dbl>      <int> <int>
## 1 a              4          4     3
## 2 b              5          5     3
## 3 c              6          6     3
\end{verbatim}
\end{kframe}
\end{knitrout}
\pagebreak

In the non-persistent grouping approach, we specify the grouping in the call to \Rfunction{summarise()} (this new feature is labelled as experimental in \pkgname{dplyr} version 1.1.3, and may change in future versions).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tibble}\hlstd{(}\hlkwc{numbers} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{9}\hlstd{,} \hlkwc{Letters} \hlstd{=} \hlkwd{rep}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],} \hlnum{3}\hlstd{)) |>}
  \hlkwd{summarise}\hlstd{(}\hlkwc{.by} \hlstd{= Letters,}
            \hlkwc{mean_num} \hlstd{=} \hlkwd{mean}\hlstd{(numbers),}
            \hlkwc{median_num} \hlstd{=} \hlkwd{median}\hlstd{(numbers),}
            \hlkwc{n} \hlstd{=} \hlkwd{n}\hlstd{())}
\end{alltt}
\begin{verbatim}
## # A tibble: 3 x 4
##   Letters mean_num median_num     n
##   <chr>      <dbl>      <int> <int>
## 1 a              4          4     3
## 2 b              5          5     3
## 3 c              6          6     3
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
How is grouping implemented for data frames and tibbles?\index{grouping!implementation in tidyverse} Best way to find out is to explore how a grouped tibble differs from one that is not grouped.

Tibble \code{my.tb} is not grouped.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.tb} \hlkwb{<-} \hlkwd{tibble}\hlstd{(}\hlkwc{numbers} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{9}\hlstd{,} \hlkwc{Letters} \hlstd{=} \hlkwd{rep}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{3}\hlstd{],} \hlnum{3}\hlstd{))}
\hlkwd{is.grouped_df}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(my.tb)}
\end{alltt}
\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(}\hlkwd{attributes}\hlstd{(my.tb))}
\end{alltt}
\begin{verbatim}
## [1] "class"     "row.names" "names"
\end{verbatim}
\end{kframe}
\end{knitrout}

Tibble \code{my\_gr.tb} is grouped by variable, or column, \code{Letters}. In this case, as our tibble belongs to class \code{tibble\_df}, grouping adds \code{grouped\_df} as the most derived class.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_gr.tb} \hlkwb{<-} \hlkwd{group_by}\hlstd{(}\hlkwc{.data} \hlstd{= my.tb, Letters)}
\hlkwd{is.grouped_df}\hlstd{(my_gr.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(my_gr.tb)}
\end{alltt}
\begin{verbatim}
## [1] "grouped_df" "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\end{kframe}
\end{knitrout}

Grouping also adds several attributes with the grouping information in a format suitable for fast selection of group members.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{names}\hlstd{(}\hlkwd{attributes}\hlstd{(my_gr.tb))}
\end{alltt}
\begin{verbatim}
## [1] "class"     "row.names" "names"     "groups"
\end{verbatim}
\begin{alltt}
\hlkwd{setdiff}\hlstd{(}\hlkwd{attributes}\hlstd{(my_gr.tb),} \hlkwd{attributes}\hlstd{(my.tb))}
\end{alltt}
\begin{verbatim}
## $class
## [1] "grouped_df" "tbl_df"     "tbl"        "data.frame"
## 
## $groups
## # A tibble: 3 x 2
##   Letters       .rows
##   <chr>   <list<int>>
## 1 a               [3]
## 2 b               [3]
## 3 c               [3]
\end{verbatim}
\end{kframe}
\end{knitrout}

A call to \Rfunction{ungroup()} removes the grouping, thereby restoring the original tibble.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_ugr.tb} \hlkwb{<-} \hlkwd{ungroup}\hlstd{(my_gr.tb)}
\hlkwd{class}\hlstd{(my_ugr.tb)}
\end{alltt}
\begin{verbatim}
## [1] "tbl_df"     "tbl"        "data.frame"
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(}\hlkwd{attributes}\hlstd{(my_ugr.tb))}
\end{alltt}
\begin{verbatim}
## [1] "class"     "row.names" "names"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{all}\hlstd{(my.tb} \hlopt{==} \hlstd{my_gr.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{all}\hlstd{(my.tb} \hlopt{==} \hlstd{my_ugr.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(my.tb, my_gr.tb)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{identical}\hlstd{(my.tb, my_ugr.tb)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

The tests above show that members are in all cases the same as operator \Roperator{==} tests for equality at each position in the tibble but not the attributes, while attributes, including \code{class}, differ between normal tibbles and grouped ones and so they are not \emph{identical} objects.

If we replace \code{tibble} by \code{data.frame} in the first statement, and rerun the chunk, the result of the last statement in the chunk is \code{FALSE} instead of \code{TRUE}. At the time of writing starting with a \code{data.frame} object, applying grouping with \Rfunction{group\_by()} followed by ungrouping with \Rfunction{ungroup()} has the side effect of converting the data frame into a tibble. This is something to be very much aware of, as there are differences in how the extraction operator \Roperator{[ , ]} behaves in the two cases. The safe way to write code making use of functions from \pkgname{dplyr} and \pkgname{tidyr} is to always make sure that subsequent code works correctly with tibbles in addition to with data frames.
\end{warningbox}
\index{group-wise operations on data|)}

\subsection{Joins}
\index{joins between data sources|(}
\index{merging data from two tibbles|(}
Joins allow us to combine two data sources which share some variables. Variables in common are used to match the corresponding rows before ``joining'' variables (i.e., columns) from both sources together. There are several \emph{join} functions in \pkgname{dplyr}. They differ mainly in how they handle rows that do not have a match between data sources.

We create here some artificial data to demonstrate the use of these functions. We will create two small tibbles, with one column in common and one mismatched row in each.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{first.tb} \hlkwb{<-} \hlkwd{tibble}\hlstd{(}\hlkwc{idx} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwc{values1} \hlstd{=} \hlstr{"a"}\hlstd{)}
\hlstd{second.tb} \hlkwb{<-} \hlkwd{tibble}\hlstd{(}\hlkwc{idx} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{4}\hlstd{,} \hlnum{6}\hlstd{),} \hlkwc{values2} \hlstd{=} \hlstr{"b"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Below, we apply the \emph{}\index{joins between data sources!mutating} functions exported by \pkgname{dplyr}: \Rfunction{full\_join()}, \Rfunction{left\_join()}, \Rfunction{right\_join()} and \Rfunction{inner\_join()}. These functions always retain all columns, and in case of multiple matches, they keep a row for each matching combination of rows. We repeat each of these examples with the arguments passed to \code{x} and \code{y} swapped to show the differences in the behaviour of these functions.

A full join retains all unmatched rows filling missing values with \code{NA}. By default, the match is done on columns with the same name in \code{x} and \code{y}, but this can be changed by passing an argument to parameter \code{by}. Using \code{by} one can base the match on columns that have different names in \code{x} and \code{y}, or prevent matching of columns with the same name in \code{x} and \code{y} (example at end of the section).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{full_join}\hlstd{(}\hlkwc{x} \hlstd{= first.tb,} \hlkwc{y} \hlstd{= second.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 6 x 3
##     idx values1 values2
##   <dbl> <chr>   <chr>  
## 1     1 a       b      
## 2     2 a       b      
## 3     3 a       b      
## 4     4 a       b      
## 5     5 a       <NA>   
## 6     6 <NA>    b
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{full_join}\hlstd{(}\hlkwc{x} \hlstd{= second.tb,} \hlkwc{y} \hlstd{= first.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 6 x 3
##     idx values2 values1
##   <dbl> <chr>   <chr>  
## 1     1 b       a      
## 2     2 b       a      
## 3     3 b       a      
## 4     4 b       a      
## 5     6 b       <NA>   
## 6     5 <NA>    a
\end{verbatim}
\end{kframe}
\end{knitrout}

Left and right joins retain rows not matched from only one of the two data sources, \code{x} and \code{y}, respectively.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{left_join}\hlstd{(}\hlkwc{x} \hlstd{= first.tb,} \hlkwc{y} \hlstd{= second.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 5 x 3
##     idx values1 values2
##   <dbl> <chr>   <chr>  
## 1     1 a       b      
## 2     2 a       b      
## 3     3 a       b      
## 4     4 a       b      
## 5     5 a       <NA>
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{left_join}\hlstd{(}\hlkwc{x} \hlstd{= second.tb,} \hlkwc{y} \hlstd{= first.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 5 x 3
##     idx values2 values1
##   <dbl> <chr>   <chr>  
## 1     1 b       a      
## 2     2 b       a      
## 3     3 b       a      
## 4     4 b       a      
## 5     6 b       <NA>
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{right_join}\hlstd{(}\hlkwc{x} \hlstd{= first.tb,} \hlkwc{y} \hlstd{= second.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 5 x 3
##     idx values1 values2
##   <dbl> <chr>   <chr>  
## 1     1 a       b      
## 2     2 a       b      
## 3     3 a       b      
## 4     4 a       b      
## 5     6 <NA>    b
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{right_join}\hlstd{(}\hlkwc{x} \hlstd{= second.tb,} \hlkwc{y} \hlstd{= first.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 5 x 3
##     idx values2 values1
##   <dbl> <chr>   <chr>  
## 1     1 b       a      
## 2     2 b       a      
## 3     3 b       a      
## 4     4 b       a      
## 5     5 <NA>    a
\end{verbatim}
\end{kframe}
\end{knitrout}

An inner join discards rows in \code{x} that do not match rows in \code{y} and \emph{vice versa}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{inner_join}\hlstd{(}\hlkwc{x} \hlstd{= first.tb,} \hlkwc{y} \hlstd{= second.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 4 x 3
##     idx values1 values2
##   <dbl> <chr>   <chr>  
## 1     1 a       b      
## 2     2 a       b      
## 3     3 a       b      
## 4     4 a       b
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{inner_join}\hlstd{(}\hlkwc{x} \hlstd{= second.tb,} \hlkwc{y} \hlstd{= first.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 4 x 3
##     idx values2 values1
##   <dbl> <chr>   <chr>  
## 1     1 b       a      
## 2     2 b       a      
## 3     3 b       a      
## 4     4 b       a
\end{verbatim}
\end{kframe}
\end{knitrout}

Next we apply the \emph{filtering join}\index{joins between data sources!filtering} functions exported by \pkgname{dplyr}: \Rfunction{semi\_join()} and \Rfunction{anti\_join()}. These functions only return a tibble that contains only the columns from \code{x}, retaining rows based on their match to rows in \code{y}.

A semi join retains rows from \code{x} that have a match in \code{y}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{semi_join}\hlstd{(}\hlkwc{x} \hlstd{= first.tb,} \hlkwc{y} \hlstd{= second.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 4 x 2
##     idx values1
##   <dbl> <chr>  
## 1     1 a      
## 2     2 a      
## 3     3 a      
## 4     4 a
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{semi_join}\hlstd{(}\hlkwc{x} \hlstd{= second.tb,} \hlkwc{y} \hlstd{= first.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 4 x 2
##     idx values2
##   <dbl> <chr>  
## 1     1 b      
## 2     2 b      
## 3     3 b      
## 4     4 b
\end{verbatim}
\end{kframe}
\end{knitrout}

A anti-join retains rows from \code{x} that do not have a match in \code{y}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anti_join}\hlstd{(}\hlkwc{x} \hlstd{= first.tb,} \hlkwc{y} \hlstd{= second.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 1 x 2
##     idx values1
##   <dbl> <chr>  
## 1     5 a
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{anti_join}\hlstd{(}\hlkwc{x} \hlstd{= second.tb,} \hlkwc{y} \hlstd{= first.tb)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(idx)`}}\begin{verbatim}
## # A tibble: 1 x 2
##     idx values2
##   <dbl> <chr>  
## 1     6 b
\end{verbatim}
\end{kframe}
\end{knitrout}

We here rename column \code{idx} in \code{first.tb} to demonstrate the use of \code{by} to specify which columns should be searched for matches.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{first2.tb} \hlkwb{<-} \hlkwd{rename}\hlstd{(first.tb,} \hlkwc{idx2} \hlstd{= idx)}
\hlkwd{full_join}\hlstd{(}\hlkwc{x} \hlstd{= first2.tb,} \hlkwc{y} \hlstd{= second.tb,} \hlkwc{by} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"idx2"} \hlstd{=} \hlstr{"idx"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## # A tibble: 6 x 3
##    idx2 values1 values2
##   <dbl> <chr>   <chr>  
## 1     1 a       b      
## 2     2 a       b      
## 3     3 a       b      
## 4     4 a       b      
## 5     5 a       <NA>   
## 6     6 <NA>    b
\end{verbatim}
\end{kframe}
\end{knitrout}
\index{merging data from two tibbles|)}
\index{joins between data sources|)}
\index{data manipulation in the tidyverse|)}



\section{Times and Dates with \pkgname{lubridate}}\label{sec:data:datetime}
\index{time and dates|(}
In \Rlang and many other computing languages, time values are stored as integer values subject to special interpretation. In \Rlang, times are most frequently stored as objects of class \code{POSIXct} or \code{POSIXlt}. Package \pkgname{lubridate} makes working with dates and times in \Rlang much easier.

When\index{time and dates!universal time coordinates}\index{time and dates!local time}\index{time and dates!time zones} dealing with time values, first of all, it is necessary to distinguish universal time coordinates (UTC) and local time coordinates. An instant in time is an absolute value and can be unambiguously described using UTC. Local times are different representations of a given instant in time, using local time coordinates such as CET (central European Time). The relationship between UTC and local times depends on country legislation, national borders, and in some cases, time zones within countries. In addition, many countries make use a seasonal shift in the local time coordinates, the so called ``summer time''. The dates on which these seasonal shifts are implemented depends on the country or region, and these dates have varied over time. Shifts in local time create gaps and overlaps: some local time values correspond to two different time instants, and the skipped ones do not exist and when encountered should be handled as errors.

\begin{explainbox}
Different systems are in use to describe time zones and the corresponding time coordinates. One commonly used is based on three or four letter codes, e.g., EET for Eastern European Time. Another commonly used one is based on the names of continents and cities, e.g., Europe/Helsinki. A third one in common use is simply expressed as an offset in hours, e.g., UTC+3. Most time zones have time shifts of whole hours and few to half hours. To some extent, what names are recognised depends on the operating system under which \Rpgrm is running. See \url{https://en.wikipedia.org/wiki/List_of_tz_database_time_zones} for a list.
\end{explainbox}

Periodical adjustments introduced by leap years, and even leap seconds need to be taken into account when computing time durations between instants in time, even when using UTC. When carrying out arithmetic operations on dates and times, all these ``irregularities'' have to be accounted for. The functions and operators from package \pkgname{lubridate} implement the necessary corrections for current and historical times.

Times and dates written as text are formatted rather inconsistently depending on the customs of different cultures and languages. Package \pkgname{lubridate} also provides functions implementing conversions between character strings and times or dates and back. These \code{character} to time conversions are based on patterns, and are, in general, reliable if the correct pattern is used. Package \pkgname{anytime} defines functions that can decode a broad range of formats, but relying on them can be risky, as not all possible formats are correctly decoded.

Objects of class \Rclass{POSIXlt}, the class used in \Rlang to store dates and times in a partly formatted form, do not necessarily contain time zone information. In many cases, when used in computations \Rclass{POSIXlt} values are interpreted based on the locale settings under which \Rlang is running, e.g., the time zone settings of the computer. Objects of class \Rclass{Date} do not keep track of the time zone, so do not represent instants in time traceable to UTC.

\begin{warningbox}
  Whenever possible, it is best to store time data and also dates encoded using UTC as \Rclass{POSIXct} objects. This eliminates uncertainties that can cause otherwise major difficulties in computations.
\end{warningbox}

\Rclass{POSIXct} objects are of mode numeric, and thus vectors; because of this, they can be stored as columns in data frames and tibbles. Some statistical functions and even some model fitting functions accept them as input.

Current date can be easily queried, and the returned value is fetched from the computer's clock.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{this.day} \hlkwb{<-} \hlkwd{today}\hlstd{()}
\hlkwd{class}\hlstd{(this.day)}
\end{alltt}
\begin{verbatim}
## [1] "Date"
\end{verbatim}
\begin{alltt}
\hlkwd{as.POSIXct}\hlstd{(this.day,} \hlkwc{tz} \hlstd{=} \hlstr{""}\hlstd{)} \hlcom{# local time zone}
\end{alltt}
\begin{verbatim}
## [1] "2024-02-17 02:00:00 EET"
\end{verbatim}
\end{kframe}
\end{knitrout}

Similarly, the current instant in time can be retrieved. Resolution is in the order of milliseconds.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{this.instant} \hlkwb{<-} \hlkwd{now}\hlstd{()}
\hlkwd{class}\hlstd{(this.instant)}
\end{alltt}
\begin{verbatim}
## [1] "POSIXct" "POSIXt"
\end{verbatim}
\begin{alltt}
\hlstd{this.instant}
\end{alltt}
\begin{verbatim}
## [1] "2024-02-17 03:38:50 EET"
\end{verbatim}
\end{kframe}
\end{knitrout}

Conversion from character strings to \Rclass{POSIXct} is straightforward as long as all character strings to be converted have the same or very similarly formatted. A family of functions from \pkgname{lubridate} with names like \Rfunction{dmy\_hms()} can convert character strings into \Rclass{POSIXct} objects. These functions are vectorised and can convert a whole character vector in a single operation into a \Rclass{POSIXct} vector of the same length.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dmy_h}\hlstd{(}\hlstr{"04/10/23 15"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"EET"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2023-10-04 15:00:00 EEST"
\end{verbatim}
\begin{alltt}
\hlkwd{dmy_h}\hlstd{(}\hlstr{"04/10/23 3pm"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"EET"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2023-10-04 15:00:00 EEST"
\end{verbatim}
\begin{alltt}
\hlkwd{dmy_h}\hlstd{(}\hlstr{"04/10/23 15 EET"}\hlstd{)} \hlcom{# Wrong decoding!}
\end{alltt}
\begin{verbatim}
## [1] "2023-10-04 15:00:00 UTC"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
Conversion functions with no time components return \Rclass{Date} objects if no argument is passed to \code{tz}, while \code{tz = ""}, as used below, signifies the local time zone.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2023-10-04"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "Date"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2023-10-04"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{""}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "POSIXct" "POSIXt"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(}\hlkwd{today}\hlstd{(}\hlkwc{tzone} \hlstd{=} \hlstr{""}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "Date"
\end{verbatim}
\end{kframe}
\end{knitrout}

Conversions from \code{Date} into \code{POSIXct} can give very unexpected results! If you run the statement below, the returned value will be the time difference between the time setting in your computer and UTC!

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{as.POSIXct}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2023-10-04"}\hlstd{),} \hlkwc{tzone} \hlstd{=} \hlstr{""}\hlstd{)} \hlopt{-} \hlkwd{ymd}\hlstd{(}\hlstr{"2023-10-04"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{""}\hlstd{)}
\end{alltt}
\begin{verbatim}
## Time difference of 3 hours
\end{verbatim}
\end{kframe}
\end{knitrout}

The computations assume that the value in the \code{Date} is expressed in UTC, corresponding to 00:00:00 UTC. The time zone difference in UTC at midnight between time zones is not taken into account. Forcing the time zone after conversion in \code{POSIXct} fixes the problem. Quirks like these make it imperative to do extensive checks when doing conversions involving times and or dates.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{force_tz}\hlstd{(}\hlkwd{as.POSIXct}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"2023-10-04"}\hlstd{)),} \hlkwc{tzone} \hlstd{=} \hlstr{""}\hlstd{)} \hlopt{-} \hlkwd{ymd}\hlstd{(}\hlstr{"2023-10-04"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{""}\hlstd{)}
\end{alltt}
\begin{verbatim}
## Time difference of 0 secs
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{warningbox}

A difference between to instants in time returns a duration.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ymd_hms}\hlstd{(}\hlstr{"2010-05-25 12:05:00"}\hlstd{)} \hlopt{-} \hlkwd{ymd_hms}\hlstd{(}\hlstr{"1810-05-25 12:00:00"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## Time difference of 73049 days
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions with names in plural, like \Rfunction{years()} \ldots\ \Rfunction{seconds()} are constructors of durations, and can be added and subtracted from times.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ymd_hms}\hlstd{(}\hlstr{"1810-05-25 12:00:00"}\hlstd{)} \hlopt{+} \hlkwd{years}\hlstd{(}\hlnum{200}\hlstd{)} \hlopt{+} \hlkwd{minutes}\hlstd{(}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2010-05-25 12:05:00 UTC"
\end{verbatim}
\begin{alltt}
\hlkwd{ymd_hms}\hlstd{(}\hlstr{"2010-05-25 12:05:00"}\hlstd{)} \hlopt{-} \hlkwd{ymd_hms}\hlstd{(}\hlstr{"1810-05-25 12:00:00"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## Time difference of 73049 days
\end{verbatim}
\begin{alltt}
\hlkwd{ymd}\hlstd{(}\hlstr{"2023-01-01"}\hlstd{)} \hlopt{+} \hlkwd{seconds}\hlstd{(}\hlnum{123}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2023-01-01 00:02:03 UTC"
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions with names in singular, like \Rfunction{year()} \ldots\ \Rfunction{second()} are used to extract and set the implicit components of an instant in time.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.time} \hlkwb{<-} \hlkwd{now}\hlstd{()}
\hlstd{my.time}
\end{alltt}
\begin{verbatim}
## [1] "2024-02-17 03:38:50 EET"
\end{verbatim}
\begin{alltt}
\hlkwd{year}\hlstd{(my.time)}
\end{alltt}
\begin{verbatim}
## [1] 2024
\end{verbatim}
\begin{alltt}
\hlkwd{hour}\hlstd{(my.time)}
\end{alltt}
\begin{verbatim}
## [1] 3
\end{verbatim}
\begin{alltt}
\hlkwd{second}\hlstd{(my.time)}
\end{alltt}
\begin{verbatim}
## [1] 50.8375
\end{verbatim}
\begin{alltt}
\hlkwd{second}\hlstd{(my.time)} \hlkwb{<-} \hlnum{0}
\end{alltt}
\end{kframe}
\end{knitrout}

Special versions of methods \Rfunction{round()} and \Rfunction{trunc()} are available for times.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{trunc}\hlstd{(my.time,} \hlstr{"days"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2024-02-17 EET"
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(my.time,} \hlstr{"hours"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "2024-02-17 04:00:00 EET"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Working with time data, frequently involves checking that the results of computations are according to our expectations. Sometimes the documentation is not enough and we need to explore with code examples how functions work. For example, take one date in February 2020 and one date in March 2020, and compute the duration between them. Then repeat the computation for year 2022 using the same dates. Which of these years was a leap year?
\end{playground}
\index{time and dates|)}

Ín the next chapter, I describe data visualisation with package \pkgnameNI{ggplot2}, frequently also considered part of the \pkgnameNI{tidyverse}.

\section{Further Reading}
An\index{further reading!new grammars of data} in-depth discussion of the \pkgname{tidyverse} is outside the scope of this book. Several books describe in detail the use of these packages. As several of them are under active development, recent editions of books such as \citebooktitle{Wickham2023a} \autocite{Wickham2023a} and \citebooktitle{Peng2022} \autocite{Peng2022} are the most useful.






% !Rnw root = appendix.main.Rnw



\chapter{\Rlang Extensions: Grammar of Graphics}\label{chap:R:plotting}

\begin{VF}
The commonality between science and art is in trying to see profoundly---to develop strategies of seeing and showing.

\VA{Edward Tufte's answer to Charlotte Thralls}{\emph{An Interview with Edward R. Tufte}, 2004}\nocite{Zachry2004}
\end{VF}

%\dictum[Edward Tufte]{The commonality between science and art is in trying to see profoundly---to develop strategies of seeing and showing.}

\index{geometries ('ggplot2')|see{grammar of graphics, geometries}}
%\index{geom@\texttt{geom}|see{grammar of graphics, geometries}}
%\index{functions!geom@\texttt{geom}|see{grammar of graphics, geometries}}
\index{statistics ('ggplot2')|see{grammar of graphics, statistics}}
%\index{stat@\texttt{stat}|see{grammar of graphics, statistics}}
%\index{functions!stat@\texttt{stat}|see{grammar of graphics, statistics}}
\index{scales ('ggplot2')|see{grammar of graphics, scales}}
%\index{scale@\texttt{scale}|see{grammar of graphics, scales}}
%\index{functions!scale@\texttt{scale}|see{grammar of graphics, scales}}
\index{coordinates ('ggplot2')|see{grammar of graphics, coordinates}}
\index{themes ('ggplot2')|see{grammar of graphics, themes}}
%\index{theme@\texttt{scale}|see{grammar of graphics, themes}}
%\index{function!theme@\texttt{scale}|see{grammar of graphics, themes}}
\index{facets ('ggplot2')|see{grammar of graphics, facets}}
\index{annotations ('ggplot2')|see{grammar of graphics, annotations}}
\index{aesthetics ('ggplot2')|see{grammar of graphics, aesthetics}}

\section{Aims of This Chapter}

Three main data plotting systems are available to \Rlang users: base \Rlang, package \pkgname{lattice} \autocite{Sarkar2008}, and package \pkgname{ggplot2} \autocite{Wickham2016}; the last one being the most recent and currently most popular system available in \Rlang for plotting data. Even two different sets of graphics primitives (i.e., those used to produce the simplest graphical elements such as lines and symbols) are available in \Rlang, those in base \Rlang and a newer one in the \pkgname{grid} package \autocite{Murrell2019}.

In this chapter, you will learn the concepts of the layered grammar of graphics, on which package \pkgname{ggplot2} is based. You will also learn how to build several types of data plots with package \pkgname{ggplot2}. As a consequence of the popularity and flexibility of \pkgname{ggplot2}, many contributed packages extending its functionality have been developed and deposited in public repositories. However, I will focus mainly on package \pkgname{ggplot2} only briefly describing a few of these extensions.

\section{Packages Used in This Chapter}



If the packages used in this chapter are not yet installed in your computer, you can install them as shown below, as long as package \pkgname{learnrbook} is already installed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(learnrbook}\hlopt{::}\hlstd{pkgs_ch_ggplot)}
\end{alltt}
\end{kframe}
\end{knitrout}
\pagebreak

To run the examples included in this chapter, you need first to load some packages from the library (see section \ref{sec:script:packages} on page \pageref{sec:script:packages} for details on the use of packages).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(learnrbook)}
\hlkwd{library}\hlstd{(scales)}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{library}\hlstd{(ggrepel)}
\hlkwd{library}\hlstd{(gginnards)}
\hlkwd{library}\hlstd{(broom)}
\hlkwd{library}\hlstd{(ggpmisc)}
\hlkwd{library}\hlstd{(ggbeeswarm)}
\hlkwd{library}\hlstd{(lubridate)}
\hlkwd{library}\hlstd{(tibble)}
\hlkwd{library}\hlstd{(dplyr)}
\hlkwd{library}\hlstd{(patchwork)}
\end{alltt}
\end{kframe}
\end{knitrout}





\section{The Components of a Plot}
I\index{data visualization!concepts} start by briefly presenting concepts central to data visualisation, following the \citetitle{Koponen2019} \autocite{Koponen2019}. Plots are a medium used to convey information, like text. It is worthwhile keeping this in mind. As with text, the design of plots needs to consider what needs to be highlighted to convey the take home message. The style of the plot should match the expectations and the plot-reading abilities of the expected audience. One needs to be careful to avoid ambiguities and most importantly of all not to miss-inform. Data visualisations like text need to be planned, revised, commented upon, and revised again until the best way of expressing our message is found. The flexibility of the grammar of graphics supports very well this approach to designing and producing high quality data visualisations for different audiences.

Of course, when exploring data, fancy details of graphical design are irrelevant, but flexibility remains important as it makes it possible to look at data from many differing angles, highlighting different aspects of them. In the same way as boiler-plate text and text templates have specific but limited uses, all-in-one functions for producing plots do not support well the design of original data visualisations. They tend to get the job done, but lack the flexibility needed to do the best job of communicating information. Being this a book about languages, the focus of this chapter is in the layered grammar of graphics.

The plots described in this chapter are classified as \emph{statistical graphics}\index{statistical graphics} within the broader field of data visualisation. Plots such as scatter plots include points (geometric objects) that by their position, shape, colour, or some other property directly convey information. The location of these points in the plot ``canvas'' or ``plotting area'', given by the values of their $x$ and $y$ coordinates describes properties of the data and any deviation in the mapping of observations to coordinates is misleading, because deviations from the expected mapping conveys wrong/false information to the audience.

A \emph{data label}\index{data visualization!data labels} is connected to an observation but its position can be displaced as long as its link to the corresponding observation can be inferred, e.g., by the direction of an arrow or even simple proximity. Data labels provide ancillary information, such as the name of a gene or place.

\emph{Annotations}\index{data visualization!annotations}, are additions to a plot that have no connection to individual observations, but rather with all observations taken together, e.g., a text like $n = 200$ indicating the number of observations, usually included in a corner or margin of a plot free of observations.

Axis and tick labels, legends and keys make it possible for the reader to retrieve the original values represented in the plot as graphical elements. Other features of visualisations even when not carrying additional information affect the easy with which a plot can be read and accessibility to readers with visual constraints such as colour blindness. These features include the size of text and symbols, thickness of lines, choice of font face, choice of colour palette, etc.

Because of the different lengths of time available for the audience to interact with visualisations, in general, plots designed to be included in books and journals are unsuitable for oral presentations, and vice versa. It is important to keep in mind the role played by plots in informing the audience, and what information can be expected to be of interest to different audiences and under different situations. The grammar of graphics and its extensions provide enough flexibility to tailor the design of plots to different uses and also to easily create variations of a given plot.

\section{The Grammar of Graphics}\label{sec:plot:intro}
\index{grammar of graphics!elements|(}
What separates \ggplot from base \Rlang and trellis/lattice plotting functions is the use of a layered grammar of graphics\index{grammar of graphics} (the reason behind `gg' in the name of package \pkgname{ggplot2}). What is meant by grammar in this case is that plots are assembled piece by piece using different ``nouns'' and ``verbs'' \autocite{Cleveland1985,Wickham2010}. Instead of using a single function with many arguments, plots are assembled by combining different elements with operators \code{+} and \verb|%+%|. Furthermore, the construction is mostly semantics-based and to a large extent, how plots look when printed, displayed, or exported to a bitmap or vector-graphics file is controlled by themes.

Plotting can be thought as translating or mapping the observations or data into a graphical language. Properties of graphical (or geometrical) objects are used to represent different aspects of the data. An observation can consist of multiple recorded values. Say an observation of air temperature may be defined by a position in 3-dimensional space and a point in time, in addition to the temperature itself. An observation for the size and shape of a plant can consist of height, stem diameter, number of leaves, size of individual leaves, length of roots, fresh mass, dry mass, etc. For example, an effective way of studying and/or communicating the relationship between height and stem diameter in plants, is to plot observations as points using cartesian coordinates\index{grammar of graphics!cartesian coordinates}, \emph{mapping} stem diameter to the $x$ axis and the height to the $y$ axis.

The grammar of graphics makes it possible to design plots by combining various elements in ways that are nearly orthogonal. In other words, the majority of the possible combinations of ``words'' yield valid plots as long the rules of the grammar are respected. This flexibility makes \ggplot extremely powerful as types of plots not considered when the \ggplot package was designed can be easily created.

\begin{warningbox}
When a ggplot is built, the whole plot and its components are created as \Rlang objects that can be saved in the workspace or written to a file as \Rlang objects. These objects encode a recipe for constructing the plot, not its final graphical representation. The graphical representation is generated when the object is printed, explicitly or not. Thus, the same \code{"gg"} plot object can be rendered into different bitmap and vector graphic formats for display and/or printing.
\end{warningbox}

The transformation of a set of data or observations into a rendered graphic with package \pkgname{ggplot2} can be represented as a flow of information, but also as a sequence of actions. However, what avoids that the flexibility from becoming a burden on users is that in most cases adequate defaults are used when the user does not provide explicit ``instructions''. The recipe to build a plot needs to specify a) the data to use, b) which variable to map to which graphical property (or aesthetic), c) which layers to add and which geometric representation to use, d) the scales that establish the link between data values and aesthetic values, e) a coordinate system (affecting only aesthetics $x$, $y$ and possibly $z$), f) a theme to use. The result from constructing a plot object using the grammar of graphics is an \Rlang object containing a ``recipe for a plot'', including the data, which behaves similarly to other \Rlang objects.

\subsection{The words of the grammar}
Before building a plot step by step, I introduce the different components of a ggplot recipe, or the words of the grammar of graphics.

\paragraph{Data}
The\index{grammar of graphics!data} data to be plotted must be available as a \code{data.frame} or \code{tibble}, with data stored so that each row represents a single observation event, and the columns are different values observed in that single event. In other words, in long form (so-called ``tidy data'') as described in chapter \ref{chap:R:data}. The variables to be plotted can be \code{numeric}, \code{factor}, \code{character}, and time or date stored as \code{POSIXct}. (Some extensions to \pkgname{ggplot2} add support for other types of data such as time series).

\paragraph{Mapping}
When\index{grammar of graphics!mapping of data} constructing a plot, data variables have to be mapped to aesthetics\index{plots!aesthetics} (or graphic properties). Most plots will have an $x$ dimension, which is one of the \emph{aesthetics}, and a variable containing numbers (or categories) mapped to it. The position on a 2D plot of, say, a point, will be determined by $x$ and $y$ aesthetics, while in a 3D plot, three aesthetics need to be mapped $x$, $y$, and $z$. Many aesthetics are not related to coordinates, they are properties, like colour, size, shape, line type, or even rotation angle, which add an additional dimension on which to represent the values of variables and/or constants.

\paragraph{Statistics}
Statistics\index{grammar of graphics!statistics} are ``words'' that represent calculation of summaries or some other operation on the values in the data. When \emph{statistics} are used for a computation, the returned value is passed to a \emph{geometry}, and consequently adding a \emph{statistics} also adds a layer to the plot. For example, \ggstat{stat\_smooth()} fits a smoother, and \ggstat{stat\_summary()} applies a summary function such as \code{mean(()}. Most statistics are applied by group when data have been grouped by mapping additional aesthetics such as colour to a factor.

\paragraph{Geometries}
\sloppy%
Geometries\index{grammar of graphics!geometries} are ``words'' that describe the graphics representation of the data: for example, \gggeom{geom\_point()}, plots a point or symbol for each observation or summary value, while \gggeom{geom\_line()}, draws line segments between observations. Some geometries rely by default on statistics, but most ``geoms'' default to the identity statistics. Each time a \emph{geometry} is used to add a graphical representation of data to a plot, one says that a new \emph{layer} has been added. The\index{plots!layers} grammar of graphics allows plots to contain multiple layers. The name \emph{layer} reflects the fact that each new layer added is plotted on top of the layers already present in the plot, or rather when a plot is printed the layers will be generated in the order they were added to the plot object. For example, one layer in a plot can display the observations, another layer a regression line fitted to them, and a third one may contain annotations such as an equation or a text label.

\paragraph{Positions}
Positions\index{grammar of graphics!positions} are ``words'' that determine the displacement or not of graphical plot elements relative to their original $x$ and $y$ coordinates. They are one of the arguments accepted by \emph{geometries}. Position \ggposition{position\_identity()} introduces no displacement, and for example, \ggposition{position\_stack()} makes it possible to create stacked bar plots and stacked area plots. Positions will be discussed together with geometries as they are always subordinate to them.

\paragraph{Scales}
Scales\index{grammar of graphics!scales} give the ``translation'' or mapping between data values and the aesthetic values to be actually plotted. Mapping a variable to the ``colour'' aesthetic (also recognised when spelled as ``color'') only tells that different values stored in the mapped variable will be represented by different colours. A scale, such as \ggscale{scale\_colour\_continuous()}, will determine which colour in the plot corresponds to which value in the variable. Scales can also define transformations on the data, which are used when mapping data values to aesthetic values. All continuous scales support transformations---e.g., in the case of $x$ and $y$ aesthetics, positions on the plotting region or graphic viewport will be affected by the transformation, while the original values are used for tick labels along the axes or in keys for shapes, colours, etc. Scales are used for all aesthetics, including continuous variables, such as numbers, and categorical ones such as factors. The grammar of graphics allows only one scale per \emph{aesthetic} and plot. This restriction is imposed by design to avoid ambiguity (e.g., it ensures that the red colour will have the same ``meaning'' in all plot layers where the \code{colour} \emph{aesthetic} is mapped to data). Scales have limits that are set automatically unless supplied explicitly.

\paragraph{Coordinate systems}
The\index{grammar of graphics!coordinates} most frequently used coordinate system when plotting data, the cartesian system, is the default for most \emph{geometries}. In the cartesian system, $x$ and $y$ are represented as distances on two orthogonal (at 90$^\circ$) axes. Additional coordinate systems are available in \pkgname{ggplot2} and through extensions. For example, in the polar system of coordinates, the $x$ values are mapped to angles around a central point and $y$ values to the radius. Setting limits to a coordinate system changes the region of the plotting space visible in the plot, but does not discard observations. In other words, when using \emph{statistics}, observations located outside the coordinate limits, i.e., not visible in the rendered plot, will still be included in computations when excluded by coordinate limits but will be ignored when excluded by scale limits.

\paragraph{Themes}
How\index{grammar of graphics!themes} the plots look when displayed or printed can be altered by means of themes. A plot can be saved without adding a theme and then printed or displayed using different themes. Also, individual theme elements can be changed, and whole new themes defined. This adds a lot of flexibility and helps in the separation of the data representation aspects from those related to the graphical design.

\paragraph{Operators}
The\index{grammar of graphics!operators} elements described above are assembled into a ggplot object using operator \Roperator{+} and exceptionally using \Roperator{\%+\%}. The choice of these operators makes sense, as ggplot objects are built by sequentially adding members or elements to them.
\index{grammar of graphics!elements|)}

\begin{warningbox}
The functions corresponding to the different elements of the grammar of graphics have distinctive names with the first few letters hinting at their roles: aesthetics mappings (\code{aes}), geometric elements (\code{geom\_\ldots}), statistics (\code{stat\_\ldots}), scales (\code{scale\_\ldots}), coordinate systems (\code{coord\_\ldots}), and themes (\code{theme\_\ldots}).
\end{warningbox}

\subsection{The workings of the grammar}\label{sec:plot:workings}
\index{grammar of graphics!plot structure|(}
\index{grammar of graphics!plot workings|(}
A \code{"gg"} plot object is an \Rlang object of mode \code{"list"} containing the recipe and data to construct a plot. It is self contained in the sense that the only requirement for rendering it into a graphical representation is the availability of package \pkgname{ggplot2}. A \code{"gg"} object contains the data in one or more data frames and instructions encoded as functions and parameters, but not yet a rendering of the plot into graphical objects. Both data transformations and rendering of the plot into drawing instructions (encoded as graphical objects or \emph{grobs}) take place at the time of printing or exporting the plot, e.g., when saving a bitmap to a file.

To understand ggplots, one should first think in terms of the graphical organisation of the plot: there is always a background layer onto which other layers composed by different graphical objects are laid. Each layer contains related graphical objects originating from the same data. The last layer added is the topmost and the first one added the lowermost. Graphical objects in upper layers occlude those in the layers below them if their locations overlap. Although frequently layers in a ggplot share the same data and the same mappings to aesthetics, this is not a requirement. It is possible to build ggplots with independent layers, although always with shared scales and plotting area.

%%% Drawing of a plot with layers

A second perspective on ggplots is that of the process of converting the data into a graphical representation that can be printed on paper or viewed on a computer screen. The transformations applied to the data to achieve this can be thought as a data flow process divided into stages. The diagram in Figure \ref{fig:ggplot:stages} represents a single self-contained layer in a plot. The data supplied by the user is transformed in stages into instructions to draw a graphical representation. In \pkgname{ggplot2} and its documentation, graphical features are called \emph{aesthetics}, with the correspondence between values in the data and values of the aesthetic controlled by \emph{scales}. The values in the data are summarised by \emph{statistics}. However, when no summaries are needed, layers make use of \Rfunction{stat\_indentity()}, which copies its input to its output unchanged.
\emph{Geometries} provide the ``recipe'' used to generate graphical objects from the mapped data.

\begin{figure}
{\sffamily
\centering
\resizebox{\linewidth}{!}{%
  \begin{tikzpicture}[auto]
    \node [b] (data) {layer\\ data};
    \node [cc, right = of data] (mapping1) {\textbf{start}};
    \node [b, right = of mapping1] (statistic) {statistic};
    \node [cc, right = of statistic] (mapping2) {\textbf{after\\ stat}};
    \node [b, right = of mapping2] (geometry) {geometry + scale};
    \node [cc, right = of geometry] (mapping3) {\textbf{after\\ scale}};
    \node [b, right = of mapping3] (render) {layer\\ grobs};

    \path [ll] (mapping1) -- (data) node[near end,above]{a};
    \path [ll] (statistic) -- (mapping1) node[near end,above]{b};
    \path [ll] (mapping2) -- (statistic) node[near end,above]{c};
    \path [ll] (geometry) -- (mapping2) node[near end,above]{d};
    \path [ll] (mapping3) -- (geometry) node[near end,above]{e};
    \path [ll] (render) -- (mapping3) node[near end,above]{f};
  \end{tikzpicture}}}
  \caption[Stages of data flow in a ggplot layer]{Abstract diagram of data transformations in a ggplot layer showing the stages at which mappings between variables and graphic aesthetics take place.}\label{fig:ggplot:stages}
\end{figure}

Function \code{aes()} is used to define mappings to aesthetics. The default for \Rfunction{aes()} is for the mapping to take place at the \textbf{start} (leftmost circle in the diagram above), mapping names in the user data to aesthetics such as x, y, colour, and shape. The statistic can alter the mapped data, but in most cases not which aesthetics they are mapped to. Statistics can add default mappings for additional aesthetics. In addition, the default mappings of the data returned by the statistic can be modified by user code at this later stage, \textbf{after stat}. Default mappings can be modified again at the \textbf{after scale} stage.

\begin{explainbox}
Statistics always return a mapping to the same aesthetics that they require as input. However, the values mapped to these aesthetics at the \textbf{after stat} stage are in most cases different from those at \textbf{start}. Many statistics return additional variables, which are not mapped by default to any aesthetic. These variables facilitate variations on how results from a given type of data summary are added to plots, including the use of a geometry different from the default set by the statistic. In this case, the user has to override default mappings at the \textbf{after stat} stage. The additional variables returned by statistics are listed in their documentation. (See section \ref{sec:plot:mappings} on page \pageref{sec:plot:mappings} for details.)
\end{explainbox}

\begin{warningbox}
As mentioned above, all ggplot layers include a statistic and a geometry. From the perspective of the construction of a plot using the grammar, both \code{stats} and \code{geoms} are layer constructor functions. While \code{stats} take a \code{geom} as one of their arguments, \code{geoms} take a \code{stat} as one of their arguments. Thus, in both cases, a \code{stat} and a \code{geom} are added as a layer, and their role and position in the data flow remain the same, i.e., the diagram in Figure \ref{fig:ggplot:stages} applies independently of how the layers are added to the plot. The default statistic of many geometries is \ggstat{stat\_identity()} making their behaviour when added to a plot as if the layer they create contained no statistics.
\end{warningbox}

There are some statistics in \pkgname{ggplot2} that have companion geometries that can be used (almost) interchangeably. This tends to lead into confusion, and in this book, only geometries that have as default \ggstat{stat\_identity()} are described as geometries in section \ref{sec:plot:geometries}. In the case of those that by default use other statistics, like \gggeom{geom\_smooth()} only the companion statistic, \gggeom{stat\_smooth()} for this example, are described in section \ref{sec:plot:statistics}.

A ggplot can have a single layer or many layers, but when ggplots have more than one layer, the data flow, computations, and generation of graphical objects takes place independently for each layer. As mentioned above, most ggplots do not have fully independent layers, but the layers share the same data and aesthetic mappings at the \textbf{start}. Ahead of this point computations in layers are always independent of those in other layers, except that for a given aesthetic only one scale is allowed per plot.

\begin{explainbox}
 make it possible
\end{explainbox}

\index{grammar of graphics!plot workings|)}
\index{grammar of graphics!plot structure|)}

\subsection{Plot construction}
\index{grammar of graphics!plot construction|(}

As the use of the grammar is easier to demonstrate by example than to explain with words, I will show how to build plots of increasing complexity, starting from the simplest possible. All elements of a plot have defaults, although in some cases these defaults result in empty plots. Defaults make it possible to create a plot very succinctly. When building a plot step by step, the different viewpoints described in the previous section are relevant: the static structure of the plot's \Rlang object, the final graphic output, and the transformations that the data undergo ``in transit'' from the recipe stored in an object to the graphic output. In this section, I emphasise the syntax of the grammar and how it translates into a plot.

Function \code{ggplot()} by default constructs an empty plot. This is similar to how \code{character()}, \code{numeric()}, etc. construct empty vectors. This empty skeleton of a plot when printed is displayed as an grey rectangle.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-01-1} 

}


\end{knitrout}

A data frame passed as an argument to \code{data} without adding a mapping results in the same empty grey rectangle (not shown). Data frame \Rdata{mtcars} is a data set included in \Rlang (to read a description, type \code{help("mtcars")} at the \Rlang command prompt).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars)}
\end{alltt}
\end{kframe}
\end{knitrout}

Once the data are available, a graphical or geometric representation needs to be selected. The geometry used, such as \code{geom\_point()} and \code{geom\_line()}, drawing separate points for the observations or connecting them with lines, respectively, defines the type of plot. A mapping defines which property of the geometric elements will be used to represent the values from a variable in the user's data. Most geometries require mappings to both $x$ and $y$ aesthetics, as they establish the position of the geometrical shapes like points or lines in the plotting area. Additional aesthetics like colour make use of default scales and palettes. These defaults can be overridden with \code{scale} functions added to the plot (see section \ref{sec:plot:scales}).

Mapping at the \textbf{start} stage, \code{disp} to $x$ and \code{mpg} to $y$ aesthetics, makes the ranges of the values available. They are used to find default limits for the $x$ and $y$ scales as reflected in the plot axes. The plotting area $x$ and $y$ now match the ranges of the mapped variables, expanded by a small margin. The axis labels also reflect the names of the mapped variables, however, there are no graphical element yet displayed for the individual observations.% ({\small\textsf{data $\to$ aes $\to$ \emph{ggplot object}}})

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-03-1} 

}


\end{knitrout}

Observations are made visible by the addition of a suitable \emph{geometry} or \code{geom} to the plot recipe. Below, adding \gggeom{geom\_point()} makes the observations visible as points or symbols. %({\small\textsf{data $\to$ aes $\to$ geom $\to$ \emph{ggplot object}}})

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-04-1} 

}


\end{knitrout}

\begin{warningbox}
In the examples above, the plots were printed automatically, which is the default at the \Rlang console. However, as with other \Rlang objects, ggplots can be assigned to a variable.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
             \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
       \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\noindent
and printed at a later time, and saved to and read from files on disk.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{print}\hlstd{(p1)}
\end{alltt}
\end{kframe}
\end{knitrout}

Layers and other elements can be also added to a saved ggplot as the saved objects are not the graphical representation of the plots themselves but instead a \emph{recipe} plus data needed to build them.
\end{warningbox}

\begin{advplayground}
As for any \Rlang object \code{str()} displays the structure of \code{"gg"} objects. In addition, package \pkgname{ggplot2} provides a \code{summary()} method for \code{"gg"} plot objects.

As you make progress through the chapter, use these methods to explore the \code{"gg"} plot objects you construct, paying attention to layers, and global vs.\ layer-specific data and mappings. You will learn how the plot components are stored as members of \code{"gg"} plot objects.
\end{advplayground}

Although \emph{aesthetics} are usually mapped to variables in the data, constant aesthetic values can be passed as arguments to layer functions, consistently controlling a property of all elements in a layer. While variables in \code{data} can be both mapped using \code{aes()} as whole-plot defaults, as shown above, or within individual layers, constant values for aesthetics have to be set, as shown here, as named arguments passed directly to layer functions, instead of to a call to \code{aes()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"blue"}\hlstd{,} \hlkwc{shape} \hlstd{=} \hlstr{"square"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-04a-1} 

}


\end{knitrout}

\begin{warningbox}
Mapping an aesthetic to a constant value within a call to \Rfunction{aes()} adds a column containing this value to the data frame received as input by the \code{stat()}. This value is not interpreted as an aesthetic value but instead as a data value. The plot above, but using a call to \Rfunction{aes()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"blue"}\hlstd{,} \hlkwc{shape} \hlstd{=} \hlstr{"square"}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-04b-1} 

}


\end{knitrout}

The plot contains red circles instead of blue squares!

In principle, one could correct this plot by adding suitable \code{scales} but this would be still wasteful by unnecessarily storing many copies of the constant \code{"blue"} in the \code{"gg"} plot object.
\end{warningbox}

While a geometry directly constructs during rendering a graphical representation of the observations or summaries in the data it receives as input, a \emph{statistics} or \code{stat} ``sits'' in-between the data and a \code{geom}, applying some computation, usually but not always, to produce a statistical summary of the data. Here \code{stat\_smooth()} fits a linear regression (see section \ref{sec:stat:LM:regression} on page \pageref{sec:stat:LM:regression}) and passes the resulting predicted values to \gggeom{geom\_line()}. Passing \code{method = "lm"} selects \code{lm()} as the model fitting function. Passing \code{formula = y ~ x} sets the model to be fitted. This plot has two layers, one from geometries \gggeom{geom\_point()} and one from \gggeom{geom\_line()}.%({\small\textsf{data $\to$ aes $\to$ stat $\to$ geom $\to$ \emph{ggplot object}}})

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-05-1} 

}


\end{knitrout}

The plots above relied on defaults for \emph{scales}, \emph{coordinates} and \emph{themes}. In the examples below, the defaults are overridden by arguments that produce differently rendered plots. Adding \ggscale{scale\_y\_log10()} applies a logarithmic transformation to the values mapped to $y$. This works like plotting using graph paper with rulings spaced according to a logarithmic scale. Tick marks continue to be expressed in the original units, but statistics are applied to the transformed data. In other words, the transformation specified in the scale affects the values in advance of the \textbf{start} stage, before they are mapped to aesthetics and passed to \emph{statistics}. Thus, in this example, the linear regression is fitted to \code{log10()} transformed $y$ values and the original $x$ values.%({\small\textsf{data $\to$ aes $\to$ stat $\to$ geom $\to$ scale $\to$ \emph{ggplot object}}})

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)} \hlopt{+}
  \hlkwd{scale_y_log10}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-06-1} 

}


\end{knitrout}

The range limits of a scale can be set manually, instead of automatically as by default. These limits create a virtual \emph{window into the data}: out-of-bounds (oob) observations, those outside the scale limits remain hidden and are not mapped to aesthetics---i.e., these observations are not included in the graphical representation or used in calculations. Crucially, when using \emph{statistics} the computations are only applied to observations that fall within the limits of all scales in use. These limits \emph{indirectly} affect the plotting area when the plotting area is automatically set based on the range of the (within limits) data---even the mapping to values of a different aesthetics may change when a subset of the data is selected by manually setting the limits of a scale.

In contrast to \emph{scale limits}, \emph{coordinates}\index{grammar of graphics!cartesian coordinates} function as a \emph{zoomed view} into the plotting area, and do not affect which observations are visible to \emph{statistics}. The coordinate system, as expected, is also determined by this grammar element---below, adding cartesian coordinates, which are the default, but setting $y$ limits overrides the default ones. %({\small\textsf{data $\to$ aes $\to$ stat $\to$ geom $\to$ coordinate $\to$ theme $\to$ \emph{ggplot object}}})

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)} \hlopt{+}
  \hlkwd{coord_cartesian}\hlstd{(}\hlkwc{ylim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{15}\hlstd{,} \hlnum{25}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-07-1} 

}


\end{knitrout}

The next example uses a coordinate system transformation. When the transformation is applied to the coordinate system, it affects only the plotting---it sits between the \code{geom} and the rendering of the plot. The transformation is applied to the values that were returned by \emph{statistics}. The straight line fitted is plotted on the transformed coordinates as a curve, because the model was fitted to the untransformed data obtaining untransformed predicted values. The coordinate transformation is applied to these predicted values and plotted. (Other coordinate systems are described in sections \ref{sec:plot:sf} and \ref{sec:plot:circular} on pages \pageref{sec:plot:sf} and \pageref{sec:plot:circular}, respectively.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)} \hlopt{+}
  \hlkwd{coord_trans}\hlstd{(}\hlkwc{y} \hlstd{=} \hlstr{"log10"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-08-1} 

}


\end{knitrout}

Themes affect the rendering of plots at the time of printing---they can be thought of as style sheets defining the graphic design. A complete theme can override the default gray theme. The plot is the same, the observations are represented in the same way, the limits of the axes are the same and all text is the same. On the other hand, how these elements are rendered by different themes can be drastically different.% ({\small\textsf{data $\to$ aes $\to$ $\to$ geom $\to$ theme $\to$ \emph{ggplot object}}}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{theme_classic}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-09-1} 

}


\end{knitrout}

Both the base font size and the base font family can be changed. The base font size controls the size of all text elements, as other sizes are defined relative to the base size. How the plot looks changes when using the same theme as in the previous example, but with a different base point size and font family for text elements. (The use of themes is discussed in section \ref{sec:plot:themes} on page \pageref{sec:plot:themes}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{theme_classic}\hlstd{(}\hlkwc{base_size} \hlstd{=} \hlnum{20}\hlstd{,} \hlkwc{base_family} \hlstd{=} \hlstr{"serif"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-10-1} 

}


\end{knitrout}

How to set axis labels, tick positions, and tick labels will be discussed in depth in section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}. Function \code{labs()} is \emph{a convenience function} used to set the title and subtitle of a plot and to replace the default \code{name} of scales, here displayed as axis labels. The default \code{name} of scales is the name of the mapped variable. In the call to \code{labs()}, the names of aesthetics are used as if they were formal parameters with character strings or \Rlang expressions as arguments. Below \code{x} and \code{y} are the names of the two \emph{aesthetics} to which two variables in \code{data} were mapped, \code{disp} and \code{mpg}, respectively. Formal parameters \code{title} and \code{subtitle} add these plot elements. (The escaped character \verb|\n| stands for new line, see section \ref{sec:calc:character} on page \pageref{sec:calc:character}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Engine displacement (cubic inches)"}\hlstd{,}
       \hlkwc{y} \hlstd{=} \hlstr{"Fuel use efficiency\textbackslash{}n(miles per gallon)"}\hlstd{,}
       \hlkwc{title} \hlstd{=} \hlstr{"Motor Trend Car Road Tests"}\hlstd{,}
       \hlkwc{subtitle} \hlstd{=} \hlstr{"Source: 1974 Motor Trend US magazine"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-11-1} 

}


\end{knitrout}

As elsewhere in \Rlang, when a value is expected, either a value stored in a variable or a more complex statement returning a suitable value can be passed as an argument to be mapped to an \emph{aesthetic}. In other words, the values to be plotted do not need to be stored as variables (or columns) in the data frame passed as an argument to parameter \code{data}, they can also be computed from these variables. Below, miles-per-gallon, \code{mpg} are plotted against the engine displacement per cylinder by dividing \code{disp} by \code{cyl} within the call to \code{aes()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp} \hlopt{/} \hlstd{cyl,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-info-01-1} 

}


\end{knitrout}

Each of the elements of the grammar exemplified above is implemented in multiple functions, and in addition these functions accept arguments that can be used to modify their behaviour. Multiple data objects as well as multiple mappings can coexist within a single \code{"gg"} plot object. Packages and user code can define new \emph{geometries}, \emph{statistics}, \emph{scales}, \emph{coordinates}, and even implement new \emph{aesthetics}. Individual elements in a \emph{theme} can be modified and new complete \emph{themes} created, re-used and shared. I describe below how to use the grammar of graphics to construct different types of data visualisations, both simple and complex. Because the different elements interact, I introduce some of them first briefly in sections other than where I describe them in depth.
\index{grammar of graphics!plot construction|)}

\subsection{Plots as \Rlang objects}\label{sec:plot:objects}
\index{grammar of graphics!plots as R objects|(}
\code{"gg"} plot objects and their components behave as other \Rlang objects. Operators and methods for the \code{"gg"} class are available. As above, a \code{"gg"} plot object saved as \code{p1} is used below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
             \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
       \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

In the previous section, operator \code{+} was used to assemble the plots from ``anonymous'' \Rlang objects. Saved or ``named'' objects can also be combined with \code{+}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-objects-02-1} 

}


\end{knitrout}

Above, plot elements were added one by one, with operator \code{+}. Multiple components can be also added in a single operation. Like individual components, sets of components stored in a list can be saved in a variable and added to multiple plots. This ensures consistency and makes coordinated alterations to a set of plots easier. \emph{Throughout this chapter, I use this approach to achieve conciseness and to highlight what is different and what is not among plots in related examples.}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.ls} \hlkwb{<-} \hlkwd{list}\hlstd{(}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x),}
  \hlkwd{scale_y_log10}\hlstd{())}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p.ls}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-objects-info-02-1} 

}


\end{knitrout}

\begin{playground}
  Reproduce the examples in the previous section, using \code{p1} defined above as a basis instead of building each plot from scratch.
\end{playground}

\begin{warningbox}
\index{grammar of graphics!structure of plot objects|(}
The separation of plot construction and rendering is possible because \code{"gg"} objects are self-contained. A copy of the data object passed as an argument to \code{data} is saved within the plot object, similarly as in model-fit objects. In the example above, \code{p1} by itself could be saved to a file on disk and loaded into a clean \Rlang session, even on another computer, and rendered as long as package \ggplot and its dependencies are available. Another consequence of storing a copy of the data in the plot object, is that later changes to the data object used to create a \code{"gg"} object are \emph{not} reflected in newly rendered plots from this object: the \code{"gg"} object needs to be created anew.
\end{warningbox}

\begin{explainbox}
The \emph{recipe} for a plot is stored in a \code{"gg"} plot object. Objects of class \code{"gg"} are of mode \code{"list"}. In \Rlang, lists can contain heterogeneous members and \code{"gg"} objects contain data, function definitions, and unevaluated expressions. In other words, the data plus instructions to transform the data, to map them into graphic objects, and various aspects of the rendering from scale limits to type faces to use. (\Rlang lists are described in section \ref{sec:calc:lists} on page \pageref{sec:calc:lists}.)

Top level members of the \code{"gg"} plot object \code{p1}, a simple plot, are displayed below with method \code{summary()}, which shows the components without making explicit the structure of the object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(p1)}
\end{alltt}
\begin{verbatim}
## data: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb [32x11]
## mapping:  x = ~disp, y = ~mpg
## faceting: <ggproto object: Class FacetNull, Facet, gg>
##     compute_layout: function
##     draw_back: function
##     draw_front: function
##     draw_labels: function
##     draw_panels: function
##     finish_data: function
##     init_scales: function
##     map_data: function
##     params: list
##     setup_data: function
##     setup_params: function
##     shrink: TRUE
##     train_scales: function
##     vars: function
##     super:  <ggproto object: Class FacetNull, Facet, gg>
## -----------------------------------
## geom_point: na.rm = FALSE
## stat_identity: na.rm = FALSE
## position_identity
\end{verbatim}
\end{kframe}
\end{knitrout}

Method \code{str()} shows the structure of objects and can be also used to advantage with ggplots (long output not shown). Alternatively, \code{names()} extracts the names of the top-level members of \code{p1}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{names}\hlstd{(p1)}
\end{alltt}
\begin{verbatim}
##  [1] "data"        "layers"      "scales"      "guides"      "mapping"    
##  [6] "theme"       "coordinates" "facet"       "plot_env"    "layout"     
## [11] "labels"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

\begin{advplayground}
Explore in more detail the different members of object \code{p1}. For example, the code statement below extracts member \code{"layers"} from object \code{p1} and display its structure.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{str}\hlstd{(p1}\hlopt{$}\hlstd{layers,} \hlkwc{max.level} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

How many layers are present in this case?
\end{advplayground}
\index{grammar of graphics!structure of plot objects|)}
\index{grammar of graphics!plots as R objects|)}

\subsection{Scales and mappings}\label{sec:plot:mappings}
\index{grammar of graphics!mapping of data|(}
\index{grammar of graphics!aesthetics|(}
In \ggplot, a \emph{mapping} describes which variable in \code{data} is mapped to which \code{aesthetic},  or graphic feature of a plot, such as $x$, $y$, colour, fill, shape, and linewidth. In \ggplot, a \emph{scale} describes the correspondence between \emph{values} in the mapped variable and values of the graphic feature. Below, the numeric variable \code{cyl} is mapped to the \code{colour} aesthetic. As the variable is \code{numeric}, a continuous colour scale is used. Out of the multiple continuous colour scales available, \ggscale{scale\_colour\_continuous()} is the default.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{= cyl))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-12a-1} 

}


\end{knitrout}

Without changing the \code{mapping}, a different-looking plot can be created by changing the scale used. Below, in addition, a palette is selected with \code{option = "magma"} and the range of colours used from this palette adjusted with \code{end = 0.85}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlopt{+} \hlkwd{scale_colour_viridis_c}\hlstd{(}\hlkwc{option} \hlstd{=} \hlstr{"magma"}\hlstd{,} \hlkwc{end} \hlstd{=} \hlnum{0.85}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-12b-1} 

}


\end{knitrout}

Changing the scale used for the \code{colour} aesthetic, conceptually does not modify the plot, except for the colours used. There is a separation between the semantic structure of the plot and its graphic design. Still, how the audience interacts and perceives the plot depends on both of these concerns.

Some scales, like those for \code{colour}, exist in multiple ``flavours'', suitable for numeric variables (continuous) or for factors (discrete) values. If \code{cyl} is converted into a \code{factor}, a discrete colour scale is used instead of a continuous one. Out of the different discrete scales, \ggscale{scale\_colour\_discrete()} is used by default.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-12c-1} 

}


\end{knitrout}

If \code{cyl} is converted into an \code{ordered} factor, an ordinal colour scale is used, by default \ggscale{scale\_colour\_ordinal()} (plot not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{ordered}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

The scales for other aesthetics work in a similar way as those for colour. Scales are described in detail in section \ref{sec:plot:scales} on page \pageref{sec:plot:scales:continuous}.

In the examples above for simple plots, based on data contained in a single data frame, mappings were established  by passing the value returned by the call to \Rfunction{aes()} as the argument to parameter \code{mapping} of \Rfunction{ggplot()}.

Arguments passed to \code{data} and/or \code{mapping} parameters of \Rfunction{ggplot()} work as defaults for all layers in a plot. If arguments are passed to the identically named parameters of a layer function---statistic or geometry---, they are applied to the layer, overriding whole-plot defaults, if they exist. Consequently, the code below creates a plot, \code{p3}, identical to \code{p2} above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
             \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{= cyl))}
\hlstd{p3}
\end{alltt}
\end{kframe}
\end{knitrout}

These examples demonstrate two different approaches that are equally convenient for simple plots with a single layer. However, if a plot has multiple layers based on the same data, the approach used for \code{p2}  makes this clear and is concise. If each layer uses different data and/or different mappings, the second approach is necessary.

\begin{explainbox}
In some cases, when flexibility is needed while constructing complex plots with multiple layers other \emph{idioms} can be preferable, e.g., when assembling a plot from ``pieces'' stored in variables or built programmatically.

The default mapping can also be added directly with the \code{+} operator, instead of being passed as an argument to \Rfunction{ggplot()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars)} \hlopt{+}
       \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

It is also possible to have a default mapping for the whole plot, but no default data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{()} \hlopt{+}
  \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{data} \hlstd{= mtcars)}
\end{alltt}
\end{kframe}
\end{knitrout}

A mapping saved in a variable (example below), as well as a mapping returned by a function call (shown above for \code{aes()}), can be passed as an argument to parameter \code{mapping}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.mapping} \hlkwb{<-} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg)}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{= my.mapping)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

In all these examples, the plot remains unchanged (not shown). However, the flexibility of the grammar allows the assembly of plots from separately constructed pieces and reusing these pieces by storing them in variables. These approaches can be very useful in scrips that construct consistently formatted sets of plots, or when the same mapping needs to be used consistently in multiple plots.
\end{explainbox}

The mapping to aesthetics in the call to \Rfunction{aes()} does not have to be to a variable from \code{data} as in examples above. A a code statement that returns a value computed from one or more variables from \code{data} is also accepted. Computations during mapping helps avoid the proliferation of variables in the data frames containing observations. In this simple example, \code{mpg} in miles per gallon is converted into km per litre during mapping.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=}\hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg} \hlopt{*} \hlnum{0.43}\hlstd{))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-15b-1} 

}


\end{knitrout}

\begin{explainbox}
Operations applied to the \code{data} before they are plotted are usually implemented in \code{stats}. Sometimes it is convenient to directly modify the whole-plot default \code{data} before it reaches the layer's \code{stat} function. One approach is to pass a function to parameter \code{data} of the layer function. This argument must be the definition of a function accepting a data frame as its first argument and returning a data frame. When the argument to \code{data} is a function definition instead of the usual data frame, the function is applied to the plot's default data and the data frame returned by the function is used as the \code{data} in the layer. In the example below, an anonymous function defined in-line, extracts a subset of the rows. The observations in the extracted rows are highlighted in the plot by overplotting them with smaller yellow shapes.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{data} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)\{}\hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= x, cyl} \hlopt{==} \hlnum{4}\hlstd{)\},}
             \hlkwc{colour} \hlstd{=} \hlstr{"yellow"}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{1.5}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-basics-16-1} 

}


\end{knitrout}

The argument passed above to data is a function definition, not a function call. Thus, if a function is passed by name, no parentheses are used. No arguments can be passed to a function, except for the default \code{data} passed by position to its first parameter. Consequently, it is not possible to pass function \code{subset} directly. The anonymous function above is needed to be able to pass \code{cyl == 4} as argument.

The plot's default data can also be operated upon using the \pkgname{magrittr} pipe operator, but not the pipe operator native to \Rlang (\Roperator{\textbar >}) or the dot-pipe operator from \pkgname{wrapr} (see section \ref{sec:data:pipes} on page \pageref{sec:data:pipes}). In this approach, the dot (\code{.}) placeholder at the head of the pipe stands for the plot's default \code{data} object. The code statement below uses a pipe as argument for \code{data} to call function \Rfunction{subset()} with \code{cyl == 4} passed as the condition. The plot, not shown, is as in the example above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{data} \hlstd{= .} \hlopt{%>%} \hlkwd{subset}\hlstd{(}\hlkwc{x} \hlstd{= ., cyl} \hlopt{==} \hlnum{4}\hlstd{),} \hlkwc{colour} \hlstd{=} \hlstr{"yellow"}\hlstd{,}
             \hlkwc{size} \hlstd{=} \hlnum{1.5}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

A third possible approach is to test the condition within the call to \Rfunction{aes()}. In this approach, it is not possible to extract a subset of rows. Making some observations invisible by reducing their size seems straightforward. However, setting \code{size = 0} draws a very small point, still visible. Out of various possible approaches, setting size to \code{NA}, skips the rows, and \code{na.rm = TRUE} silences the expected warning. This is a roundabout approach to subsetting. Notice that \ggscale{scale\_size\_identity()} is also needed. The plot, not shown, when rendered does not differ from the two examples above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"yellow"}\hlstd{,}
             \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{size} \hlstd{=} \hlkwd{ifelse}\hlstd{(cyl} \hlopt{==} \hlnum{4}\hlstd{,} \hlnum{1.5}\hlstd{,} \hlnum{NA}\hlstd{)),}
             \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_size_identity}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

As it is usual in \Rlang, multiple approaches can be used to the same end.
\end{explainbox}

\begin{explainbox}
\emph{Late mapping}\index{grammar of graphics!mapping of data!late} of variables to aesthetics has been possible in \pkgname{ggplot2} for a long time using as notation enclosure of the name of a variable returned by a statistic between \code{..}, but this notation has been deprecated some time ago and replaced by \ggscale{stat()}. In both cases, this imposed a limitation: it was impossible to map a computed variable to the same aesthetic as input to the statistic and to the geometry in the same layer. There were also some other quirks that prevented passing some arguments to the geometry through the dots \code{...} parameter of a statistic.

Since version 3.3.0 of \pkgname{ggplot2}, the syntax used for mapping variables to aesthetics is based on functions \ggscale{stage()}, \ggscale{after\_stat()} and \ggscale{after\_scale()}. Function \ggscale{after\_stat()} replaces both \ggscale{stat()} and the \code{..} notation.
\end{explainbox}

%Variables in the data frame passed as argument to \code{data} are mapped to aesthetics before they are received as input by a statistic (possibly \code{stat\_identity()}). The mappings of variables in the data frame returned by statistics are the input to the geometry. Those statistics that operate on \textit{x} and/or \text{y} return a transformed version of these variables, by default also mapped to these aesthetics. However, in most cases other variables in addition to \textit{x} and/or \text{y} are included in the \code{data} returned by a \emph{statistic}. Although their default mapping is coded in the statistic functions' definitions, the user can modify this default mapping explicitly within a call to \code{aes()} using \ggscale{after\_stat()}, which lets us differentiate between the data frame supplied by the user and that returned by the statistic. The third stage was not accessible in earlier versions of \pkgname{ggplot2}, but lack of access was usually not insurmountable. Now this third stage can be accessed with \ggscale{after\_scale()} making coding simpler.
%
%User-coded transformations of the data are best handled at the third stage using scale transformations. However, when the intention is to jointly display or combine different computed variables returned by a statistic we need to set the desired mapping of original and computed variables to aesthetics at more than one stage.
%
The documentation of \pkgname{ggplot2} gives several good examples of cases when the new mapping syntax is useful. I give here a different example, a polynomial fitted to data using \Rfunction{rlm()}. RLM is a procedure that automatically assigns before computing the residual sums of squares, weights to the individual residuals in an attempt to protect the estimated fit from the influence of extreme observations or outliers. When using this and similar methods, it is of interest to plot the residuals together with the weights. One approach is to map weights to a gradient between two colours. The code below constructs a data frame containing artificial data that includes an extreme value or outlier.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{4321}\hlstd{)}
\hlstd{X} \hlkwb{<-} \hlnum{0}\hlopt{:}\hlnum{10}
\hlstd{Y} \hlkwb{<-} \hlstd{(X} \hlopt{+} \hlstd{X}\hlopt{^}\hlnum{2} \hlopt{+} \hlstd{X}\hlopt{^}\hlnum{3}\hlstd{)} \hlopt{+} \hlkwd{rnorm}\hlstd{(}\hlkwd{length}\hlstd{(X),} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlkwd{mean}\hlstd{(X}\hlopt{^}\hlnum{3}\hlstd{)} \hlopt{/} \hlnum{4}\hlstd{)}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(X, Y)}
\hlstd{df2} \hlkwb{<-} \hlstd{df1}
\hlstd{df2[}\hlnum{6}\hlstd{,} \hlstr{"Y"}\hlstd{]} \hlkwb{<-}\hlstd{df1[}\hlnum{6}\hlstd{,} \hlstr{"Y"}\hlstd{]} \hlopt{*} \hlnum{10}
\end{alltt}
\end{kframe}
\end{knitrout}

In the first plot, \ggscale{after\_stat()} is used to map variable \code{weights} computed by the statistic to the \code{colour} aesthetic. In \ggstat{stat\_fit\_residuals()}, \gggeom{geom\_point()} is used by default. This figure shows the raw residuals with no weights applied (mapped to $y$ by default), and the computed weights (with range 0 to 1) encoded by colours ranging between red and blue.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= df2,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,} \hlkwc{y} \hlstd{= Y))} \hlopt{+}
  \hlkwd{stat_fit_residuals}\hlstd{(}\hlkwc{formula} \hlstd{= y} \hlopt{~} \hlkwd{poly}\hlstd{(x,} \hlnum{3}\hlstd{,} \hlkwc{raw} \hlstd{=} \hlnum{TRUE}\hlstd{),} \hlkwc{method} \hlstd{=} \hlstr{"rlm"}\hlstd{,}
                     \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlkwd{after_stat}\hlstd{(weights)),}
                     \hlkwc{show.legend} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_colour_gradient}\hlstd{(}\hlkwc{low} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{high} \hlstd{=} \hlstr{"blue"}\hlstd{,} \hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
                       \hlkwc{guide} \hlstd{=} \hlstr{"colourbar"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-mapping-stage-02-1} 

}


\end{knitrout}

In the second plot, weighted residuals are mapped to the $y$ aesthetic, and weights, as above, to the colour aesthetic. A call to \ggscale{stage()} can distinguish the mapping ahead of the statistic (\code{start}) from that after the statistic, i.e., ahead of the geometry. As above, the default geometry, \gggeom{geom\_point()} is used. The mapping in this example can be read as: the variable \code{X} from the data frame \code{df2} is mapped to the \textit{x} aesthetic at all stages. Variable \code{Y} from the data frame \code{df2} is mapped to the \textit{y} aesthetic ahead of the computations in \ggstat{stat\_fit\_residuals()}. After the computations, variables \code{y} and \code{weights} in the data frame returned by \ggstat{stat\_fit\_residuals()} are multiplied and mapped to the \textit{y} ahead of \gggeom{geom\_point()}.\label{chunk:plot:weighted:resid}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(df2)} \hlopt{+}
  \hlkwd{stat_fit_residuals}\hlstd{(}\hlkwc{formula} \hlstd{= y} \hlopt{~} \hlkwd{poly}\hlstd{(x,} \hlnum{3}\hlstd{,} \hlkwc{raw} \hlstd{=} \hlnum{TRUE}\hlstd{),}
                     \hlkwc{method} \hlstd{=} \hlstr{"rlm"}\hlstd{,}
                     \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,}
                                   \hlkwc{y} \hlstd{=} \hlkwd{stage}\hlstd{(}\hlkwc{start} \hlstd{= Y,}
                                             \hlkwc{after_stat} \hlstd{= y} \hlopt{*} \hlstd{weights),}
                                   \hlkwc{colour} \hlstd{=} \hlkwd{after_stat}\hlstd{(weights)),}
                     \hlkwc{show.legend} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_colour_gradient}\hlstd{(}\hlkwc{low} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{high} \hlstd{=} \hlstr{"blue"}\hlstd{,} \hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
                        \hlkwc{guide} \hlstd{=} \hlstr{"colourbar"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-mapping-stage-03-1} 

}


\end{knitrout}

\begin{explainbox}
When fitting models to observations with \Rfunction{lm()}, the un-weighted residuals are used to compute the sum of squares unless weights are passed as an argument. In \Rfunction{rlm()}, the weights are computed from the data by the function.
\end{explainbox}

\index{grammar of graphics!mapping of data|)}
\index{grammar of graphics!aesthetics|)}

\section{Geometries}\label{sec:plot:geometries}
\index{grammar of graphics!geometries|(}

Different geometries support different \emph{aesthetics} (Table \ref{tab:plot:geoms}). While \gggeom{geom\_point()} supports \code{shape}, and \gggeom{geom\_line()} supports \code{linetype}, both support \code{x}, \code{y}, \code{colour}, and \code{size}. In this section I describe frequently used \code{geometries} from package \ggplot and from a few packages that extend \ggplot. The graphic output from some code examples will not be shown, with the expectation that readers will run the code to see the plots.

Mainly for historical reasons, \emph{geometries} accept a \emph{statistic} as an argument, in the same way as \emph{statistics} accept a \emph{geometry} as an argument. In this section I only describe \emph{geometries} which have as a default \emph{statistic} \code{stat\_identity}. In section \ref{sec:plot:stat:summaries} (page \pageref{sec:plot:stat:summaries}), I describe other \emph{geometries} together with the \emph{statistics} they use by default.

\begin{table}
  \caption[Geometries]{\ggplot geometries described in section \ref{sec:plot:geometries}, packages where they are defined, and the aesthetics supported. The default statistic is in all cases \ggstat{stat\_identity()}.}\vspace{1ex}\label{tab:plot:geoms}
  \centering
   \begin{tabular}{llp{8.25cm}}
     \toprule
     Geometry & Package & Aesthetics \\
     \midrule
     \code{geom\_point} & \pkgnameNI{ggplot2} & x, y, shape, size, fill, colour, alpha \\
     \code{geom\_point\_s} & \pkgnameNI{ggpp} & x, y, size, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_pointrange} & \pkgnameNI{ggplot2} & x, y, ymin, ymax, shape, size, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_errorbar} & \pkgnameNI{ggplot2} & x, ymin, ymax, linetype, linewidth, colour, alpha \\
     \code{geom\_linerange} & \pkgnameNI{ggplot2} & x, ymin, ymax, linetype, linewidth, colour, alpha  \\
     \code{geom\_line} & \pkgnameNI{ggplot2} & x, y, linetype, linewidth, colour, alpha  \\
     \code{geom\_segment} & \pkgnameNI{ggplot2} & x, y, xend, yend, linetype, linewidth, colour, alpha \\
     \code{geom\_step} & \pkgnameNI{ggplot2} & x, y, linetype, linewidth, colour, alpha  \\
     \code{geom\_path} & \pkgnameNI{ggplot2} & x, y, linetype, linewidth, colour, alpha  \\
     \code{geom\_curve} & \pkgnameNI{ggplot2} & x, y, xend or yend, linetype, linewidth, colour, alpha  \\
     \code{geom\_area} & \pkgnameNI{ggplot2} & x, y, (ymin = 0), linetype, linewidth, fill, colour, alpha \\
     \code{geom\_ribbon} & \pkgnameNI{ggplot2} & x, ymin and ymax, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_align} & \pkgnameNI{ggplot2} & x or y, xmin or xmax, ymin or ymax, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_rect} & \pkgnameNI{ggplot2} & xmin, xmax, ymin, ymax, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_tile} & \pkgnameNI{ggplot2} & x, y, width, height, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_col} & \pkgnameNI{ggplot2} & x, y, width, linetype, linewidth, fill, colour, alpha \\
     \code{geom\_rug} & \pkgnameNI{ggplot2} & x or y, linewidth, colour, alpha \\
     \code{geom\_hline} & \pkgnameNI{ggplot2} & yintercept, linetype, linewidth, colour, alpha  \\
     \code{geom\_vline} & \pkgnameNI{ggplot2} & xintercept, linetype, linewidth, colour, alpha  \\
     \code{geom\_abline} & \pkgnameNI{ggplot2} & intercept, slope, linetype, linewidth, colour, alpha  \\
     \code{geom\_text} & \pkgnameNI{ggplot2} & x, y, label, face, family, angle, size, colour, alpha \\
     \code{geom\_label} & \pkgnameNI{ggplot2} & x, y, label, face, family, (angle), size, fill, colour, alpha  \\
     \code{geom\_text\_repel} & \pkgnameNI{ggrepel} & x, y, label, face, family, angle, size, colour, alpha \\
     \code{geom\_label\_repel} & \pkgnameNI{ggrepel} & x, y, label, face, family, size, fill, colour, alpha  \\
     \code{geom\_sf} & \pkgnameNI{ggplot2} & fill, colour \\
     \code{geom\_table} & \pkgnameNI{ggpp} & x, y, label, size, colour, angle \\
     \code{geom\_plot} & \pkgnameNI{ggpp} & x, y, label, vp.width, vp.height, angle \\
     \code{geom\_grob} & \pkgnameNI{ggpp} & x, y, vp.width, vp.height, label \\
     \code{geom\_blank} & \pkgnameNI{ggplot2} & --- \\
     \bottomrule
   \end{tabular}
\end{table}

\subsection{Point}\label{sec:plot:geom:point}
\index{grammar of graphics!point geometry|(}

As seen in examples above, \gggeom{geom\_point()}, can be used to add a layer with observations represented by ``points'' or symbols. In \emph{scatter plots} the variables mapped to $x$ and $y$ aesthetics are both continuous (\code{numeric}) and in \emph{dot plots} one of them is discrete (\code{factor} or \code{ordered}) and the other continuous. The plots in the examples above have been scatter plots.

\index{plots!scatter plot|(}The first examples of the use of \gggeom{geom\_point()} are for \textbf{scatter plots}, as \code{disp} and \code{mpg} are \code{numeric} variables. In the examples above, a third variable, \code{cyl}, was mapped to \code{colour}. While the colour aesthetic can be used with all \code{geoms}, other aesthetics can be used only with some \code{geoms}, for example the \code{shape} aesthetic can be used only with \gggeom{geom\_point()} and similar \code{geoms}, such as \gggeom{geom\_pointrange()}. The values in the \code{shape} aesthetic are discrete, and consequently only discrete values can be mapped to it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{shape} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{p.base}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scatter-01-1} 

}


\end{knitrout}

\begin{playground}
Try a different mapping: \code{disp} $\rightarrow$ \code{colour}, \code{cyl} $\rightarrow$ \code{x}, keeping the mapping \code{mpg}  $\rightarrow$ \code{y} unchanged. Continue by using \code{help(mtcars)} and/or \code{names(mtcars)} to see what other variables are available, and then try the combinations that trigger your curiosity---i.e., explore the data.
\end{playground}

Adding \ggscale{scale\_shape\_discrete()}, the scale already used by default, but passing \code{solid = FALSE} in the call creates a version of the same plot based on open shapes, still selected automatically.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
  \hlkwd{scale_shape_discrete}\hlstd{(}\hlkwc{solid} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scatter-11-1} 

}


\end{knitrout}

In contrast to ``filled'' shapes that obey both \code{colour} and \code{fill}, ``open'' shapes obey only \code{colour}, similarly to ``solid'' shapes. Function \code{scale\_shape\_manual} can be used to set the shape used for each value in the mapped factor. Below, ``open'' shapes are used, as they reveal partial overlaps better than solid shapes (plot not shown).\label{chunk:filled:symbols}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
  \hlkwd{scale_shape_manual}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"circle open"}\hlstd{,}
                                \hlstr{"square open"}\hlstd{,}
                                \hlstr{"diamond open"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\pagebreak

It is also possible to use characters as shapes. The character is centred on the position of the observation. As the numbers used as symbols are self-explanatory, the default guide is removed by passing \code{guide = "none"} (plot not shown).\label{chunk:plot:point:char}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
 \hlkwd{scale_shape_manual}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"4"}\hlstd{,} \hlstr{"6"}\hlstd{,} \hlstr{"8"}\hlstd{),} \hlkwc{guide} \hlstd{=} \hlstr{"none"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

A variable from \code{data} can be mapped to more than one aesthetic, allowing redundant aesthetics. This makes possible figures that, even if using colour, are readable when reproduced as black-and-white images and to viewers affected by colour blindness.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,}
       \hlkwc{shape} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\index{plots!scatter plot|)}
\index{plots!dot plot|(}The next examples of the use of \gggeom{geom\_point()} are for \textbf{dot plots}, as \code{disp} is a \code{numeric} variable but \code{factor(cyl)} is discrete. Dot plots are prone to have overlapping observations, and one way of making these points visible is to make them partly transparent by setting a constant value smaller than one for the \code{alpha} \emph{aesthetic}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{3}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scatter-12a-1} 

}


\end{knitrout}

Function\label{par:plot:pos:jitter} \ggposition{position\_identity()}, which is the default, does not alter the coordinates or position of observations, as shown in all examples above. To make overlapping observations visible, instead of making the points semitransparent as above, it is possible randomly displace them along the axis mapped to the discrete variable, $x$ in this case. This is called \emph{jitter}, and can be added using \ggposition{position\_jitter()} as argument to formal parameter \code{position} of \code{geoms}. The amount of jitter is set by numeric arguments passed to \code{width} and/or \code{height}, given as a fraction of the distance between adjacent factor levels in the plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{position} \hlstd{=} \hlkwd{position_jitter}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{0.25}\hlstd{,} \hlkwc{heigh} \hlstd{=} \hlnum{0}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scatter-13-1} 

}


\end{knitrout}

\begin{warningbox}
   The name as a character string can be also used when no arguments need to be passed to the \emph{position} function, and for some positions by passing numerical arguments to specific parameters of geometries. However, the default width of $\pm0.5$ tends to be rarely optimal (plot not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{y} \hlstd{= mpg),} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"jitter"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{warningbox}

\index{plots!dot plot|)}
\index{plots!bubble plot|(}
\textbf{Bubble plots} are scatter- or dot plots in which the size of points or bubbles varies following values of a continuous variable mapped to the \code{size} \emph{aesthetic}. There are two approaches to this mapping, values in the mapped variable either describe the area of the points or their radii. Although the radius is sometimes used, due to how visual perception works, using area is perceptually closer to a linear mapping compared to radii. Below, the weights of cars in tons are mapped to the area of the points. Open circles are used because of overlaps.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{size} \hlstd{= wt))} \hlopt{+}
  \hlkwd{scale_size_area}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape} \hlstd{=} \hlstr{"circle open"}\hlstd{,} \hlkwc{stroke} \hlstd{=} \hlnum{1.5}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scatter-16-1} 

}


\end{knitrout}

\begin{playground}
If a radius-based scale is used instead of an area-based one the perceived size differences are larger, i.e., the ``impression'' on the viewer is different. In the plot above, replace \code{scale\_size\_area()} with \code{scale\_size\_radius()}.

Display the plot, look at it carefully. Check the numerical values of some of the weights of the cars, and assess if your perception of the plot matches the numbers behind it.
\end{playground}

\index{plots!bubble plot|)}

As a final example summarising the use of \gggeom{geom\_point()}, the scatter plot below combines different \emph{aesthetics} and their \emph{scales}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{shape} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),}
                     \hlkwc{fill} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{size} \hlstd{= wt))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.33}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_size_area}\hlstd{()} \hlopt{+}
  \hlkwd{scale_shape_manual}\hlstd{(}\hlkwc{values} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"circle filled"}\hlstd{,}
                                \hlstr{"square filled"}\hlstd{,}
                                \hlstr{"diamond filled"}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scatter-18-1} 

}


\end{knitrout}

\begin{playground}
Play with the code in the chunk above. Remove or change each of the mappings and the scale, display the new plot, and compare it to the one above. Continue playing with the code until you are sure you understand what graphical element in the plot is added or modified by each individual argument or ``word'' in the code statement.
\end{playground}
\index{grammar of graphics!point geometry|)}

It is common to draw error bars together with points representing means or medians. These can be added in a single layer with \gggeom{geom\_pointrange()} with values mapped to the \code{x}, \code{y}, \code{ymin} and \code{ymax} aesthetics, using \code{y} for the point and \code{ymin} and \code{ymax} for the ends of the line segment. Two other \emph{geometries}, \gggeom{geom\_range()} and  \gggeom{geom\_errorbar()} draw only a segment or a segment with capped ends. These three \code{geoms} are frequently used together with \code{stats} that compute summaries by group. However, summary values calculated before plotting can alternatively be passed as \code{data}.

\subsection{Rug}\label{sec:plot:rug}
\index{plots!rug margin|(}

Rarely, rug plots are used by themselves. Instead they are usually an addition to scatter plots. An example of the use of \gggeom{geom\_rug()} follows. They make it easier to see the distribution of observations along the $x$- and/or $y$-axes. By default, rugs are drawn on the left and bottom edges of the plotting area. By passing \code{sides = "btlr"} they are drawn on the bottom, top, left, and right margins. Any combination of the four characters can be used to control the drawing of the rugs.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_rug}\hlstd{(}\hlkwc{sides} \hlstd{=} \hlstr{"btlr"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-rug-plot-01-1} 

}


\end{knitrout}

\begin{warningbox}
  Rug plots are useful when the local density of observations in a continuous variable is not high as, otherwise, rugs become too cluttered and the rug ``threads'' overlap. When the overlap is moderate, making the segments semitransparent by setting the \code{alpha} aesthetic to a constant value smaller than one, can make the variation in density easier to appreciate. When the number of observations is large, marginal density plots are preferred.
\end{warningbox}
\index{plots!rug margin|)}

\subsection{Line and area}\label{sec:plot:line}

\index{grammar of graphics!various line and path geometries|(}\index{plots!line plot|(}
\textbf{Line plots} are normally created using \gggeom{geom\_line()}, and, occasionally using \gggeom{geom\_path()}. These two \code{geoms} differ in the sequence they follow when connecting values: \gggeom{geom\_line()} connects observations based on the ordering of \code{x} values while \gggeom{geom\_path()} uses the order in the data. Aesthetic \code{linewidth} controls the thickness of lines and \code{linetype} the patterns of dashes and dots.

In a line plot, observations, or the subset of observations in a group, are joined by straight lines. Below, a different data set, \Rdata{Orange}, with data on the growth of five orange trees (see \code{help(Orange)}) is used. By mapping \code{Tree} to \code{linetype} the observations become grouped, and a line is plotted for each tree.

\label{plot:fig:lines}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Orange,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= age,} \hlkwc{y} \hlstd{= circumference,} \hlkwc{linetype} \hlstd{= Tree))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-line-plot-01-1} 

}


\end{knitrout}

\begin{warningbox}
Before \ggplot 3.4.0 the \code{size} aesthetic controlled the width of lines. Aesthetic \code{linewidth} was added in \ggplot 3.4.0 and the use of the \code{size} aesthetic for lines deprecated.
\end{warningbox}
\index{plots!line plot|)}

\index{plots!step plot|(}%
Geometry \gggeom{geom\_step()} plots only vertical and horizontal lines to join the observations, creating a stepped line, or ``staircase''. Parameter \code{direction}, with default \code{"hv"}, controls the ordering of horizontal and vertical lines.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Orange,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= age,} \hlkwc{y} \hlstd{= circumference,} \hlkwc{linetype} \hlstd{= Tree))} \hlopt{+}
  \hlkwd{geom_step}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-step-plot-01-1} 

}


\end{knitrout}
\index{plots!step plot|)}

\begin{playground}
Using the following toy data, make three plots using \code{geom\_line()}, \code{geom\_path()}, and \code{geom\_step} to add a layer. How do they differ?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{toy.df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{,}\hlnum{2}\hlstd{,}\hlnum{4}\hlstd{),} \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{1}\hlstd{,}\hlnum{0}\hlstd{,}\hlnum{1}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\index{plots!filled-area plot|(}
While \gggeom{geom\_line()} draws a line joining observations, \gggeom{geom\_area()} supports, in addition, filling the area below the line according to the \code{fill} \emph{aesthetic}. In some cases, it is useful to stack the areas, e.g., when the values plotted represent parts of a bigger whole. In the next, contrived, example, the areas representing the growth of the five orange trees are stacked (visually summed) using \code{position = "stack"} in place of the default \code{position = "identity"}. The visibility of the lines for individual trees is improved by changing their colour and width from the defaults. (Compare the $y$ axis of the figure below to that drawn using \code{geom\_line()} on page \pageref{plot:fig:lines}.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlcom{# will be used again later}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Orange,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= age,} \hlkwc{y} \hlstd{= circumference,} \hlkwc{fill} \hlstd{= Tree))} \hlopt{+}
  \hlkwd{geom_area}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"stack"}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"white"}\hlstd{,} \hlkwc{linewidth} \hlstd{=} \hlnum{1}\hlstd{)}
\hlstd{p1}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-area-plot-01-1} 

}


\end{knitrout}

\gggeom{geom\_ribbon()} draws two lines based on the \code{x}, \code{ymin} and \code{ymax} \emph{aesthetics}, with the space between the lines filled according to the \code{fill} \emph{aesthetic}. \gggeom{geom\_polygon()} is similar to \gggeom{geom\_path()} but connects the first and last observations forming a closed polygon that obeys the \code{fill} aesthetic.

\index{plots!filled-area plot|)}

\index{plots!reference lines|(}
Finally,\label{sec:plot:vhline} three \emph{geometries} for drawing lines across the whole plotting area: \gggeom{geom\_hline()}, \gggeom{geom\_vline()} and \gggeom{geom\_abline()}. The first two draw horizontal and vertical lines, respectively, while the third one draws straight lines according to the \emph{aesthetics} \code{slope} and \code{intercept} determining the position. The lines drawn with these three geoms extend to the edge of the plotting area.

\gggeom{geom\_hline()} and \gggeom{geom\_vline()} require a single parameter (or aesthetic), \code{yintercept} and \code{xintercept}, respectively. Different from other geoms, the data for these aesthetics can be passed as constant numeric vector containing multiple values. The reason for this is that these geoms are most frequently used to annotate plots rather than plotting observations. Vertical lines can be used to highlight time points, here the ages of 1, 2, and 3 years.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{xintercept} \hlstd{=} \hlnum{365} \hlopt{*} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"gray75"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_vline}\hlstd{(}\hlkwc{xintercept} \hlstd{=} \hlnum{365} \hlopt{*} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{,} \hlkwc{linetype} \hlstd{=} \hlstr{"dashed"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-area-plot-02-1} 

}


\end{knitrout}

\begin{playground}
  Change the order of the two layers in the example above. How did the figure change? What order is best? Would the same order be the best for a scatter plot? And would it be necessary to add two \code{geom\_vline()} layers?
\end{playground}

Similarly to \gggeom{geom\_hline()} and \gggeom{geom\_vline()}, \gggeom{geom\_abline()} draws a straight line, accepting as parameters (or as aesthetics) values for the \code{intercept}, $a$, and the \code{slope}, $b$.
\index{plots!reference lines|)}

\index{plots!segments and arrows|(}
Disconnected straight-line segments and arrows, one for each observation or row in the data, can be plotted with \gggeom{geom\_segment()} which accepts \code{x}, \code{xend}, \code{y}, and \code{yend} as mapped aesthetics. \gggeom{geom\_spoke()}, which uses a polar parametrisation, uses a different set of aesthetics, \code{x}, \code{y} for origin, and \code{angle} and \code{radius} for the segment. Similarly, \gggeom{geom\_curve()} draws curved segments, with the curvature, control points, and angles controlled through parameters. These three \emph{geometries} support arrow heads at the ends of segments or curves, controlled through parameter \code{arrow} (not through an aesthetic).
\index{plots!segments and arrows|)}
\index{grammar of graphics!various line and path geometries|)}

\subsection{Column}\label{sec:plot:col}
\index{grammar of graphics!column geometry|(}
\index{plots!column plot|(}

The \emph{geometry} \gggeom{geom\_col()} can be used to create \emph{column plots}, where each bar represents an observation or row in the \code{data} (frequently means or totals previously computed from the primary observations).

\begin{warningbox}
In other contexts, column plots are frequently called bar plots. \Rlang users not familiar yet with \ggplot are frequently surprised by the default behaviour of \gggeom{geom\_bar()} as it uses \ggstat{stat\_count()} to produce a histogram, rather than plotting values as is (see section \ref{sec:plot:histogram} on page \pageref{sec:plot:histogram}). \gggeom{geom\_col()} is identical to \gggeom{geom\_bar()} but with \code{"identity"} as the default statistic.
\end{warningbox}

Using very simple artificial data helps demonstrate how variations of column plots can be obtained. The data are for two groups, hypothetical males and females.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{654321}\hlstd{)}
\hlstd{my.col.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{treatment} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{,} \hlstr{"C"}\hlstd{),} \hlnum{2}\hlstd{)),}
             \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"male"}\hlstd{,} \hlstr{"female"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{3}\hlstd{))),}
             \hlkwc{measurement} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{6}\hlstd{)} \hlopt{+} \hlkwd{c}\hlstd{(}\hlnum{5.5}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{7}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The first plot includes data for \code{"female"} subjects extracted using a nested call to \Rfunction{subset()}. Except for \code{x} and \code{y} default mappings are used for all \emph{aesthetics}.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwd{subset}\hlstd{(my.col.data, group} \hlopt{==} \hlstr{"female"}\hlstd{),}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= treatment,} \hlkwc{y} \hlstd{= measurement))} \hlopt{+}
  \hlkwd{geom_col}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-col-plot-02-1} 

}


\end{knitrout}

The \label{par:plot:pos:stack} bars above, are overwhelmingly wide, passing \code{width = 0.5} makes the bars narrower, using only half the distance between the levels on the $x$ axis. Setting \code{colour = "white"} overrides the default colour of the lines bordering the bars. Both males and females are included and \code{group} is mapped to the \code{fill} aesthetic. The default argument for position in \gggeom{geom\_col()} is \ggposition{position\_stack()}. Function \ggposition{position\_stack()} is similar to \ggposition{position\_stack()} but divides the stacked values by their sum, i.e., the individual stacked ``slices'' of the column display proportions instead of absolute values.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
 \hlkwd{ggplot}\hlstd{(my.col.data,}
        \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= treatment,} \hlkwc{y} \hlstd{= measurement,} \hlkwc{fill} \hlstd{= group))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_col}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{0.5}\hlstd{)} \hlopt{+} \hlkwd{ggtitle}\hlstd{(}\hlstr{"stack (default)"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Using \code{position = "dodge"}\label{par:plot:pos:dodge} to override the default \code{position = "stack"} the columns for males and females are plotted side by side.\qRfunction{position\_stack()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_col}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"dodge"}\hlstd{)} \hlopt{+} \hlkwd{ggtitle}\hlstd{(}\hlstr{"dodge"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

The two plots side by side (see section \ref{sec:plot:composing} on page \pageref{sec:plot:composing} for details).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-col-plot-04a-1} 

}


\end{knitrout}



\begin{playground}
Change the argument to \code{position}, or let the default be active, until you understand its effect on the figure. What is the difference between \emph{positions} \code{"identity"}, \code{"dodge"}, \code{"stack"}, and \code{"fill"}?
\end{playground}

\begin{playground}
Use constants as arguments for \emph{aesthetics} or map variable \code{treatment} to one or more of the \emph{aesthetics} recognised by \gggeom{geom\_col()}, such as \code{colour}, \code{fill}, \code{linetype}, \code{size}, \code{alpha} and \code{width}.
\end{playground}

\index{grammar of graphics!column geometry|)}
\index{plots!column plot|)}

\subsection{Tiles}\label{sec:tileplot}
\index{grammar of graphics!tile geometry|(}
\index{plots!tile plot|(}
\textbf{Tile plots} and \textbf{heat maps} are useful when observations are available on a regular rectangular 2D grid. The grid can, for example, represent locations in space as well combinations of levels of two discrete classification criteria. The colour or darkness of the tiles informs about the value of the observations. A layer with square or rectangular tiles can be added with \gggeom{geom\_tile()}.

Data from 100 random draws from the $F$ distribution with degrees of freedom $\nu_1 = 2, \nu_2 = 20$ are used in the examples.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{1234}\hlstd{)}
\hlstd{randomf.df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{F.value} \hlstd{=} \hlkwd{rf}\hlstd{(}\hlnum{100}\hlstd{,} \hlkwc{df1} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{df2} \hlstd{=} \hlnum{20}\hlstd{),}
                         \hlkwc{x} \hlstd{=} \hlkwd{rep}\hlstd{(letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{],} \hlnum{10}\hlstd{),}
                         \hlkwc{y} \hlstd{= LETTERS[}\hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwd{rep}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{10}\hlstd{))])}
\end{alltt}
\end{kframe}
\end{knitrout}

\gggeom{geom\_tile()} requires aesthetics $x$ and $y$, with no defaults, and \code{width} and \code{height} with defaults that make all tiles of equal size filling the plotting area. Variable \code{F.value} is mapped to \code{fill}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= randomf.df,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{fill} \hlstd{= F.value))} \hlopt{+}
  \hlkwd{geom_tile}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-tile-plot-02-1} 

}


\end{knitrout}

Below, setting \code{colour = "gray75"} and \code{linewidth = 1} makes the tile borders visible. Whether highlighting these lines improves or not a tile plot depends on whether the individual tiles correspond to values of a categorical- or continuous variable. For example, when rows of tiles correspond to genes and columns to discrete treatments, visible tile borders are preferable. In contrast, in the case when the tiles are an approximation to a continuous surface like measurements on a regular spatial grid, it is best to suppress tile borders.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= randomf.df,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{fill} \hlstd{= F.value))} \hlopt{+}
  \hlkwd{geom_tile}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"gray75"}\hlstd{,} \hlkwc{linewidth} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-tile-plot-03-1} 

}


\end{knitrout}

\begin{playground}
Play with the arguments passed to parameters \code{colour} and \code{size} in the example above, considering what features of the data are most clearly perceived in each of the plots you create.
\end{playground}

Continuous fill scales can be used to control the appearance. Below, code for a tile plot based on a gray gradient, with missing values in red, is constructed is shown (plot not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= randomf.df,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{fill} \hlstd{= F.value))} \hlopt{+}
  \hlkwd{geom_tile}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"white"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_gradient}\hlstd{(}\hlkwc{low} \hlstd{=} \hlstr{"gray15"}\hlstd{,} \hlkwc{high} \hlstd{=} \hlstr{"gray85"}\hlstd{,} \hlkwc{na.value} \hlstd{=} \hlstr{"red"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

In contrast to \gggeom{geom\_tile()}, \gggeom{geom\_rect()} draws rectangular tiles based on the position of the corners, mapped to aesthetics \code{xmin}, \code{xmax}, \code{ymin} and \code{ymax}. In this case, tiles can vary in size and do not need to be contiguous. The filled rectangles can be used, for example, to highlight a rectangular region in a plot (see example on page \pageref{par:plot:inset:zoom}).
\index{plots!tile plot|)}
\index{grammar of graphics!tile geometry|)}

\subsection{Simple features (sf)}\label{sec:plot:sf}
\index{grammar of graphics!sf geometries|(}
\index{plots!maps and spatial plots|(}

\ggplot version 3.0.0 or later supports with \gggeom{geom\_sf()}, and its companions, \gggeom{geom\_sf\_text()}, \gggeom{geom\_sf\_label()}, and \ggstat{stat\_sf()}, the plotting of shape data similarly to geographic information systems (GIS). This makes it possible to display data on maps, for example, using different fill values for different regions. The special \emph{coordinate} \code{coord\_sf()} can be used to select different projections for maps. The \emph{aesthetic} used is called \code{geometry} and contrary to all the other aesthetics described above, the values to be mapped are of class \code{sfc} containing \emph{simple features} data with multiple components. Manipulation of simple features data is supported by package \pkgname{sf}. Normal geometries can be use together with \ggstat{stat\_sf\_coordinates()} to add other graphical elements to maps. This subject exceeds the scope of this book, so a single and very simple example is shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nc} \hlkwb{<-} \hlstd{sf}\hlopt{::}\hlkwd{st_read}\hlstd{(}\hlkwd{system.file}\hlstd{(}\hlstr{"shape/nc.shp"}\hlstd{,} \hlkwc{package} \hlstd{=} \hlstr{"sf"}\hlstd{),} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{ggplot}\hlstd{(nc)} \hlopt{+}
  \hlkwd{geom_sf}\hlstd{(}\hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{fill} \hlstd{= AREA),} \hlkwc{colour} \hlstd{=} \hlstr{"gray90"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-sf_plot-01-1} 

}


\end{knitrout}
\index{grammar of graphics!sf geometries|)}
\index{plots!maps and spatial plots|)}

\subsection{Text}\label{sec:plot:text}
\index{grammar of graphics!text and label geometries|(}
\index{plots!text in|(}
\index{plots!maths in|(}
Geometries \gggeom{geom\_text()} or \gggeom{geom\_label()} are used to add textual data labels and annotations to plots.

For \gggeom{geom\_text()} and \gggeom{geom\_label()}, the aesthetic \code{label} provides the text to be plotted and aesthetics \code{x} and \code{y}, the location of the labels. The size of the text is controlled by the \code{size} aesthetics, while the font is selected by the \code{family} and \code{fontface} aesthetics. Below, the whole-plot default mappings for \code{colour} and \code{size} aesthetics are overridden within \gggeom{geom\_text()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,}
                       \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{size} \hlstd{= wt,} \hlkwc{label} \hlstd{= cyl))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"darkblue"}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-text-plot-01-1} 

}


\end{knitrout}

Aesthetics \code{angle}, expressed in degrees, and \code{vjust} and \code{hjust} can be used to rotate the text and adjust its vertical and horizontal justification. The default value of 0.5 for both \code{hjust} and \code{vjust} sets the centre of the text at the supplied \code{x} and \code{y} coordinates. \emph{``Vertical'' and ``horizontal'' for text justification are relative to the text, not the plot.} This is important when \code{angle} is different from zero. Values larger than 0.5 shift the label left or down, and values smaller than 0.5, right or up with respect to its \code{x} and \code{y} coordinates. A value of 1 or 0 sets the text so that its edge is at the supplied coordinate. Values outside the range $0\ldots 1$ shift the text even farther away, however, still using units based on the length or height of the text label. Recent versions of \pkgname{ggplot2} make possible justification using character constants for alignment: \code{"left"}, \code{"middle"}, \code{"right"}, \code{"bottom"}, \code{"center"}, and \code{"top"}, and two special alignments, \code{"inward"} and \code{"outward"}, that automatically vary based on the position in the plotting area.

Below, \gggeom{geom\_text()} or \gggeom{geom\_label()} are used together with \gggeom{geom\_point()} similarly as they are used to add data labels in a plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,}
             \hlkwc{y} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{),}
             \hlkwc{label} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"ab"}\hlstd{,} \hlstr{"bc"}\hlstd{,} \hlstr{"cd"}\hlstd{,} \hlstr{"de"}\hlstd{,} \hlstr{"ef"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{label} \hlstd{= label))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlnum{90}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{1.5}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-text-plot-02a-1} 

}


\end{knitrout}

In the case of \gggeom{geom\_label()} the text is enclosed in a box and obeys the \code{fill} \emph{aesthetic} and additional parameters (described starting at page \pageref{start:plot:label}) allowing control of the shape and size of the box. Before \ggplot 3.5.0, \gggeom{geom\_label()} did not support rotation with the \code{angle} aesthetic.

\begin{playground}
Modify the example above to use \gggeom{geom\_label()} instead of \gggeom{geom\_text()} using, in addition, the \code{fill} aesthetic.
\end{playground}

A serif font is set by passing \code{family = "serif"}. The names \code{"sans"} (the default), \code{"serif"} and \code{"mono"} are recognised by all graphics devices on all operating systems. They do not necessarily correspond to identical fonts in different computers or for different graphic devices, but instead to fonts that are similar. Additional fonts are available for specific graphic devices, such as the 35 ``PDF'' fonts by the \code{pdf()} device. In this case, their names can be queried with \code{names(pdfFonts())}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{label} \hlstd{= label))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlnum{90}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{1.5}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"serif"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
In the examples above, the character strings were all of the same length, containing a single character. Redo the plots above with longer character strings of various lengths mapped to the \code{label} \emph{aesthetic}. Do also play with justification of these labels.
\end{playground}

\begin{warningbox}
\Rlang\index{plots!fonts} and \ggplot support the use of UNICODE\index{UNICODE}, such as UTF8\index{UTF8} character encodings in strings. If your editor or IDE supports their use, then you can type Greek letters and simple maths symbols directly, and they \emph{may} show correctly in labels if a suitable font is loaded and an extended encoding like UTF8 is in use by the operating system. Even if UTF8 is in use, text is not fully portable unless the same font is available\index{portability}, as even if the character positions are standardised for many languages, most UNICODE fonts support at most a small number of languages. In principle, one can use this mechanism to have labels both using other alphabets and languages like Chinese with their numerous symbols mixed in the same figure. Furthermore, the support for fonts and consequently character sets in \Rlang is output-device dependent. The font encoding used by \Rlang by default depends on the default locale settings of the operating system, which can also lead to garbage printed to the console or wrong characters being plotted running the same code on a different computer from the one where a script was created. Not all is lost, though, as \Rlang can be coerced to use system fonts and Google fonts with functions provided by packages \pkgname{showtext} and \pkgname{extrafont}. Encoding-related problems, especially in MS-Windows, are common.
\end{warningbox}

Plotting (mathematical) expressions involves mapping to the \code{label} aesthetic character strings that can be parsed as expressions, and setting \code{parse = TRUE} (see section \ref{sec:plot:plotmath} on page \pageref{sec:plot:plotmath}). Below, the character strings are assembled using \Rfunction{paste()} but, of course, they could have been also typed in as constant values. This use of \Rfunction{paste()} is an example of recycling of shorter vectors, \code{"alpha["} and \code{"]"} to match the length of \code{1:5} (see section \ref{sec:vectors} on page \pageref{sec:vectors}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{),} \hlkwc{label} \hlstd{=} \hlkwd{paste}\hlstd{(}\hlstr{"alpha["}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlstr{"]"}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{))}
\hlstd{my.data}\hlopt{$}\hlstd{label}
\end{alltt}
\begin{verbatim}
## [1] "alpha[1]" "alpha[2]" "alpha[3]" "alpha[4]" "alpha[5]"
\end{verbatim}
\end{kframe}
\end{knitrout}

Text and labels do not automatically expand the plotting area past their anchoring coordinates. In the example below, \code{expand\_limits(x = 5.2)} ensures that the text is not clipped at the edge of the plotting area.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{label} \hlstd{= label))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{hjust} \hlstd{=} \hlopt{-}\hlnum{0.2}\hlstd{,} \hlkwc{parse} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{6}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{5.2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-text-plot-06-1} 

}


\end{knitrout}

In the example above, the text to be parsed was mapped to the \code{label} aesthetic using character strings previously added to the data frame \code{my.data}. It is also possible, and usually preferable, to build suitable character strings with a nested function call, or a code statement, passed as an argument in the call to \code{aes()} (plot identical to the previous one, not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{label} \hlstd{=} \hlkwd{paste}\hlstd{(}\hlstr{"alpha["}\hlstd{, x,} \hlstr{"]"}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{)))} \hlopt{+}
  \hlkwd{geom_text}\hlstd{(}\hlkwc{hjust} \hlstd{=} \hlopt{-}\hlnum{0.2}\hlstd{,} \hlkwc{parse} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{6}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

Geometry \gggeom{geom\_label()} obeys the same aesthetics as \gggeom{geom\_text()} (except for \code{angle} in \ggplot <\,3.5.0) and additionally \code{label.size} for the width of the border line, \code{label.r} for the roundness of the box corners, \code{label.padding} for the space between the text boundary and the box boundary, and \code{fill} for the colour used to fill the boxes' background.

\label{start:plot:label}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{5}\hlstd{),}
             \hlkwc{label} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"one"}\hlstd{,} \hlstr{"two"}\hlstd{,} \hlstr{"three"}\hlstd{,} \hlstr{"four"}\hlstd{,} \hlstr{"five"}\hlstd{))}

\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{label} \hlstd{= label))} \hlopt{+}
  \hlkwd{geom_label}\hlstd{(}\hlkwc{hjust} \hlstd{=} \hlopt{-}\hlnum{0.2}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{6}\hlstd{,}
             \hlkwc{label.size} \hlstd{=} \hlnum{0}\hlstd{,}
             \hlkwc{label.r} \hlstd{=} \hlkwd{unit}\hlstd{(}\hlnum{0}\hlstd{,} \hlstr{"lines"}\hlstd{),}
             \hlkwc{label.padding} \hlstd{=} \hlkwd{unit}\hlstd{(}\hlnum{0.15}\hlstd{,} \hlstr{"lines"}\hlstd{),}
             \hlkwc{fill} \hlstd{=} \hlstr{"yellow"}\hlstd{,} \hlkwc{alpha} \hlstd{=} \hlnum{0.5}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{5.6}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-label-plot-01-1} 

}


\end{knitrout}

\begin{playground}
Starting from the example above, play with the arguments to the different parameters and with the mappings to \emph{aesthetics} to get an idea of the variations in the design that they allow. For example, use thicker border lines and increase the padding so that a visually well-balanced margin is retained. You may also try mapping the \code{fill} and \code{colour} \emph{aesthetics} to factors in the data.
\end{playground}

If\index{grammar of graphics!text and label geometries!repulsive} the parameter \code{check\_overlap} of \gggeom{geom\_text()} is set to \code{TRUE}, text overlap will be avoided by suppressing the text that would otherwise overlap other text.  \emph{Repulsive} versions of \gggeom{geom\_text()} and \gggeom{geom\_label()}, \gggeom{geom\_text\_repel()} and \gggeom{geom\_label\_repel()}, are available in package \pkgname{ggrepel}. These \emph{geometries} avoid overlaps by automatically repositioning the text or labels. Please read the package documentation for details of how to control the repulsion strength and direction, and the properties of the segments linking the labels to the position of their data coordinates. Nearly all aesthetics supported by \code{geom\_text()} and \code{geom\_label()} are supported by the repulsive versions. However, given that a segment connects the label or text to its anchor point, several properties of these segments can also be controlled with aesthetics or arguments.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,}
                     \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{size} \hlstd{= wt,} \hlkwc{label} \hlstd{= cyl))} \hlopt{+}
  \hlkwd{scale_size}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{3}\hlstd{)} \hlopt{+}
  \hlkwd{geom_text_repel}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{3}\hlstd{,}
                  \hlkwc{min.segment.length} \hlstd{=} \hlnum{0.2}\hlstd{,} \hlkwc{point.padding} \hlstd{=} \hlnum{0.1}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-repel-plot-01-1} 

}


\end{knitrout}
\index{plots!maths in|)}
\index{plots!text in|)}
\index{grammar of graphics!text and label geometries|)}

\subsection{Plot insets}\label{sec:plot:insets}
\index{grammar of graphics!inset-related geometries|(}
\index{plots!insets|(}

The support for insets in \pkgname{ggplot2} is confined to \code{annotation\_custom()}, which was designed to be used for static annotations expected to be the same in each panel of a plot (the use of annotations is described in section \ref{sec:plot:annotations}). Package \pkgname{ggpp} provides geoms that mimic \code{geom\_text()} in relation to the \emph{aesthetics} used, but that similarly to \code{geom\_sf()}, expect that the column in \code{data} mapped to the \code{label} aesthetics are lists of objects containing multiple pieces of information, rather than atomic vectors. Three geometries are currently available: \gggeom{geom\_table()}, \gggeom{geom\_plot()} and \gggeom{geom\_grob()}.

\begin{warningbox}
Given that  \gggeom{geom\_table()}, \gggeom{geom\_plot()}, and \gggeom{geom\_grob()} will rarely use a mapping inherited from the whole plot, by default they do not inherit it. Either the mapping should be supplied as an argument to these functions or their parameter \code{inherit.aes} explicitly set to \code{TRUE}.
\end{warningbox}

\index{plots!inset tables|(}
Tables can be added as plot insets with \gggeom{geom\_table()} by mapping a list of data frames (or tibbles) to the \code{label} \emph{aesthetic}. Positioning, justification, and angle work as for \gggeom{geom\_text()} and are applied to the whole table. The table(s) are constructed as \pkgnameNI{grid} \code{grob} objects and added to the \code{gg} plot object as a layer.

The code below builds a \code{tibble} containing summaries from the \code{mtcars} data set, with the summary values formatted as character strings, adds this tibble as the single member to a list, and stores this list as column named \code{table.inset} in another \code{tibble}, named code{table.tb}, together with the \code{x} and \code{y} coordinates for its location as an inset.

\begin{explainbox}
The code uses functions from the \pkgname{tidyverse} (see section \ref{sec:dplyr:group:wise} on page \pageref{sec:dplyr:group:wise}). Data frames and base \Rlang functions could have been used instead (see section \ref{sec:calc:df:aggregate} on page \pageref{sec:calc:df:aggregate}).
\end{explainbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mtcars |>}
  \hlkwd{group_by}\hlstd{(cyl) |>}
  \hlkwd{summarize}\hlstd{(}\hlstr{"mean wt"} \hlstd{=} \hlkwd{format}\hlstd{(}\hlkwd{mean}\hlstd{(wt),} \hlkwc{digits} \hlstd{=} \hlnum{3}\hlstd{),}
            \hlstr{"mean disp"} \hlstd{=} \hlkwd{format}\hlstd{(}\hlkwd{mean}\hlstd{(disp),} \hlkwc{digits} \hlstd{=} \hlnum{2}\hlstd{),}
            \hlstr{"mean mpg"} \hlstd{=} \hlkwd{format}\hlstd{(}\hlkwd{mean}\hlstd{(mpg),} \hlkwc{digits} \hlstd{=} \hlnum{2}\hlstd{))} \hlkwb{->} \hlstd{my.table}
\hlstd{table.tb} \hlkwb{<-} \hlkwd{tibble}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{500}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{35}\hlstd{,} \hlkwc{table.inset} \hlstd{=} \hlkwd{list}\hlstd{(my.table))}
\end{alltt}
\end{kframe}
\end{knitrout}

As with text labels, justification is interpreted in relation to table-text orientation, however, the default, \code{"inward"}, rarely needs to be changed if one sets $x$ and $y$ coordinates to the location of the inset corner farthest from the centre of the plot. The inset table is added at its native size, given by the \code{size} aesthetic, which is applied to the text in it.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{size} \hlstd{= wt))} \hlopt{+}
  \hlkwd{scale_size}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_table}\hlstd{(}\hlkwc{data} \hlstd{= table.tb,}
             \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x,} \hlkwc{y} \hlstd{= y,} \hlkwc{label} \hlstd{= table.inset),}
             \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-table-plot-02-1} 

}


\end{knitrout}

Parsed text, using \Rlang's \emph{plotmath} syntax is supported in tables, with fallback to plain text in case of parsing errors, on a cell-by-cell basis.

\begin{explainbox}
The \emph{geometry} \gggeom{geom\_table()} uses functions from package \pkgname{gridExtra} to build a graphical object for the table. A table theme can be passed as an argument to \gggeom{geom\_table()}.
\end{explainbox}
\index{plots!inset tables|)}

\index{plots!inset plots|(}
Geometry \gggeom{geom\_plot()} works similarly to \code{geom\_table()} but insets a ggplot within another ggplot. Thus, instead of expecting a list of data frames or tibbles to be mapped to the \code{label} aesthetics, it expects a list of ggplots (objects of class \code{gg}). Inset plots can be very useful for zooming-in on parts of a main plot where observations are crowded and for displaying summaries based on the observations shown in the main plot. The inset plots are nested in viewports which constrain the dimensions of the inset plot. Aesthetics \code{vp.height} and \code{vp.width} set the size of the viewports---with defaults of 1/3 of the height and width of the plotting area of the main plot. Themes can be applied separately to the main and inset plots.

In the first example of inset plots, the summaries shown above as numbers in a column in the inset table, are displayed in an inset column plot. We first create a one-row \code{data.frame} containing the plot to be inset as member of a \code{list}, and the $x$ and $y$ coordinates in the main plot of the location of the inset. Unlike with a \code{tibble}, with a \code{data.frame} we need to use \Rfunction{I()} to protect the \code{list}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mtcars |>}
  \hlkwd{group_by}\hlstd{(cyl) |>}
  \hlkwd{summarize}\hlstd{(}\hlkwc{mean.mpg} \hlstd{=} \hlkwd{mean}\hlstd{(mpg)) |>}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= _,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwd{factor}\hlstd{(cyl), mean.mpg,} \hlkwc{fill} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{scale_fill_discrete}\hlstd{(}\hlkwc{guide} \hlstd{=} \hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlkwa{NULL}\hlstd{)} \hlopt{+}
    \hlkwd{geom_col}\hlstd{()} \hlopt{+}
    \hlkwd{theme_bw}\hlstd{(}\hlnum{8}\hlstd{)} \hlkwb{->} \hlstd{my.plot}
\hlstd{plot.tb} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{500}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{35}\hlstd{,} \hlkwc{plot.inset} \hlstd{=} \hlkwd{I}\hlstd{(}\hlkwd{list}\hlstd{(my.plot)))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_plot}\hlstd{(}\hlkwc{data} \hlstd{= plot.tb,}
            \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x,} \hlkwc{y} \hlstd{= y,} \hlkwc{label} \hlstd{= plot.inset),}
            \hlkwc{vp.width} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{2}\hlstd{,}
            \hlkwc{hjust} \hlstd{=} \hlstr{"inward"}\hlstd{,} \hlkwc{vjust} \hlstd{=} \hlstr{"inward"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plot-plot-02-1} 

}


\end{knitrout}

In the second example, the plot inset is a zoom-in into a region of the base plot. The code to build this plot is split into three chunks. \code{p.main} is the plot to be used as the base for the final plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.main} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\code{p.inset}, is the plot to be used as the inset; the call to \code{coord\_cartesian()} zooms-into \code{p.main}; the call to \code{labs()} removes the redundant axis labels; the call to \code{scale\_colour\_discrete()} removes the redundant guide in the inset; and the calls to \code{theme\_bw()} and \code{theme()} change the theme and font size for the inset.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.inset} \hlkwb{<-} \hlstd{p.main} \hlopt{+}
  \hlkwd{coord_cartesian}\hlstd{(}\hlkwc{xlim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{270}\hlstd{,} \hlnum{330}\hlstd{),} \hlkwc{ylim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{14}\hlstd{,} \hlnum{19}\hlstd{))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwa{NULL}\hlstd{,} \hlkwc{y} \hlstd{=} \hlkwa{NULL}\hlstd{)} \hlopt{+}
  \hlkwd{scale_colour_discrete}\hlstd{(}\hlkwc{guide} \hlstd{=} \hlstr{"none"}\hlstd{)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{(}\hlnum{8}\hlstd{)} \hlopt{+} \hlkwd{theme}\hlstd{(}\hlkwc{aspect.ratio} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

As in the previous example, \gggeom{geom\_plot()} adds the inset, in this case with constant values for aesthetics. The call to \code{annotate()} using \gggeom{geom\_rect()} adds the rectangle highlighting the zoomed-in region in the main plot.\label{par:plot:inset:zoom}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.main} \hlopt{+}
  \hlkwd{geom_plot}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{480}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{34}\hlstd{,} \hlkwc{label} \hlstd{=} \hlkwd{list}\hlstd{(p.inset),} \hlkwc{vp.height} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{2}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"rect"}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{NA}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,}
           \hlkwc{xmin} \hlstd{=} \hlnum{270}\hlstd{,} \hlkwc{xmax} \hlstd{=} \hlnum{330}\hlstd{,} \hlkwc{ymin} \hlstd{=} \hlnum{14}\hlstd{,} \hlkwc{ymax} \hlstd{=} \hlnum{19}\hlstd{,}
           \hlkwc{linetype} \hlstd{=} \hlstr{"dotted"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plot-plot-03c-1} 

}


\end{knitrout}
\index{plots!inset plots|)}
\index{plots!inset graphical objects|(}
Geometry \gggeom{geom\_grob()} differs very little from \code{geom\_plot()} but insets \pkgname{grid} graphical objects, called \code{grob} for short. This approach is very flexible, as grobs can be vector graphics as well as contain rasters (or bitmaps). In most cases, the grobs need to be first created either using functions from package \pkgname{grid} to draw them or by converting other types of objects into grobs. Geometry \gggeom{geom\_grob()} is as flexible as \gggeom{annotation\_custom()} with respect to the grobs but behaves as a \emph{geometry}. Below, two bitmaps are added as ``labels'' to the base plot.

The bitmaps are read from PNG files (contained as examples in package \pkgname{gpmisc}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{file1.name} \hlkwb{<-}
  \hlkwd{system.file}\hlstd{(}\hlstr{"extdata"}\hlstd{,} \hlstr{"Isoquercitin.png"}\hlstd{,}
              \hlkwc{package} \hlstd{=} \hlstr{"ggpp"}\hlstd{,} \hlkwc{mustWork} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{Isoquercitin} \hlkwb{<-} \hlstd{magick}\hlopt{::}\hlkwd{image_read}\hlstd{(file1.name)}
\hlstd{file2.name} \hlkwb{<-}
  \hlkwd{system.file}\hlstd{(}\hlstr{"extdata"}\hlstd{,} \hlstr{"Robinin.png"}\hlstd{,}
              \hlkwc{package} \hlstd{=} \hlstr{"ggpp"}\hlstd{,} \hlkwc{mustWork} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{Robinin} \hlkwb{<-} \hlstd{magick}\hlopt{::}\hlkwd{image_read}\hlstd{(file2.name)}
\end{alltt}
\end{kframe}
\end{knitrout}

The two bitmaps are converted into \code{grobs}, added as two separate members to a list, and the list added as a column to a \code{data.frame} named, for this example, \code{grob.tb}. The coordinates for the position of each \code{grob} as well as the size of each viewport are also added to this \code{data.frame}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{grob.tb} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{100}\hlstd{),} \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwc{height} \hlstd{=} \hlnum{1}\hlopt{/}\hlnum{3}\hlstd{,} \hlkwc{width} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{/}\hlnum{2}\hlstd{),}
             \hlkwc{grobs} \hlstd{=} \hlkwd{I}\hlstd{(}\hlkwd{list}\hlstd{(grid}\hlopt{::}\hlkwd{rasterGrob}\hlstd{(}\hlkwc{image} \hlstd{= Isoquercitin),}
                            \hlstd{grid}\hlopt{::}\hlkwd{rasterGrob}\hlstd{(}\hlkwc{image} \hlstd{= Robinin))))}
\end{alltt}
\end{kframe}
\end{knitrout}

The two \code{grobs} are added as a single plot layer to an empty plot. Insets like these, can be added to any base plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{()} \hlopt{+}
  \hlkwd{geom_grob}\hlstd{(}\hlkwc{data} \hlstd{= grob.tb,}
            \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x,} \hlkwc{y} \hlstd{= y,} \hlkwc{label} \hlstd{= grobs,}
                          \hlkwc{vp.height} \hlstd{= height,} \hlkwc{vp.width} \hlstd{= width),}
                          \hlkwc{hjust} \hlstd{=} \hlstr{"inward"}\hlstd{,} \hlkwc{vjust} \hlstd{=} \hlstr{"inward"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plot-grob-01c-1} 

}


\end{knitrout}
\index{plots!inset graphical objects|)}

\begin{explainbox}
Grid graphics\index{grid graphics coordinate systems} provide the low-level functions that \pkgname{ggplot2} uses under the hood. Package \pkgname{grid} supports different types of units for expressing the coordinates of positions. In the \pkgname{ggplot2} user interface, \code{"native"} data coordinates are used with only a few exceptions. Package \pkgname{grid} supports the use of physical units like \code{"mm"} as well as relative units like "npc" \emph{normalised parent coordinates}. Positions expressed as npc are numbers in the range 0 to 1, relative to the dimensions of current \emph{viewport}, with origin at the lower left corner. Normalised parent coordinates ("npc") are useful when annotating plots and adding insets at positions relative to the plotting area, as these positions remain always consistent across different plots, or across panels when using facets with free axis limits.

Package \pkgname{ggplot2} interprets $x$ and $y$ coordinates in \code{"native"} data coordinates. Newly, \pkgname{ggplot2} >= 3.5.0 interprets ``mappings'' of variables and constant values enclosed in function \Rfunction{I()} as expressed using "npc" coordinates, skipping the usual mapping based on scales.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_label}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{I}\hlstd{(}\hlnum{0.5}\hlstd{),} \hlkwc{y} \hlstd{=} \hlkwd{I}\hlstd{(}\hlnum{0.9}\hlstd{),} \hlkwc{label} \hlstd{=} \hlstr{"a label"}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plot-npc-eb-02-1} 

}


\end{knitrout}

An earlier approach was provided by package \pkgname{ggpp} through \emph{pseudo aesthetics} \code{npcx} and \code{npcy} and \emph{geometries} that support them can be used with \pkgname{ggplot2} <= 3.4.4.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_label_npc}\hlstd{(}\hlkwc{npcx} \hlstd{=} \hlnum{0.5}\hlstd{,} \hlkwc{npcy} \hlstd{=} \hlnum{0.9}\hlstd{,} \hlkwc{label} \hlstd{=} \hlstr{"a label"}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,}
             \hlkwc{vjust} \hlstd{=} \hlstr{"center"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{explainbox}

\index{grammar of graphics!inset-related geometries|)}
\index{plots!insets|)}
\index{grammar of graphics!geometries|)}

\section{Statistics}\label{sec:plot:statistics}
\index{grammar of graphics!statistics|(}
All statistics, except \ggstat{stat\_identity()}, modify the \code{data} they receive before passing it to a geometry. Most statistics compute a specific summary from the data, but there are exceptions. More generally, they make it possible to integrate computations on the data into the plotting workflow. This saves effort but more importantly helps ensure that the data and summaries within a given plot are consistent. Table \ref{tab:plot:stats} list all the statistics used in the chapter.

When a factor is mapped to an aesthetic, each level creates a group. For example, in the first plot example in section \ref{sec:plot:line} on page \pageref{sec:plot:line}, the grouping resulted in separate lines. The grouping is not so obvious with other aesthetics but it is not different. Most \emph{statistics} operate separately on the data for each group, returning an independent summary for each group. Mapping a continuous variable to an aesthetics does not create groups. All aesthetics, including \code{x} and \code{y}, follow this pattern, thus a factor mapped to \code{x} also creates a group for each level of the factor.

\begin{table}
  \caption[Statistics]{\ggplot statistics described in section \ref{sec:plot:statistics}, packages where they are defined, their default geometry, and the aesthetics they use as input for computations.}\vspace{1ex}\label{tab:plot:stats}
  \centering
   \begin{tabular}{llll}
     \toprule
     Statistic & Package & Geometry & Aesthetics \\
     \midrule
     \code{stat\_function} & \pkgnameNI{ggplot2} & \code{geom\_function} & x \\
     \code{stat\_summary} & \pkgnameNI{ggplot2} & \code{geom\_pointrange} & x, y \\
     \code{stat\_smooth} & \pkgnameNI{ggplot2} & \code{geom\_smooth} & x, y, weight \\
     \code{stat\_poly\_line} & \pkgnameNI{ggpmisc} &\code{geom\_smooth} & x, y, weight \\
     \code{stat\_poly\_eq} & \pkgnameNI{ggpmisc} & \code{geom\_text} & x, y, weight  \\
     \code{stat\_fit\_tb} & \pkgnameNI{ggpmisc} & \code{geom\_table} & x, y, weight  \\
     \code{stat\_bin} & \pkgnameNI{ggplot2} & \code{geom\_bar} & x, y \\
     \code{geom\_histogram} & \pkgnameNI{ggplot2} & --- & x, y \\
     \code{stat\_bin2d} & \pkgnameNI{ggplot2} & \code{geom\_tile} & x, y \\
     \code{stat\_bin\_hex} & \pkgnameNI{ggplot2} & \code{geom\_hex} & x, y \\
     \code{stat\_density} & \pkgnameNI{ggplot2} & \code{geom\_area} & x, y \\
     \code{geom\_density} & \pkgnameNI{ggplot2} & --- & x, y \\
     \code{stat\_density\_2d} & \pkgnameNI{ggplot2} & \code{geom\_density\_2d} & x, y \\
     \code{stat\_boxplot} & \pkgnameNI{ggplot2} & \code{geom\_boxplot} & x, y  \\
     \code{stat\_ydensity} & \pkgnameNI{ggplot2} & \code{geom\_violin} & x, y  \\
     \code{geom\_violin} & \pkgnameNI{ggplot2} & --- & x, y  \\
     \code{geom\_quasirandom} & \pkgnameNI{ggbeeswarm} & --- & x, y \\
     \code{stat\_ma\_line} & \pkgnameNI{ggpmisc} & \code{geom\_smooth} & x, y \\
     \code{stat\_ma\_eq} & \pkgnameNI{ggpmisc} & \code{geom\_text} & x, y \\
     \code{stat\_centroid} & \pkgnameNI{ggpmisc} & \code{geom\_point} & x, y \\
     \code{stat\_quant\_line} & \pkgnameNI{ggpmisc} & \code{geom\_smooth} & x, y \\
     \code{stat\_quant\_eq} & \pkgnameNI{ggpmisc} & \code{geom\_text} & x, y \\
     \code{stat\_identity} & \pkgnameNI{ggplot2} & \code{geom\_point} & --- \\
     \bottomrule
   \end{tabular}
\end{table}

\subsection{Functions}\label{sec:plot:function}
\index{grammar of graphics!function statistic|(}
\index{plots!plots of functions|(}
Statistics \ggstat{stat\_function()} is the simplest to use and understand, even if unusual. It generates $y$ values by applying an \Rlang function to a sequence of $x$ values. The range of the \code{numeric} variable mapped to \code{x} determines the range of $x$ values used.

Any \Rlang function, user defined or not, can be used as long as it is vectorised, with the length of the returned vector equal to the length of the vector passed as an argument to its first parameter. The argument passed to parameter \code{n} of \code{geom\_function()} determines the length of the generated vector of $x$ values. The data frame returned contains these are the $x$ values and as $y$ values the values returned by the function.

The code to plot the Normal probability distribution function is very simple, relying on the defaults \code{n = 101} and \code{geom = "path"}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{=} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{3}\hlstd{,}\hlnum{3}\hlstd{)),}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{= dnorm)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-function-plot-01-1} 

}


\end{knitrout}

Using a named list, additional arguments can be passed to the function when called to generate the data (plot not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{=} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{3}\hlstd{,}\hlnum{4}\hlstd{)),}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{= dnorm,} \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{mean} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{.5}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Edit the code above so as to plot in the same figure three curves, either for three different values for \code{mean} or for three different values for \code{sd}.
\end{playground}

Named user-defined functions (not shown), and anonymous functions (below) can also be used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{=} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{0}\hlopt{:}\hlnum{1}\hlstd{),}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{,} \hlkwc{a}\hlstd{,} \hlkwc{b}\hlstd{)\{a} \hlopt{+} \hlstd{b} \hlopt{*} \hlstd{x}\hlopt{^}\hlnum{2}\hlstd{\},}
                \hlkwc{args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{b} \hlstd{=} \hlnum{1.4}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Edit the code above to use a different function, such as $e^{x + k}$, adjusting the argument(s) passed through \code{args} accordingly. Do this by means of an anonymous function, and by means of an equivalent named function defined by your code.
\end{playground}

\index{plots!plots of functions|)}
\index{grammar of graphics!function statistic|)}

\subsection{Summaries}\label{sec:plot:stat:summaries}
\index{grammar of graphics!summary statistic|(}
\index{plots!data summaries|(}
\index{plots!means}\index{plots!medians}\index{plots!error bars}
The summaries discussed in this section can be superimposed on raw data plots, or plotted on their own. Beware, that if scale limits are manually set, the summaries will be calculated from the subset of observations within these limits. Scale limits can be altered when explicitly defining a scale or by means of functions \Rfunction{xlim()} and \Rfunction{ylim()}. See section \ref{sec:plot:coord} on page \pageref{sec:plot:coord} for an explanation of how coordinate limits can be used to zoom into a plot without excluding of $x$ and $y$ values from the data.

It is possible to summarise data on the fly when plotting. The simultaneous calculation of measures of central tendency and of variation in \ggstat{stat\_summary()} allows them to be added together to the same plot layer.

Data frame \code{fake.data}, constructed below, contains normally distributed artificial values in variable \code{Y} in two groups, distinguished by the levels of factor \code{group}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fake.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}
  \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{0.5}\hlstd{),}
        \hlkwd{rnorm}\hlstd{(}\hlnum{10}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{0.7}\hlstd{)),}
  \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{10}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlnum{10}\hlstd{))))}
\end{alltt}
\end{kframe}
\end{knitrout}

Below, a base plot is constructed an assigned to \code{p1.base}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= y,} \hlkwc{x} \hlstd{= group))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{shape} \hlstd{=} \hlstr{"circle open"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

In \ggstat{stat\_summary()}, the \Rlang function used to compute the summaries is passed as an argument. This function can be one returning a single value, like \code{mean()}, or one returning a central value and the extremes of a range. With the default argument, \ggstat{stat\_summary()} plots means and standard errors, displaying a message.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlopt{+} \hlkwd{stat_summary}\hlstd{()}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# No summary function supplied, defaulting to `mean\_se()`}}\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-summary-plot-02-1} 

}


\end{knitrout}

For $\bar{x} \pm \mathrm{s.e.}$, the default, \code{"mean\_se"} can be passed as argument to \code{fun.data} to avoid the message seen above, and for $\bar{x} \pm \mathrm{s.d.}$ \code{"mean\_sdl"} should be passed as argument. These functions have to be passed to parameter \code{fun.data}, while functions that return a single value, like \code{"mean"}, to \code{fun}. The \code{geom} used has to be suitable for the values computed by the \code{stat}.

Below is code for a similar plot, with means highlighted in red, using \gggeom{geom\_point()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun} \hlstd{=} \hlstr{"mean"}\hlstd{,} \hlkwc{geom} \hlstd{=} \hlstr{"point"}\hlstd{,}
               \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{shape} \hlstd{=} \hlstr{"-"}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{15}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-summary-plot-03-1} 

}


\end{knitrout}

Below, confidence intervals for $P = 0.99$ computed assuming normality are added.
Intervals can be also computed without assuming normality, using the empirical distribution estimated from the data by bootstrap using \code{"mean\_cl\_boot"} instead of \code{"mean\_cl\_normal"}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,} \hlkwc{fun.args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{conf.int} \hlstd{=} \hlnum{0.99}\hlstd{),}
               \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{0.7}\hlstd{,} \hlkwc{linewidth} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{alpha} \hlstd{=} \hlnum{0.5}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-summary-plot-04-1} 

}


\end{knitrout}

\begin{explainbox}
It is possible to use user-defined functions instead of the functions exported by package \ggplot (based on those in package \Hmisc). Additional named arguments can be passed to the summary function through parameter \code{fun.args} of \ggstat{stat\_summary()}.
\end{explainbox}

Means, or other summaries, computed by groups based on the factor mapped to the \code{x} aesthetic (\code{class} in this example) can be plotted as columns by passing \code{"col"} as an argument to parameter \code{geom}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= class,} \hlkwc{y} \hlstd{= hwy))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"col"}\hlstd{,} \hlkwc{fun} \hlstd{= mean)}
\end{alltt}
\end{kframe}
\end{knitrout}

Error bars can be added to the column plot. Passing \code{linewidth = 1} makes the lines of the error bars thicker. The default \emph{geometry} in \ggstat{stat\_summary()} is \gggeom{geom\_pointrange()}, passing \code{"linerange"} as an argument for \code{geom} removes the points at the top edge of the bars.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2.base} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"linerange"}\hlstd{,} \hlkwc{fun.data} \hlstd{=} \hlstr{"mean_cl_normal"}\hlstd{,}
               \hlkwc{linewidth} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-summary-plot-12-1} 

}


\end{knitrout}

Passing \code{"errorbar"} instead of \code{"linerange"} to \code{geom} results in traditional ``capped'' error bars. However, this type of error bar has been criticised as adding unnecessary clutter to plots \autocite{Tufte1983}. Aesthetic \code{width} controls the width of the caps at the ends of the tips bars.

When calculated values for the summaries are already available in \code{data}, equivalent plots can be obtained by mapping the summary values from \code{data} to the \emph{aesthetics} \code{x}, \code{y}, \code{ymax}, and \code{ymin} and using the \code{geoms} \gggeom{geom\_errorbar()} and \gggeom{geom\_linerange()} with their default for \code{stat}, \ggstat{stat\_identity()}, to add a plot layer.

\begin{explainbox}
A layer can be added to a plot directly with a \code{geom}, possibly passing a \code{stat} as an argument to it. In this book I have usually avoided this alternative syntax, except when not overriding \ggstat{stat\_identity()}, the usual default. The two code statements below are equivalent.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= class,} \hlkwc{y} \hlstd{= hwy))} \hlopt{+}
  \hlkwd{geom_col}\hlstd{(}\hlkwc{stat} \hlstd{=} \hlstr{"summary"}\hlstd{,} \hlkwc{fun} \hlstd{= mean)}

\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= class,} \hlkwc{y} \hlstd{= hwy))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"col"}\hlstd{,} \hlkwc{fun} \hlstd{= mean)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}
\index{plots!data summaries|)}
\index{grammar of graphics!summary statistic|)}

\subsection{Smoothers and models}\label{sec:plot:smoothers}
\index{plots!smooth curves|(}
\index{plots!fitted curves|(}
\index{plots!statistics!smooth}

For describing or highlighting relationships between pairs of continuous variables, using a line, straight or curved, in a plot is very effective. Drawing lines that provide a meaningful and accurate description of the relationship, requires lines based on predictions from models fitted to the observations. Frequently fitted models make possible to assess the reliability of the estimation. See section \ref{sec:stat:mf} on page \pageref{sec:stat:mf} for a description of the model fitting procedures underlying the plotting described in the current section.

The statistic \ggstat{stat\_smooth()} fits a smooth curve to observations in the case when the scales for $x$ and $y$ are continuous---the corresponding \emph{geometry} \gggeom{geom\_smooth()} uses this \emph{statistic}, and differs only in how arguments are passed to formal parameters. In the first example, \ggstat{stat\_smooth()} with the default smoother, a spline is used. In \ggstat{stat\_smooth()}, the type of smoother, or \code{method}, is automatically chosen based on the number of observations, and the choice informed by a message. In statistics, the \code{formula} must be stated using the names of the $x$ and $y$ aesthetics, rather than the original names of the variables mapped, i.e., in this example, not their name in the \code{mtcars} data frame. Splines are described in section \ref{sec:stat:splines} on page \pageref{sec:stat:splines}. When their small enough number makes it possible, observations are usually plotted as points together with the smoother. The observations can be plotted on top of the smoother or the smoother on top of the observations, as done here.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"loess"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-smooth-plot-02-1} 

}


\end{knitrout}

A model different to the default one can be used. Below, a linear regression is fitted with \Rfunction{lm()}. Fitting of linear models is explained in section \ref{sec:stat:LM} on page \pageref{sec:stat:LM}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)}
\end{alltt}
\end{kframe}
\end{knitrout}

These data can be grouped, here by mapping \code{factor(cyl)} to the \code{colour} \emph{aesthetic}. With three groups, three separate linear regressions are fitted, and displayed as three straight lines. Each one line is delimited by a confidence band for the ``true'' location of the curve.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlkwd{aes}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl))} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-smooth-plot-04-1} 

}


\end{knitrout}

To obtain a single fitted smoother, in this case a joint linear regression line for the three groups, the grouping in the layer was disabled by mapping a constant value to the \code{colour} \emph{aesthetic} in the call to \ggstat{stat\_smooth()}. Values passed to a layer function as argument override the defaults set in \code{ggplot()}. The use of \code{"black"} is arbitrary, any other \code{color} definition known to \Rlang could have been used instead.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlkwd{aes}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl))} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

A different linear model, a second degree polynomial in this example, is fitted below by passing a different argument to \code{formula} than in the example above for linear regression.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlkwd{aes}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl))} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlkwd{poly}\hlstd{(x,} \hlnum{2}\hlstd{),} \hlkwc{colour} \hlstd{=} \hlstr{"grey20"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-smooth-plot-06-1} 

}


\end{knitrout}

\begin{explainbox}
It is possible to use other types of models, including GAM and GLM, as smoothers.  I give next two simple examples of the use of \code{nls()} to fit a model non-linear in its parameters (see section \ref{sec:stat:NLS} on page \pageref{sec:stat:NLS} for details about fitting this same model with \code{nls()}). In both examples, the model fitted is the Michaelis-Menten equation, describing the rate of a chemical reaction (\code{rate}) as a function of reactant concentration (\code{conc}). \Rdata{Puromycin} is a data set included in the \Rlang distribution. Function \Rfunction{SSmicmen()}, used in the first example, is also from \Rlang, and is a \emph{self-starting}\index{self-starting functions} implementation of the Michaelis-Menten equation. Thanks to this, even though the fit is done with an iterative algorithm, starting values for the parameters to be fitted are not needed. Passing \code{se = FALSE} suppresses the attempt to compute a confidence band as it is not supported by the \code{predict()} method for model fits done with function \Rfunction{nls()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Puromycin,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(conc, rate,} \hlkwc{colour} \hlstd{= state))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"nls"}\hlstd{,} \hlkwc{formula} \hlstd{=  y} \hlopt{~} \hlkwd{SSmicmen}\hlstd{(x, Vm, K),} \hlkwc{se} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-smooth-plot-07-1} 

}


\end{knitrout}

In the second example, the code describing the equation is passed as an argument to \code{formula}, with starting values passed as a named list to \code{start}. The names used for the parameters to be estimated by fitting the model can be chosen at will, within the restrictions of the \Rlang language, but of course the names used in \code{formula} and \code{start} must match each other. As for other models, \code{x} and \code{y} are the names of the aesthetics to which the observations have been mapped (plot not shown).%
\pagebreak

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Puromycin,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(conc, rate,} \hlkwc{colour} \hlstd{= state))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{geom_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"nls"}\hlstd{,}
              \hlkwc{formula} \hlstd{=  y} \hlopt{~} \hlstd{(Vmax} \hlopt{*} \hlstd{x)} \hlopt{/} \hlstd{(k} \hlopt{+} \hlstd{x),}
              \hlkwc{method.args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{start} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{Vmax} \hlstd{=} \hlnum{200}\hlstd{,} \hlkwc{k} \hlstd{=} \hlnum{0.05}\hlstd{)),}
              \hlkwc{se} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

In some cases, it is desirable to annotate plots with fitted model equations or fitted parameters. One way of achieving this is by fitting the model and then extracting the parameters to manually construct text strings to use for text or label annotations. However, package \pkgname{ggpmisc} makes it possible to automate such annotations in many cases. This package also provides \ggstat{stat\_poly\_line()}, which is similar to \ggstat{stat\_smooth()} but with \code{method = "lm"} consistently as its default irrespective of the number of observations.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.formula} \hlkwb{<-} \hlstd{y} \hlopt{~} \hlstd{x} \hlopt{+} \hlkwd{I}\hlstd{(x}\hlopt{^}\hlnum{2}\hlstd{)}
\hlstd{p3} \hlopt{+} \hlkwd{aes}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl))} \hlopt{+}
  \hlkwd{stat_poly_line}\hlstd{(}\hlkwc{formula} \hlstd{= my.formula,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_poly_eq}\hlstd{(}\hlkwc{formula} \hlstd{= my.formula,} \hlkwc{mapping} \hlstd{=} \hlkwd{use_label}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"eq"}\hlstd{,} \hlstr{"F"}\hlstd{)),}
               \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{label.x} \hlstd{=} \hlstr{"right"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-smooth-plot-12-1} 

}


\end{knitrout}

Package \pkgname{ggpmisc} also makes it possible to annotate plots with summary tables from a model fit. The argument passed to \code{tb.vars} substitutes the names of the columns in the table.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
  \hlkwd{stat_poly_line}\hlstd{(}\hlkwc{formula} \hlstd{= my.formula,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{stat_fit_tb}\hlstd{(}\hlkwc{method.args} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{formula} \hlstd{= my.formula),}
              \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,}
              \hlkwc{parse} \hlstd{=} \hlnum{TRUE}\hlstd{,}
              \hlkwc{tb.vars} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwc{Parameter} \hlstd{=} \hlstr{"term"}\hlstd{,}
                          \hlkwc{Estimate} \hlstd{=} \hlstr{"estimate"}\hlstd{,}
                          \hlstr{"s.e."} \hlstd{=} \hlstr{"std.error"}\hlstd{,}
                          \hlstr{"italic(t)"} \hlstd{=} \hlstr{"statistic"}\hlstd{,}
                          \hlstr{"italic(P)"} \hlstd{=} \hlstr{"p.value"}\hlstd{),}
              \hlkwc{label.y} \hlstd{=} \hlstr{"top"}\hlstd{,} \hlkwc{label.x} \hlstd{=} \hlstr{"right"}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y} \hlstd{=} \hlnum{40}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-smooth-plot-13-1} 

}


\end{knitrout}

Package \pkgname{ggpmisc} provides additional \emph{statistics} for the annotation of plots based on fitted models supported by package \pkgname{broom} and its extensions. It also supports lines and equations for quantile regression and major axis regression. Please see the package documentation for details.

\index{plots!smooth curves|)}
\index{plots!fitted curves|)}

\subsection{Frequencies and counts}\label{sec:histogram}\label{sec:plot:histogram}
\index{plots!histograms|(}

When the number of observations is rather small, it is possible rely on the density of graphical elements, such as points, to convey the density of the observations. For example, scatter plots using well-chosen values for transparency, \code{alpha}, can give a satisfactory impression of the density. Rug plots, described in section \ref{sec:plot:rug} on page \pageref{sec:plot:rug}, can also satisfactorily convey the density of observations along $x$ and/or $y$ axes. Such approaches do not involve computations, while the \emph{statistics} described in this section do. Frequencies by value-range (or bins) and empirical density functions are summaries especially useful when the number of observations is large. These summaries can be computed in one or more dimensions.

Histograms are defined by how the plotted values are calculated. Although histograms are most frequently plotted as bar plots, many bar or ``column'' plots are not histograms. Although rarely done in practice, a histogram could be plotted using a different \emph{geometry} using \ggstat{stat\_bin()}, the \emph{statistic} used by default by \gggeom{geom\_histogram()}. This \emph{statistic} does binning of observations before computing frequencies, and is suitable for observations on a continuous scales, usually mapped to the \code{x} aesthetic. When a factor is mapped to \code{x}, \ggstat{stat\_count()} can be used, the default \code{stat} of \gggeom{geom\_bar()}. These two \emph{geometries} are described in this section about statistics, because they default to using statistics different from \code{stat\_identity()} and consequently summarise the data.

The code below constructs a data frame containing an artificial data set.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{54321}\hlstd{)}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{X} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{600}\hlstd{),}
             \hlkwc{Y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{300}\hlstd{,} \hlopt{-}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{),} \hlkwd{rnorm}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1}\hlstd{)),}
             \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{300}\hlstd{,} \hlnum{300}\hlstd{))) )}
\end{alltt}
\end{kframe}
\end{knitrout}

A default and usually suitable number of bins is automatically selected by the \ggstat{stat\_bin()} statistic; however, passing \code{bins = 15} sets it manually. In a histogram plot the variable mapped onto the \code{y} \emph{aesthetic} is not from \code{data} but instead computed in the statistics as the number of observations falling in each \emph{bin}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X))} \hlopt{+}
  \hlkwd{geom_histogram}\hlstd{(}\hlkwc{bins} \hlstd{=} \hlnum{15}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-histogram-plot-01-1} 

}


\end{knitrout}

\begin{explainbox}
A reason to add layers with \gggeom{geom\_histogram()}, instead of with \ggstat{stat\_bin()} or \ggstat{stat\_count()} is that its name is easier to remember.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Y,} \hlkwc{fill} \hlstd{= group))} \hlopt{+}
  \hlkwd{stat_bin}\hlstd{(}\hlkwc{bins} \hlstd{=} \hlnum{15}\hlstd{,} \hlkwc{position} \hlstd{=} \hlstr{"dodge"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

The grouping created by mapping a factor to an additional \emph{aesthetic}, results in two separate histograms. The position of the two groups of bars with respect to each other is controlled with \emph{position} functions (see section \ref{sec:plot:positions} on page \pageref{sec:plot:positions} for details). With \code{position = "dodge"}, bars are plotted side by side; with \code{position = "stack"}, the default, plotted one above the other; and with \code{position = "identity"} overlapping. In this last case, adding \code{alpha = 0.5} makes occluded bars visible. The examples below use \code{position = "dodge"}.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Y,} \hlkwc{fill} \hlstd{= group))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_histogram}\hlstd{(}\hlkwc{bins} \hlstd{=} \hlnum{15}\hlstd{,} \hlkwc{position} \hlstd{=} \hlstr{"dodge"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

In addition to \code{count}, \code{density}, computed as \code{count} divided by the number of observations in the group, is returned, and mapped in \code{p2} using \Rfunction{after\_stat()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_histogram}\hlstd{(}\hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{=} \hlkwd{after_stat}\hlstd{(density)),}
                              \hlkwc{bins} \hlstd{=} \hlnum{15}\hlstd{,} \hlkwc{position} \hlstd{=} \hlstr{"dodge"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-histogram-plot-03a-1} 

}


\end{knitrout}

\emph{Statistic} \ggstat{stat\_bin2d()}, and its matching \emph{geometry} \gggeom{geom\_bin2d()}, by default compute a frequency histogram in two dimensions, along the \code{x} and \code{y} \emph{aesthetics}. The \code{count} for each 2D bin is mapped to the \code{fill} aesthetic, with a lighter-coloured value being equivalent to a taller bar in a 1D histogram.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,} \hlkwc{y} \hlstd{= Y))} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlkwc{facets} \hlstd{=} \hlkwd{vars}\hlstd{(group))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{stat_bin2d}\hlstd{(}\hlkwc{bins} \hlstd{=} \hlnum{8}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-bin2d-plot-01-1} 

}


\end{knitrout}

\emph{Statistic} \ggstat{stat\_bin\_hex()}, and its matching \emph{geometry} \gggeom{geom\_hex()}, differ from \ggstat{stat\_bin2d()} only in their use of hexagonal instead of square bins, and tiles.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{stat_bin_hex}\hlstd{(}\hlkwc{bins} \hlstd{=} \hlnum{8}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-hex-plot-01-1} 

}


\end{knitrout}

As \ggstat{stat\_bin()}, \ggstat{stat\_bin2d()} and \ggstat{stat\_bin\_hex()} compute \code{density} in addition to \code{counts} and they can be plotted by mapping them to the \code{fill} aesthetic.
\index{plots!histograms|)}

\subsection{Density functions}\label{sec:plot:density}
\index{plots!density plot!1 dimension|(}
\index{plots!statistics!density}
Empirical density functions are the equivalent of a histogram, but are continuous and not calculated using bins, but fitted. They can be estimated in 1 or 2 dimensions (1D or 2D). As with histograms it is possible to use different \emph{geometries} with them. Examples of \gggeom{geom\_density()} used to create 1D density plots follow. A semitransparent fill is used in addition to colour. Density plots for \code{Y} and \code{X}, i.e., using as mappings \code{x = Y} and \code{x = X}, are shown below side-by-side).



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Y,} \hlkwc{colour} \hlstd{= group,} \hlkwc{fill} \hlstd{= group))} \hlopt{+}
  \hlkwd{geom_density}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.3}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p4} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,} \hlkwc{colour} \hlstd{= group,} \hlkwc{fill} \hlstd{= group))} \hlopt{+}
  \hlkwd{geom_density}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.3}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Plot composition, as used below, is described in detail in section \ref{sec:plot:composition} on page \pageref{sec:plot:composition}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlstd{p4} \hlcom{# plot composition}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-density-plot-03-1} 

}


\end{knitrout}
\index{plots!density plot!1 dimension|)}

\index{plots!density plot!2 dimensions|(}
\index{plots!statistics!density 2d}

A 2D density plot using the same data as for the 1D plots above. In the first example, \ggstat{stat\_density\_2d()} creates two 2D density ``maps'' shown using isolines, with \code{group} mapped to the \code{colour} \emph{aesthetic}. Isolines can be used when the empirical distributions overlap. The 1D plots above show the projections of the 2D density in the plot below onto the two axes.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,} \hlkwc{y} \hlstd{= Y,} \hlkwc{colour} \hlstd{= group))} \hlopt{+}
  \hlkwd{stat_density_2d}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.46\textwidth]{figure/pos-density-plot-10-1} 

}


\end{knitrout}
\pagebreak

Below, the 2D density for each group is plotted in a separate panel, with \code{level}, a variable computed by \code{stat\_density\_2d()}, mapped to the \code{fill} \emph{aesthetic}.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,} \hlkwc{y} \hlstd{= Y))} \hlopt{+}
  \hlkwd{stat_density_2d}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill} \hlstd{=} \hlkwd{after_stat}\hlstd{(level)),} \hlkwc{geom} \hlstd{=} \hlstr{"polygon"}\hlstd{)} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlkwc{facets} \hlstd{=} \hlkwd{vars}\hlstd{(group))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-density-plot-12-1} 

}


\end{knitrout}


\index{plots!density plot!2 dimensions|)}

\subsection{Box and whiskers plots}\label{sec:boxplot}
\index{box plots|see{plots, box and whiskers plot}}
\index{plots!box and whiskers plot|(}

Box and whiskers plots, or just box plots, are summaries that convey some of the properties of a distribution. They are calculated and plotted with \ggstat{stat\_boxplot()} or the matching \gggeom{geom\_boxplot()}. Although box plots can be plotted based on just a few observations, they are not useful unless each box plot is based on more than 10 to 15 observations. In the next example, a sample of every sixth row from the data frame \code{my.data} with 600 rows is used.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= my.data[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlkwd{rep}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{5}\hlstd{)) , ],}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= group,} \hlkwc{y} \hlstd{= Y))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{stat_boxplot}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

As with other \emph{statistics}, the appearance obeys both \emph{aesthetics} such as \code{colour}, and parameters specific to box plots: \code{outlier.colour}, \code{outlier.fill}, \code{outlier.shape}, \code{outlier.size}, \code{outlier.stroke}, and \code{outlier.alpha}, which affect outliers similarly to equivalent \code{aesthetics}. The shape and width of the ``box'' can be adjusted with \code{notch}, \code{notchwidth} and \code{varwidth}. Notches in box plots play a similar role as confidence limits play for means.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlkwb{<-}
  \hlstd{p.base} \hlopt{+}
  \hlkwd{stat_boxplot}\hlstd{(}\hlkwc{notch} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{0.4}\hlstd{,}
               \hlkwc{outlier.colour} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{outlier.shape} \hlstd{=} \hlstr{"*"}\hlstd{,} \hlkwc{outlier.size} \hlstd{=} \hlnum{5}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

The two plots have been composed side by side to save space (see section \ref{sec:plot:composing} on page \pageref{sec:plot:composing} for details about composing plots).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-bw-plot-03-1} 

}


\end{knitrout}

\index{plots!box and whiskers plot|)}

\subsection{Violin plots}\label{sec:plot:violin}
\index{plots!violin plot|(}

Violin plots are a more recent development than box plots, and usable with relatively large numbers of observations. They could be thought of as being a sort of hybrid between an empirical density function (see section \ref{sec:plot:density} on page \pageref{sec:plot:density}) and a box plot (see section \ref{sec:boxplot} on page \pageref{sec:boxplot}). As is the case with box plots, they are particularly useful when comparing distributions of related data, side by side. They can be created with  \gggeom{geom\_violin()} as shown in the examples below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlkwb{<-} \hlstd{p.base} \hlopt{+}
  \hlkwd{geom_violin}\hlstd{(}\hlkwd{aes}\hlstd{(}\hlkwc{fill} \hlstd{= group),} \hlkwc{alpha} \hlstd{=} \hlnum{0.16}\hlstd{)} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.33}\hlstd{,} \hlkwc{size} \hlstd{=} \hlnum{1.5}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{shape} \hlstd{=} \hlnum{21}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

As with other \emph{geometries}, their appearance obeys both the usual \emph{aesthetics}, such as colour, and others specific to these types of visual representation.

Other types of displays related to violin plots are \emph{beeswarm} plots and \emph{sina} plots, and can be produced with \emph{geometries} defined in packages \pkgname{ggbeeswarm} and \pkgname{ggforce}, respectively. A minimal example of a beeswarm plot is shown below. See the documentation of the packages for details about the many options in their use.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p4} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_quasirandom}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlstd{p4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-ggbeeswarm-plot-012-1} 

}


\end{knitrout}

\index{plots!violin plot|)}
\index{grammar of graphics!statistics|)}



\section{Flipped Plot Layers}\label{sec:plot:flipped}
\index{grammar of graphics!flipped axes|(}
\index{grammar of graphics!swap axes}
\index{grammar of graphics!orientation}
\index{grammar of graphics!horizontal geometries}
\index{grammar of graphics!horizontal statistics}

Although it is the norm to design plots so that the independent variable is on the $x$ axis, i.e., mapped to the \code{x} aesthetic, there are situations where swapping the roles of $x$ and $y$ is useful. In `ggplot2', this is described as \emph{flipping the orientation} of a plot or of a plot layer. In the present section, I exemplify both cases where the flipping is automatic and where flipping requires user intervention. Some geometries like \gggeom{geom\_point()} are symmetric on the \textit{x} and \textit{y} aesthetics, but others like \gggeom{geom\_line()} operate differently on \textit{x} and \textit{y}. This is also the case for most \emph{statistics}.

Starting from \ggplot version 3.3.5, most geometries and statistics where it is meaningful, support flipping using a new syntax. This new approach is different to the flip of the coordinate system (which is expected to be deprecated in the future), and conceptually similar to that implemented by package \pkgname{ggstance}. However, instead of defining new horizontal layer functions as in \pkgname{ggstance}, in \ggplot the orientation of many layer functions can change. This has made package \pkgname{ggstance} nearly redundant and the coding of flipped plots easier and more intuitive. Although \ggplot has offered \ggcoordinate{coord\_flip()} for a long time, flipping of plot coordinates affects the whole plot rather than individual layers.

When a factor is mapped to $x$ or $y$ flipping is automatic. A factor creates groups and summaries are computed per group, i.e., per level of the factor irrespective of the factor being mapped to the $x$ or $y$ aesthetic. There are also cases that require user intervention. For example, flipping must be requested manually if both $x$ and $y$ are mapped to continuous variables. This is, for example, the case with \ggstat{stat\_smooth()} and with \gggeom{geom\_line()}.

\begin{figure}
  \centering%
  {\sffamily%
\resizebox{0.8\linewidth}{!}{%
\begin{tikzpicture}[auto]
    \node [b] (data) {data};
    \node [bo, right = of data] (statistic) {statistic};
    \node [b, right = of statistic] (geometry) {geometry};
    \node [b, right = of geometry] (render) {rendered\\plot};

    \path [ll] (statistic) -- (data) node[near end,above]{\ \ \ \ \ \ $x \rightleftarrows y$};
    \path [ll] (geometry) -- (statistic) node[near end,above]{\ \ \ \ \ \ $y \rightleftarrows x$};
    \path [ll] (render) -- (geometry) node[near end,above]{};
  \end{tikzpicture}}\\[2.5ex]
  \resizebox{0.8\linewidth}{!}{%
\begin{tikzpicture}[auto]
    \node [b] (data) {data};
    \node [b, right = of data] (statistic) {statistic};
    \node [bo, right = of statistic] (geometry) {geometry};
    \node [b, right = of geometry] (render) {rendered\\plot};

    \path [ll] (statistic) -- (data) node[near end,above]{};
    \path [ll] (geometry) -- (statistic) node[near end,above]{\ \ \ \ \ \ $x \rightleftarrows y$};
    \path [ll] (render) -- (geometry) node[near end,above]{\ \ \ \ \ \ $y \rightleftarrows x$};
  \end{tikzpicture}}}
  \caption[Flipped layers diagram]{Flipped layers. Top diagram, flipped aesthetics in statistic with \code{orientation = "y"}; bottom diagram, flipped aesthetics in geometry with \code{orientation = "y"}. During flipping, related aesthetics such as \code{xmin} and \code{ymin} are also swapped, but not shown in the diagram. }\label{fig:plot:flip:stat}
\end{figure}

In \emph{statistics}, passing \code{orientation = "y"} as argument results in the calculations being applied after swapping the mappings of the \code{x} and \code{y} aesthetics. After applying the calculations, the mappings of the $x$ and $y$ and related aesthetics are swapped back (Figure \ref{fig:plot:flip:stat}).

In geometries, passing \code{orientation = "y"} also results in flipping of the aesthetics  (Figure \ref{fig:plot:flip:stat}). For example, in \gggeom{geom\_line()}, flipping changes the drawing of the lines. Normally observations are sorted along the $x$ axis before drawing the line segments connecting them. After flipping, as $x$ and $y$ are swapped, observations are sorted along the $y$ axis before drawing the connecting segments. The variables shown on each axis remain the same, as does the position of points drawn with \gggeom{geom\_point()}, but the line connecting them is different: in the example below, only two segments are the same in the flipped plot and in the ``normal'' one.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
   \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars[}\hlnum{1}\hlopt{:}\hlnum{8}\hlstd{, ],} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= hp,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
    \hlkwd{geom_point}\hlstd{()}
\hlstd{p1} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_line}\hlstd{()} \hlopt{+} \hlkwd{ggtitle}\hlstd{(}\hlstr{"Not flipped"}\hlstd{)}
\hlstd{p2} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_line}\hlstd{(}\hlkwc{orientation} \hlstd{=} \hlstr{"y"}\hlstd{)} \hlopt{+} \hlkwd{ggtitle}\hlstd{(}\hlstr{"Flipped"}\hlstd{)}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping_box-01a-ggplot-1} 

}


\end{knitrout}

The next pair of examples demonstrates automatic flipping using \ggstat{stat\_boxplot()}. Factor \code{Species} is mapped first to $x$ and then to $y$. In both cases, the same boxplots were computed and plotted for each level of the factor. Statistics \ggstat{stat\_boxplot()}, \ggstat{stat\_summary()}, \ggstat{stat\_histogram()} and \ggstat{stat\_density()} behave similarly with respect to automatic flipping.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Species,} \hlkwc{y} \hlstd{= Sepal.Length))} \hlopt{+}
  \hlkwd{stat_boxplot}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p4} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Sepal.Length,} \hlkwc{y} \hlstd{= Species))} \hlopt{+}
  \hlkwd{stat_boxplot}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlstd{p4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-01-02-ggplot-1} 

}


\end{knitrout}

In the case of \code{stats} that do computations on a single variable mapped to \code{x} or \code{y} aesthetics, flipping is also automatic.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p5} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Sepal.Length,} \hlkwc{colour} \hlstd{= Species))} \hlopt{+}
  \hlkwd{stat_density}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{position} \hlstd{=} \hlstr{"identity"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p6} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{y} \hlstd{= Sepal.Length,} \hlkwc{colour} \hlstd{= Species))} \hlopt{+}
  \hlkwd{stat_density}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"line"}\hlstd{,} \hlkwc{position} \hlstd{=} \hlstr{"identity"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p5} \hlopt{+} \hlstd{p6}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-03-04-ggplot-1} 

}


\end{knitrout}



\begin{explainbox}
In the case of ordinary least squares (OLS), regressions of $y$ on $x$ and of $x$ on $y$ in most cases yield different fitted lines, even if $R^2$ is consistent. This is due to the assumption that $x$ values are known, either set or measured without error, i.e., not subject to uncertainty. Under this assumption, all unexplained variation in the data is attributed to $y$. See section \ref{sec:stat:mf} on page \pageref{sec:stat:mf} or consult a Statistics book such as \citetitle{Holmes2019} \autocite[][pp.\ 168--170]{Holmes2019} for additional information.
\end{explainbox}

With two continuous variables mapped, the default is to take $x$ as independent and $y$ as dependent. Passing \code{"x"} (the default) or \code{"y"} as argument to parameter \code{orientation} indicates which of $x$ or $y$ is the independent or explanatory variable.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Sepal.Length,} \hlkwc{y} \hlstd{= Petal.Length))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlstd{Species,} \hlkwc{scales} \hlstd{=} \hlstr{"free"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-05-ggplot-1} 

}


\end{knitrout}

Passing \code{orientation = "y"} to \gggeom{geom\_smooth()} is equivalent to swapping $x$ and $y$ in the model \code{formula}. The looser the correlation, the more different are the lines fitted before and after flipping.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x,} \hlkwc{orientation} \hlstd{=} \hlstr{"y"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-06-ggplot-1} 

}


\end{knitrout}

The two variables in the example above, are both response variables, not directly connected by cause and effect, and with measurements subject to similar errors. None, of the two fitted models are close enough to fulfilling the assumptions.

\begin{explainbox}
Flipping the orientation of plot layers with \code{orientation = "y"} is not equivalent to flipping the whole plot with \ggcoordinate{coord\_flip()}. In the first case, which axis is considered independent for computation changes but not the positions of the axes in the plot, while in the second case, the position of the $x$ and $y$ axes in the plot is swapped. So, when coordinates are flipped the $x$ aesthetic is plotted on the vertical axis and the $y$ aesthetic on the horizontal axis, but the role of the variable mapped to the \code{x} aesthetic remains as explanatory variable. (Use of \ggcoordinate{coord\_flip()} will likely be deprecated in the future.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
  \hlkwd{stat_smooth}\hlstd{(}\hlkwc{method} \hlstd{=} \hlstr{"lm"}\hlstd{,} \hlkwc{formula} \hlstd{= y} \hlopt{~} \hlstd{x)} \hlopt{+}
  \hlkwd{coord_flip}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-06a-ggplot-1} 

}


\end{knitrout}
\end{explainbox}

In package \ggpmisc (version $\geq$ 0.4.1), statistics related to model fitting have an \code{orientation} parameter as those from package \ggplot do, but in addition they accept formulas where $x$ is on the lhs and $y$ on the rhs, such as \code{formula = x \~{} y} providing a syntax consistent with \Rlang's model fitting functions. With two calls to \ggstat{stat\_poly\_line()}, the first using the default \code{formula = y \~{} x}, and the second using \code{formula = x \~{} y} to force the flipping of the fitted model, the plot produced contains two fitted lines per panel, with the flipped ones highlighted as red lines and yellow bands.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
    \hlkwd{stat_poly_line}\hlstd{()} \hlopt{+}
    \hlkwd{stat_poly_line}\hlstd{(}\hlkwc{formula} \hlstd{= x} \hlopt{~} \hlstd{y,} \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlstr{"yellow"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-07-ggpmisc-1} 

}


\end{knitrout}

In\index{plots!major axis regression}\label{par:ma:example} the case of the \code{iris} data used for these examples, both approaches used above to linear regression are wrong. In this case, the correct approach is to not assume that there is a variable that can be considered independent and another dependent on it, but instead to use a method like major axis (MA) regression, as below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{stat_ma_line}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-flipping-08-ggpmisc-1} 

}


\end{knitrout}

%A related problem is when we need to summarise in the same plot layer $x$ and $y$ values. A simple example is adding a point with coordinates given by the means along the $x$ and $y$ axes as we need to pass these computed means simultaneously to \gggeom{geom\_point()}. Package \ggplot provides \ggstat{stat\_density\_2d()} and \ggstat{stat\_summary\_2d()}. However, \ggstat{stat\_summary\_2d()} uses bins, and is similar to \ggstat{stat\_density\_2d()} in how the computed values are returned. Package \pkgname{ggpmisc} provides two dimensional equivalents of \ggstat{stat\_summary()}: \ggstat{stat\_centroid()}, which applies the same summary function along $x$ and $y$, and \ggstat{stat\_summary\_xy()}, which accepts one function for $x$ and one for $y$.
%
%<<flipping-09-ggpmisc>>=
%ggplot(data = iris,
%       mapping = aes(x = Sepal.Length, y = Petal.Length)) +
%    geom_point() +
%    stat_centroid(colour = "red") +
%    facet_wrap(~Species, scales = "free")
%@
%
%<<flipping-10-ggpmisc>>=
%ggplot(data = iris,
%       mapping = aes(x = Sepal.Length, y = Petal.Length)) +
%    geom_point() +
%    stat_centroid(geom = "rug", sides = "trbl",
%                  colour = "red", linewidth = 1.5) +
%    facet_wrap(~Species, scales = "free")
%@
%
%\begin{playground}
%Which of the plots in the last two chunks above can be created by adding two layers with \ggstat{stat\_summary()}? Recreate this plot using \ggstat{stat\_summary()}.
%\end{playground}
%
\index{grammar of graphics!flipped axes|)}



\section{Facets}\label{sec:plot:facets}
\index{grammar of graphics!facets|(}
\index{plots!trellis-like}\index{plots!coordinated panels}
\Kern{-1}{Facets are used in a special kind of plots containing multiple panels in which the panels share some properties. These sets of coordinated panels are a useful tool for visualising complex data. These plots became popular through the \code{trellis} graphs in \langname{S}, and the \pkgname{lattice} package in \Rlang. The basic idea is to have rows and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similar-looking plots, but with free scales or with the same scale but a `floating' intercept, are sometimes also useful. In \ggplot, there are two possible types of facets: facets organised in a grid and facets along a single `axis' of variation but, possibly, wrapped into two or more rows. These are produced by adding \Rfunction{facet\_grid()} or \Rfunction{facet\_wrap()}, respectively. Below, \gggeom{geom\_point()} is used in the examples, but faceting can be used with plots containing layers created with any \code{geom} or \code{stat}.}



A single-panel plot, saved as \code{p.base}, will be used through this section to demonstrate how the same plot changes when facets are added.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= wt,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{p.base}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-facets-00-1} 

}


\end{knitrout}

A grid of panels has two dimensions, \code{rows} and \code{cols}. These dimensions in the grid of plot panels can be ``mapped'' to factors. Until recently, a formula-based syntax was the only available one. Although this notation has been retained, the preferred syntax is currently to use the parameters \code{rows} and \code{cols}. The argument passed to \code{cols} in this example is factor \code{cyl} retrieved from \code{data} with a call to \code{vars()}. The ``headings'' of the panels or \emph are by default the names or labels of the levels of the factor.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_grid}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlkwd{vars}\hlstd{(cyl))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-facets-01-1} 

}


\end{knitrout}

Using \Rfunction{facet\_wrap()} the same plot can be coded as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlkwc{facets} \hlstd{=} \hlkwd{vars}\hlstd{(cyl),} \hlkwc{nrow} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

By default, all panels share the same scale limits and share the plotting space evenly, but these defaults can be overridden.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlkwc{facets} \hlstd{=} \hlkwd{vars}\hlstd{(cyl),} \hlkwc{nrow} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{scales} \hlstd{=} \hlstr{"free_y"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-facets-02a-1} 

}


\end{knitrout}



Margins, added with \code{margins = TRUE}, display an additional column or row of panels with the combined data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_grid}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlkwd{vars}\hlstd{(cyl),} \hlkwc{margins} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-facets-06-1} 

}


\end{knitrout}



To obtain a 2D grid both \code{rows} and \code{cols} have to be passed factors as arguments.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_grid}\hlstd{(}\hlkwc{rows} \hlstd{=} \hlkwd{vars}\hlstd{(vs),} \hlkwc{cols} \hlstd{=} \hlkwd{vars}\hlstd{(am),} \hlkwc{labeller} \hlstd{= label_both)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-facets-05-1} 

}


\end{knitrout}



Each faceting dimension can be mapped to more than one factor as below. As the levels are not self-explanatory, \code{label\_both} is passed as argument to \code{labeller} so that factor names are included in the \emph{strip labels} together with the levels.\qRfunction{label\_both()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_grid}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlkwd{vars}\hlstd{(vs, am),} \hlkwc{labeller} \hlstd{= label_both)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-facets-07-1} 

}


\end{knitrout}

When facetting generates many panels, wrapping them into several rows helps keep the shape of the whole plot manageable. In this example, the number of levels is small, and no wrapping takes place by default. In cases when more panels are present, wrapping into two or more continuation rows is the default. Here, we force wrapping with \code{nrow = 2}. When using \Rfunction{facet\_wrap()} there is only one dimension, and the parameter is called \code{facets}, instead of \code{rows} or \code{cols}.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{facet_wrap}\hlstd{(}\hlkwc{facets} \hlstd{=} \hlkwd{vars}\hlstd{(cyl),} \hlkwc{nrow} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-facets-13-1} 

}


\end{knitrout}



\begin{explainbox}
By default, panel headings display the names of the levels of the factor they are based on. Changing these names is one way of changing the labels. This approach can be used to add mathematical expressions or Greek letters in the panel headings. Below, first factor labels in the data frame passed as argument to \code{data} are set to strings that can be parsed into \emph{plotmath} expressions. Then, in the call to \Rfunction{facet\_grid()}, or to \Rfunction{facet\_wrap()}, we pass as argument to \code{labeller} a function definition, \code{label\_parsed}.\qRfunction{label\_parsed()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{mtcars}\hlopt{$}\hlstd{cyl12} \hlkwb{<-} \hlkwd{factor}\hlstd{(mtcars}\hlopt{$}\hlstd{cyl,}
                       \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"alpha"}\hlstd{,} \hlstr{"beta"}\hlstd{,} \hlstr{"sqrt(x, y)"}\hlstd{))}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(mpg, wt))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlkwd{vars}\hlstd{(cyl12),} \hlkwc{labeller} \hlstd{= label_parsed)}
\end{alltt}
\end{kframe}
\end{knitrout}

The labels of the levels of the factor used in faceting can be combined with text, or math, using a ``template''. Passing as argument to \code{labeller} function \Rfunction{label\_bquote()} and using a plotmath expression as argument for its parameter \code{cols}, makes this possible. In the expression used below, \code{.(cyl)} is substituted by the value of \code{cyl} when the plot is rendered---we use here the name of the variable in the data, \code{cyl}. See section \ref{sec:plot:plotmath} for an example of the use of \code{bquote()}, the \Rlang function based on which \Rfunction{label\_bquote()} is built.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
  \hlkwd{facet_grid}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlkwd{vars}\hlstd{(cyl),}
             \hlkwc{labeller} \hlstd{=} \hlkwd{label_bquote}\hlstd{(}\hlkwc{cols} \hlstd{=} \hlkwd{.}\hlstd{(cyl)}\hlopt{~}\hlstr{"cylinders"}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-facets-12-1} 

}


\end{knitrout}
\end{explainbox}

\index{grammar of graphics!facets|)}

\section{Positions}\label{sec:plot:positions}



Position functions are passed as arguments to the \code{position} parameter of \code{geoms}. They displace the positions (the values mapped to \code{x} and/or \code{y} aesthetics) away from their original position. Different position functions differ in what displacement is applied. Table \ref{tab:plots:position} lists most of the position functions available. Function \ggposition{position\_stack()} and \ggposition{position\_fill()} were already described on page \pageref{par:plot:pos:stack}, with stacked column and area plots. Function \ggposition{position\_dodge()} was used in plots with side-by-side columns on page \pageref{par:plot:pos:dodge} and \ggposition{position\_jitter()} was used in dot plot examples on page \pageref{par:plot:pos:jitter}.

\begin{table}
  \caption[Positions]{Position functions from packages \ggplot and \ggpp. The table is divided into two sections. A. Positions that only return the modified $x$ and $y$ values. B. Identical positions that additionally return a copy of the unmodified $x$ and $y$ values. The last column describes the type of displacement: fixed uses constant values supplied in the call; random, uses random values for the displacement, within a maximum distance set by the user.}\vspace{1ex}\label{tab:plots:position}
  \centering
  \noindent
  \begin{tabular}{@{}llp{6.25cm}l@{}}
     \toprule
     Position & Package & Parameters & Displ. \\
     \midrule
     A. \textit{Origin not kept} & & & \\ \addlinespace
     \code{position\_identity} & \ggplot & --- & none \\
     \code{position\_stack} & \ggplot & vjust, reverse & fixed \\
     \code{position\_fill} & \ggplot & vjust, reverse & fixed \\
     \code{position\_dodge} & \ggplot & width, preserve, padding, reverse & fixed \\
     \code{position\_dodge2} & \ggplot & width, preserve, padding, reverse  & fixed \\
     \code{position\_jitter} & \ggplot & width, height, seed & rand. \\
     \code{position\_nudge} & \ggplot & x, y & fixed \\
     \midrule
     B. \textit{Origin kept} & & & \\ \addlinespace
     \code{position\_stack\_keep} & \ggpp & vjust, reverse & fixed \\
     \code{position\_fill\_keep} & \ggpp & vjust, reverse & fixed \\
     \code{position\_dodge\_keep} & \ggpp & width, preserve, padding, reverse & fixed \\
     \code{position\_dodge2\_keep} & \ggpp & width, preserve, padding, reverse & fixed \\
     \code{position\_jitter\_keep} &  \ggpp & width, height, seed & rand. \\
     \code{position\_nudge\_keep} & \ggpp & x, y & fixed \\
%     \midrule
%     C. \textit{Computed and kept} & & & \\ \addlinespace
%     \code{position\_nudge\_to} & \ggpp & \raggedright x, y, x.action, y.action, kept.origin & comp. \\
%     \code{position\_nudge\_line} & \ggpp & \raggedright x, y, xy\_relative, abline, method, formula, direction, line\_nudge, kept.origin & comp. \\
%     \code{position\_nudge\_center} & \ggpp & \raggedright x, y, center\_x, center\_y, direction, obey\_grouping, kept.origin & comp. \\
%     \midrule
%     D. \textit{Combined and kept} & & & \\ \addlinespace
%     \code{position\_stacknudge} & \ggpp & \raggedright vjust, reverse, x, y, direction, kept.origin & fixed \\
%     \code{position\_fillnudge} & \ggpp & \raggedright vjust, reverse, x, y, direction, kept.origin & fixed \\
%     \code{position\_dodgenudge} & \ggpp & \raggedright width, preserve, x, y, direction, kept.origin & fixed \\
%     \code{position\_dodge2nudge} & \ggpp & \raggedright width, preserve, x, y, direction, kept.origin & fixed \\
%     \code{position\_jitternudge} & \ggpp & \raggedright width, height, seed, x, y, direction, nudge.from, kept.origin & mix. \\
     \bottomrule
   \end{tabular}
\end{table}

The difference between \ggposition{position\_stack()} and \ggposition{position\_fill()} is illustrated by the example below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Orange,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= age,} \hlkwc{y} \hlstd{= circumference,} \hlkwc{fill} \hlstd{= Tree))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_area}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"stack"}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"white"}\hlstd{,} \hlkwc{linewidth} \hlstd{=} \hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{ggtitle}\hlstd{(}\hlstr{"stack"}\hlstd{)}
\hlstd{p2} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{geom_area}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"fill"}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"white"}\hlstd{,} \hlkwc{linewidth} \hlstd{=} \hlnum{1}\hlstd{)} \hlopt{+}
  \hlkwd{ggtitle}\hlstd{(}\hlstr{"fill"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-position-03-1} 

}


\end{knitrout}

Position \ggposition{position\_nudge()} is used to consistently displace positions, and is most frequently used with \gggeom{geom\_text()} and \gggeom{geom\_label()} when adding data labels. When position functions are used to add data labels, it is common to add a segment linking the data point to the label. For this to be possible, position functions have to keep the original position. Position functions from package \ggplot discard them while the position functions from packages \ggpp and \ggrepel keep them in data under a different name. Table \ref{tab:plots:position} is divided into sections. The only difference between the position functions in the two sections of the table is in whether the original position is kept or not, i.e., those from package \ggpp are backwards compatible with those from package \ggplot.

The displacement introduced by jitter and nudge differ in that jitter is random, and nudge deterministic. In each case, the displacement can be separately adjusted vertically and horizontally. Jitter, as shown above, is useful when we desire to make visible overlapping points. Nudge is most frequently used with data labels to avoid occluding points or other graphical features.

Layer function \gggeom{geom\_point\_s()} from package \pkgname{ggpp} is used below to make the displacement visible by drawing an arrow connecting original and displaced positions for each observation. We need to use the \code{\_keep} flavour of the position functions for arrows to be drawn.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(cyl),} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"blue"}\hlstd{)}
\hlstd{p3} \hlkwb{<-} \hlstd{p.base} \hlopt{+}
  \hlkwd{geom_point_s}\hlstd{(}\hlkwc{position} \hlstd{=} \hlkwd{position_jitter_keep}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{0.35}\hlstd{,} \hlkwc{heigh} \hlstd{=} \hlnum{0.6}\hlstd{),}
               \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{ggtitle}\hlstd{(}\hlstr{"jitter"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

The amount of nudging is set by a distance expressed in data units through parameters \code{x} and \code{y}. (Factors have mode \code{numeric} and each level is represented by an integer, thus distance between levels of a factor is 1.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p4} \hlkwb{<-} \hlstd{p.base} \hlopt{+}
  \hlkwd{geom_point_s}\hlstd{(}\hlkwc{position} \hlstd{=} \hlkwd{position_nudge_keep}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{0.25}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{1}\hlstd{),}
               \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{)} \hlopt{+}
  \hlkwd{ggtitle}\hlstd{(}\hlstr{"nudge"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlstd{p4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-position-06-1} 

}


\end{knitrout}



\section{Scales}\label{sec:plot:scales}
\index{grammar of graphics!scales|(}

In earlier sections of this chapter, most examples have used the default \emph{scales}. In this section, I describe in more detail the use of \emph{scales}. There are \emph{scales} available for all the different \emph{aesthetics} recognised by \code{geoms}, such as position aesthetics (\code{x, y, z}), \code{size}, \code{shape}, \code{linewidth}, \code{linetype}, \code{colour}, \code{fill}, \code{alpha} or transparency, and \code{angle}. Scales determine how values in \code{data} are mapped to values of an \emph{aesthetics}, and optionally, also how these values are labelled.

Depending on the characteristics of the variables in \code{data} being mapped, \emph{scales} can be continuous or discrete, for \code{numeric} or \code{factor} variables in \code{data}, respectively. Some \emph{aesthetics}, like \code{size} and \code{colour}, are inherently continuous but others like \code{linetype} and \code{shape} are inherently discrete. In the case of inherently continuous aesthetics, both discrete and continuous scales are available, while, obviously for those inherently discrete only discrete scales are available.

The scales used by default have default mappings of data values to aesthetic values (e.g., which colour value corresponds to $cyl = 4$ and which one to $cyl = 8$). For each \emph{aesthetic}, such as \code{colour}, there are multiple scales to choose from when creating a plot, both continuous and discrete (e.g., 20 different colour scales in \ggplot 3.4.3). In addition, some scales implement multiple palettes.

\begin{warningbox}
As seen in previous sections, \emph{aesthetics} in a plot layer, in addition to being determined by mappings, can also be set to constant values. Aesthetics set to constant values are not mapped to data and are consequently independent of scales.
\end{warningbox}

The most direct mapping to data is \code{identity}, with the values in the mapped variable directly interpreted as aesthetic values. In a colour scale, say \ggscale{scale\_colour\_identity()}, the variable in the data would be encoded with values such as \code{"red"}, \code{"blue"}---i.e., valid \Rlang colours. In a simple mapping using \ggscale{scale\_colour\_discrete()} levels of a factor, such as \code{"treatment"} and \code{"control"} would be represented as distinct colours with the correspondence between factor levels and individual colours set automatically. In contrast with \code{scale\_colour\_manual()} the user explicitly provides the mapping between factor levels and colours by passing arguments to the scale functions' parameters \code{breaks} and \code{values}.

The details of the mapping of a continuous variable to an \emph{aesthetic} are controlled with a continuous scale such as \code{scale\_colour\_continuous()}. In this case, values in a \code{numeric} variable will be mapped into a continuous range of colours. How the correspondence between numeric values and colours is controlled can vary among scales. In the case of \code{colour}, some scales use complex palettes, while others implement simple gradients between two or three colours.

\begin{explainbox}
In some scales, missing values, or \code{NA}, can be assigned an aesthetic value, such as \code{colour}, while in other cases \code{NA} values are always skipped instead of plotted. The reverse, mapping values in data to \code{NA} as aesthetic value is in some cases also possible.
\end{explainbox}

\subsection{Axis and key labels}\label{sec:plot:scale:name}\label{sec:plot:labs}
\index{plots!labels|(}
\index{plots!title|(}
\index{plots!subtitle|(}
\index{plots!tag|(}
\index{plots!caption|(}
First I describe a feature common to all scales, their \code{name}. The default \code{name} of all scales is the name of the variable or the expression mapped to it. In the case of the \code{x}, \code{y}, and \code{z} \emph{aesthetics}, the \code{name} given to the scale is used for the axis labels. For other \emph{aesthetics} the name of the scale becomes the ``heading'' or \emph{key title} of the guide or key. All scales have a \code{name} parameter to which a character string or an \Rlang expression (see section \ref{sec:plot:plotmath}) can be passed as an argument to override the default. In scales that add a key or guide, passing \code{guide = "none"} to the scale function removes the key corresponding to the scale.

Convenience functions \Rfunction{xlab()} and \Rfunction{ylab()} can be used to set the axis labels.
Convenience function \Rfunction{labs()} can be used to manually set axis labels, key/guide titles, and title and other labels for the plot as a whole. For the names of scales, \Rfunction{labs()} accepts the names of aesthetics as if they were formal parameters and using \code{title}, \code{subtitle}, \code{caption}, \code{tag}, and \code{alt} for the labels for the plot as a whole. The text passed to \code{alt} is not visible in the plot but is expected to be made available to web browsers and used to enhance accessibility. (The size of title and subtitle can seem too big when rendering figures at a small size, see section \ref{sec:plot:themes} on page \pageref{sec:plot:themes} on how to replace and modify the theme used.)

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Orange,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= age,} \hlkwc{y} \hlstd{= circumference,} \hlkwc{colour} \hlstd{= Tree))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlstr{"Growth of orange trees"}\hlstd{,}
       \hlkwc{subtitle} \hlstd{=} \hlstr{"Starting from 1968-12-31"}\hlstd{,}
       \hlkwc{caption} \hlstd{=} \hlstr{"see Draper, N. R. and Smith, H. (1998)"}\hlstd{,}
       \hlkwc{tag} \hlstd{=} \hlstr{"A"}\hlstd{,}
       \hlkwc{alt} \hlstd{=} \hlstr{"A data plot"}\hlstd{,}
       \hlkwc{x} \hlstd{=} \hlstr{"Time (d)"}\hlstd{,}
       \hlkwc{y} \hlstd{=} \hlstr{"Circumference (mm)"}\hlstd{,}
       \hlkwc{colour} \hlstd{=} \hlstr{"Tree\textbackslash{}nnumber"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-axis-labels-01-1} 

}


\end{knitrout}

When passing names directly to scales, the plot title and subtitle can be added with function \Rfunction{ggtitle()} by passing either character strings or \Rlang expressions as arguments.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Time (d)"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Circumference (mm)"}\hlstd{)} \hlopt{+}
  \hlkwd{ggtitle}\hlstd{(}\hlkwc{label} \hlstd{=} \hlstr{"Growth of orange trees"}\hlstd{,}
          \hlkwc{subtitle} \hlstd{=} \hlstr{"Starting from 1968-12-31"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-axis-labels-02-1} 

}


\end{knitrout}

\begin{playground}
Make an empty plot (\code{ggplot()}) and add to it as title an \Rlang expression producing $y = b_0 + b_1 x + b_2 x^2$. (Hint: have a look at the examples for the use of expressions in the \code{plotmath} demo in \Rlang by typing \code{demo(plotmath)} at the \Rlang console.
\end{playground}

\index{plots!tag|)}
\index{plots!caption|)}
\index{plots!subtitle|)}
\index{plots!title|)}
\index{plots!labels|)}

\subsection{Continuous scales}\label{sec:plot:scales:continuous}
\index{grammar of graphics!continuous scales|(}
I start by listing the most frequently used arguments to the continuous scale functions: \code{name}, \code{breaks}, \code{minor\_breaks}, \code{labels}, \code{limits}, \code{expand}, \code{na.value}, \code{trans}, \code{guide}, and \code{position}. The value of \code{name} is used for axis labels or the key title (see previous section). The arguments to \code{breaks} and \code{minor\_breaks} override the default locations of major and minor ticks and grid lines. Setting them to \code{NULL} suppresses the ticks. By default, the tick labels are generated from the value of \code{breaks} but an argument to \code{labels} of the same length as \code{breaks} will replace these defaults. The values of \code{limits} determine both the range of values in the data included and the plotting area as described above---by default the out-of-bounds (\code{oob}) observations are replaced by \code{NA} but it is possible to instead ``squish'' these observations towards the edge of the plotting area. The argument to \code{expand} determines the size of the margins or padding added to the area delimited by \code{lims} when setting the ``visual'' plotting area. The value passed to \code{na.value} is used as a replacement for \code{NA} valued observations---most useful for \code{colour} and \code{fill} aesthetics. The transformation object passed as an argument to \code{trans} determines the transformation used---the transformation affects the rendering, but breaks and tick labels remain expressed in the original data units. The argument to \code{guide} determines the type of key or removes the default key. Depending on the scale in question not all these parameters are available. A family of continuous scales, \emph{binned scales}, was added in \ggplot 3.3.0. These scales map a continuous variable from \code{data} onto a discrete gradient of aesthetic values, but are otherwise very similar.

The code below constructs data frame \code{fake2.data}, containing artificial data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fake2.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{20}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{5}\hlstd{),}
                   \hlkwd{rnorm}\hlstd{(}\hlnum{20}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{40}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{10}\hlstd{)),}
             \hlkwc{group} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlkwd{c}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlnum{20}\hlstd{),} \hlkwd{rep}\hlstd{(}\hlstr{"B"}\hlstd{,} \hlnum{20}\hlstd{))),}
             \hlkwc{z} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{40}\hlstd{,} \hlkwc{mean} \hlstd{=} \hlnum{12}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlnum{6}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsubsection{Limits}

Limits are relevant to all kinds of \emph{scales}. Limits are set through parameter \code{limits} of the different scale functions. They can also be set with convenience functions \code{xlim()} and \code{ylim()} in the case of the \code{x} and \code{y} \emph{aesthetics}, and more generally with function \code{lims()} which like \code{labs()}, takes arguments named according to the name of the \emph{aesthetics}. The \code{limits} argument of scales accepts vectors, factors, or a function computing them from \code{data}. In contrast, the convenience functions do not accept functions as their arguments.

In the next example, by setting ``hard'' limits, some observations are excluded from the plot, they are not seen by \code{stats} and \code{geoms}, i.e., hard limits in scales subset observations in \code{data} at the \code{start} stage (see Figure \ref{fig:ggplot:stages} on page \pageref{fig:ggplot:stages}). More precisely, the off-limits observations are converted to \code{NA} values before they are passed as \code{data} to \code{stats}, and subsequently discarded with a warning.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlstd{p1.base} \hlopt{+} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{100}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

To set only one limit leaving the other free, \code{NA} is used as a boundary.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlkwb{<-}\hlstd{p1.base} \hlopt{+} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{50}\hlstd{,} \hlnum{NA}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: Removed 37 rows containing missing values or values outside the scale range\\\#\# (`geom\_point()`).}}\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-scale-limits-02a-1} 

}


\end{knitrout}

Convenience functions \Rfunction{ylim()} and \Rfunction{xlim()} can be used to set the limits to the default $x$ and $y$ scales in use. Below, \Rfunction{ylim()} is used, but \Rfunction{xlim()} works identically except for the scale it modifies (plot identical to \code{p2} above, not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlopt{+}  \hlkwd{ylim}\hlstd{(}\hlnum{50}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

In general, setting hard limits should be avoided, even though a warning is issued about \code{NA} values being omitted, as it is easy to unwillingly subset the data being plotted.
It is preferable to use function \Rfunction{expand\_limits()} as it safely \emph{expands} the dynamically computed default limits of a scale---the scale limits will grow past the requested expanded limits when needed to accommodate all observations. The arguments to \code{x} and \code{y} are numeric vectors of length one or two each, matching how the limits of the $x$ and $y$ continuous scales are defined. Below, the limits are expanded to include the origin.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlopt{+} \hlkwd{expand_limits}\hlstd{(}\hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{x} \hlstd{=} \hlnum{0}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-scale-limits-04-1} 

}


\end{knitrout}

The \code{expand} parameter of the scales plays a different role than \Rfunction{expand\_limits()}. It adds a ``margin'' or padding around the plotting area. The actual plotting area is given by the scale limits, set either dynamically or manually. Very rarely plots are drawn so that observations are plotted on top of the axes, avoiding this is a key role of \code{expand}. Rug plots and marginal annotations can make it necessary to expand the plotting area more than the default of 5\% on each margin.

In the example below, the upper edge of the plotting area is expanded by adding 0.02 units of padding and  the expansion at the bottom set to zero.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{fill} \hlstd{= group,} \hlkwc{colour} \hlstd{= group,} \hlkwc{x} \hlstd{= y))} \hlopt{+}
  \hlkwd{stat_density}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{0.3}\hlstd{,} \hlkwc{position} \hlstd{=} \hlstr{"identity"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-}
  \hlstd{p2.base} \hlopt{+} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{expand} \hlstd{=} \hlkwd{expansion}\hlstd{(}\hlkwc{add} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.01}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}

Using multipliers has the advantage that the expansion is proportional. A similar effect as above is achieved using multipliers, 10\% compared to the range of the \code{limits} at the top and none at the bottom.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p2} \hlkwb{<-}
  \hlstd{p2.base} \hlopt{+} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{expand} \hlstd{=} \hlkwd{expansion}\hlstd{(}\hlkwc{mult} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.1}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlstd{p2}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-scale-limits-07-1} 

}


\end{knitrout}

\begin{playground}
Compare the rendered plot from \code{p2.base} to \code{p1} and \code{p2} displayed above. What has been the effect of using \Rfunction{expansion()}? Try different values as arguments for \code{add} and \code{mult}.
\end{playground}

The direction of a scale can be reversed using a transformation (see section \ref{sec:plot:scales:trans} on page \pageref{sec:plot:scales:trans}). Scales \ggscale{scale\_x\_reverse()} and \ggscale{scale\_y\_reverse()} use by default the necessary transformation. However, inconsistently, \Rfunction{xlim()} and \Rfunction{ylim()} can be used to reverse the scale direction by passing the numeric values for the limits in decreasing order.

\begin{playground}
Test what the result is when the first limit is larger than the second one. Is it the same as when setting these same values as limits with \code{ylim()}? or by replacing \code{scale\_y\_continuous()} with \code{scale\_y\_reverse()}?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1.base} \hlkwb{<-} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{100}\hlstd{,} \hlnum{0}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

\subsubsection{Breaks and their labels}\label{sec:plot:scales:ticks}

Parameter \code{breaks}\index{plots!scales!tick breaks} is used not only to set the location of ticks along the axis in scales for the \code{x} and \code{y} aesthetics, but also for the keys or guides for other continuous scales such as those for colour. Parameter \code{labels}\index{plots!scales!tick labels} is used to set the break labels, including tick labels. The argument passed to each of these parameters can be vector or a function. The default is to compute ``good'' breaks based on the limits and use to nice numbers suitable for labels. Examples in this section are for continuous scales, see section \ref{sec:plot:scales:time:date} on page \pageref{sec:plot:scales:time:date} for break labels in time and date scales.

When manually setting breaks, labels for the \code{breaks} are automatically computed unless overridden.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3.base} \hlopt{+} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{20}\hlstd{, pi} \hlopt{*} \hlnum{10}\hlstd{,} \hlnum{40}\hlstd{,} \hlnum{60}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

The default breaks are computed by function \Rfunction{pretty\_breaks()} from \pkgname{scales}. The argument passed to its parameter \code{n} determines the target number ticks to be generated automatically, but the actual number of ticks computed may be slightly different depending on the range of the data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlkwb{<-}
  \hlstd{p3.base} \hlopt{+} \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{breaks} \hlstd{=} \hlkwd{pretty_breaks}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{7}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

We can set tick labels manually, in parallel to the setting of \code{breaks} by passing as arguments two vectors of equal length. Below, an expression is used to include a Greek letter in the label.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p4} \hlkwb{<-}
  \hlstd{p3.base} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{20}\hlstd{, pi} \hlopt{*} \hlnum{10}\hlstd{,} \hlnum{40}\hlstd{,} \hlnum{60}\hlstd{),}
                     \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"20"}\hlstd{,} \hlkwd{expression}\hlstd{(}\hlnum{10}\hlopt{*}\hlstd{pi),} \hlstr{"40"}\hlstd{,} \hlstr{"60"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p3} \hlopt{+} \hlstd{p4}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-scale-ticks-02a-1} 

}


\end{knitrout}

Package \pkgname{scales} provides several functions for the automatic generation of tick labels. For example, function \code{percent()} can be used to display tick labels as percentages when the values mapped from \code{data} are expressed as decimal fractions. This ``transformation'' is applied only to the tick labels.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p5} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y} \hlopt{/} \hlkwd{max}\hlstd{(y)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{labels} \hlstd{= percent)}
\end{alltt}
\end{kframe}
\end{knitrout}

\sloppy
For currency, functions \code{dollar()} and \code{comma()} can be used to format the numbers in the labels as used for currency. Function \code{scientific\_format()} formats numbers using exponents of 10---useful for logarithmic-transformed scales. Additional functions, \code{label\_number(scale\_cut = cut\_short\_scale())}, \code{label\_log()}, or \code{label\_number(scale\_cut = cut\_si("g")} provide other options. As shown below, some of these functions can be useful with untransformed continuous scales.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p6} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y} \hlopt{*} \hlnum{1000}\hlstd{))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Mass"}\hlstd{,}
                     \hlkwc{labels} \hlstd{=} \hlkwd{label_number}\hlstd{(}\hlkwc{scale_cut} \hlstd{=} \hlkwd{cut_si}\hlstd{(}\hlstr{"g"}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p5} \hlopt{+} \hlstd{p6}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.99\textwidth]{figure/pos-scale-ticks-05-1} 

}


\end{knitrout}


\pagebreak

\begin{explainbox}
Function \Rfunction{label\_number()} and the similar functions listed above, build new functions base on the arguments passed to them, and the values they return are function definitions. Thus, in the example above, even if the statement passed as argument to \code{labels} is a function call, the value actually ``received'' by \code{scale\_y\_continuous()} is an \textit{ad hoc} function definition created on-the-fly. Some packages define additional functions that work similarly to those from package \pkgname{scales}.
\end{explainbox}

\subsubsection{Transformed scales}\label{sec:plot:scales:trans}

The\index{plots!scales!transformations} default scales used by the \code{x} and \code{y} aesthetics, \ggscale{scale\_x\_continuous()} and \ggscale{scale\_y\_continuous()}, accept a user-supplied transformation function as an argument to \code{trans} with default \code{trans = "identity"} (no transformation). Package \pkgname{scales} defines several transformations that can be used as arguments for \code{trans}. User-defined transformations can be also implemented and used. In addition, there are predefined convenience scale functions for \code{log10}, \code{sqrt} and \code{reverse}.

\begin{warningbox}
  Consistently with maths functions in \Rlang, the names of the scales are \ggscale{scale\_x\_log10()} and \ggscale{scale\_y\_log10()}, rather than \ggscale{scale\_y\_log()} because in \Rlang, function \code{log()} computes the natural logarithm.
\end{warningbox}

Axis tick-labels display the original values, not transformed ones, and the argument to \code{breaks} also refers to these. Using \ggscale{scale\_y\_log10()} a $\log_{10}$ transformation is applied to the $y$ values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{breaks}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{10}\hlstd{,}\hlnum{20}\hlstd{,}\hlnum{50}\hlstd{,}\hlnum{100}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-scale-trans-02-1} 

}


\end{knitrout}

\begin{playground}
Using a transformation in a scale is not equivalent to applying the same transformation on the fly when mapping a variable to the $x$  (or $y$) \emph{aesthetic}. How does the plot produced by the code below differ from the plot using the transformed scale, shown above?

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{=} \hlkwd{log10}\hlstd{(y)))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}
\pagebreak

For the most common transformations like \Rfunction{log10()}, scales with those transformations as their default are available. In other cases, as mentioned above, the transformation is set by passing an argument to parameter \code{trans} of continuous scale functions that by default do not apply a transformation. Below, a predefined transformation, \code{"reciprocal"} or $1/y$ is used (plot not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{trans} \hlstd{=} \hlstr{"reciprocal"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Natural logarithms are important in growth analysis as the slope against time gives the relative growth rate. The growth data for orange trees, from data set \code{Orange}, are plotted using a \Rfunction{log()} as transformation. Breaks are set using the original values.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= Orange,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= age,} \hlkwc{y} \hlstd{= circumference,} \hlkwc{colour} \hlstd{= Tree))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{()} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{trans} \hlstd{=} \hlstr{"log"}\hlstd{,} \hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{20}\hlstd{,} \hlnum{50}\hlstd{,} \hlnum{100}\hlstd{,} \hlnum{200}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scale-trans-05-1} 

}


\end{knitrout}

\begin{explainbox}
In the examples above, and in practice most frequently, transformations are applied to position aesthetics, \code{x} and \code{y}. As the grammar of graphics is consistent, most if not all continuous scales, also accept transformations. In some cases, applying a transformation to a \code{size} or \code{colour} scale helps convey the information contained in the data.
\end{explainbox}

\subsubsection{Position of $x$ and $y$ axes}
\index{plots!axis position}

The default position of axes can be changed through parameter \code{position}, using character constants \code{"bottom"}, \code{"top"}, \code{"left"} and \code{"right"}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= wt,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"top"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{position} \hlstd{=} \hlstr{"right"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-axis-position-01-1} 

}


\end{knitrout}

\subsubsection{Secondary axes}

It\index{plots!secondary axes} is also possible to add secondary axes with ticks displayed in a transformed scale.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= wt,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{sec.axis} \hlstd{=} \hlkwd{sec_axis}\hlstd{(}\hlopt{~} \hlstd{.} \hlopt{^-}\hlnum{1}\hlstd{,} \hlkwc{name} \hlstd{=} \hlstr{"gpm"}\hlstd{) )}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-axis-secondary-01-1} 

}


\end{knitrout}

It is also possible to use different \code{breaks} and \code{labels} than for the main axes, and to provide a different \code{name} to be used as a secondary axis label.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= wt,} \hlkwc{y} \hlstd{= mpg))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{sec.axis} \hlstd{=} \hlkwd{sec_axis}\hlstd{(}\hlopt{~} \hlstd{.} \hlopt{/} \hlnum{2.3521458}\hlstd{,}
                                         \hlkwc{name} \hlstd{=} \hlkwd{expression}\hlstd{(km} \hlopt{/} \hlstd{l),}
                                         \hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,} \hlnum{7.5}\hlstd{,} \hlnum{10}\hlstd{,} \hlnum{12.5}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}
\index{grammar of graphics!continuous scales|)}

\subsection{Time and date scales for $x$ and $y$}\label{sec:plot:scales:time:date}
\index{grammar of graphics!time and date scales|(}
Time scales are similar to continuous scales for \code{numeric} values. In \Rlang and many other computing languages, time values are stored as integer values subject to special interpretation (see section \ref{sec:data:datetime} on page \pageref{sec:data:datetime}). Times stored as objects of class \code{POSIXct} (or \code{POSIXlt}) can be mapped to continuous \emph{aesthetics} such as \code{x}, \code{y}, \code{colour}, etc. Special scales for different aesthetics are available for time-related data.
\pagebreak

Limits and breaks are preferably set using constant values of class \code{POSIXct}. These are most easily input with the functions in packages \pkgname{lubridate} or \pkgname{anytime} that convert dates and times from character strings.


\begin{explainbox}
In the next two chunks, scale limits subset a part of the observations present in \code{data}. Passing \code{na.rm = TRUE} when calling the \code{geom} functions silences warning messages.
\end{explainbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= weather_wk_25_2019.tb,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{with_tz}\hlstd{(time,} \hlkwc{tzone} \hlstd{=} \hlstr{"EET"}\hlstd{),}
                     \hlkwc{y} \hlstd{= air_temp_C))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{(}\hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_datetime}\hlstd{(}\hlkwc{name} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                   \hlkwc{breaks} \hlstd{=} \hlkwd{ymd_h}\hlstd{(}\hlstr{"2019-06-11 12"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"EET"}\hlstd{)} \hlopt{+} \hlkwd{days}\hlstd{(}\hlnum{0}\hlopt{:}\hlnum{1}\hlstd{),}
                   \hlkwc{limits} \hlstd{=} \hlkwd{ymd_h}\hlstd{(}\hlstr{"2019-06-11 00"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"EET"}\hlstd{)} \hlopt{+} \hlkwd{days}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2}\hlstd{)))} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Air temperature (C)"}\hlstd{)} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.9\textwidth]{figure/pos-scale-datetime-01-1} 

}


\end{knitrout}

As\index{plots!scales!axis labels} for numeric scales, breaks and the corresponding labels can be set differently to defaults. For example, if all observations have been collected within a single day, default tick labels will show hours and minutes. With several years, the labels will show only dates. The default labels are frequently good enough. Below, both breaks and the format of the labels are set through parameters passed in the call to \ggscale{scale\_x\_datetime()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= weather_wk_25_2019.tb,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{with_tz}\hlstd{(time,} \hlkwc{tzone} \hlstd{=} \hlstr{"EET"}\hlstd{),}
                     \hlkwc{y} \hlstd{= air_temp_C))} \hlopt{+}
  \hlkwd{geom_line}\hlstd{(}\hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_datetime}\hlstd{(}\hlkwc{name} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                   \hlkwc{date_breaks} \hlstd{=} \hlstr{"1 hour"}\hlstd{,}
                   \hlkwc{limits} \hlstd{=} \hlkwd{ymd_h}\hlstd{(}\hlstr{"2019-06-16 00"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"EET"}\hlstd{)} \hlopt{+} \hlkwd{hours}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{6}\hlstd{,} \hlnum{18}\hlstd{)),}
                   \hlkwc{date_labels} \hlstd{=} \hlstr{"%H:%M"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Air temperature (C)"}\hlstd{)} \hlopt{+}
  \hlkwd{expand_limits}\hlstd{(}\hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.9\textwidth]{figure/pos-scale-datetime-02-1} 

}


\end{knitrout}

\begin{playground}
The formatting strings used are those supported by \Rfunction{strptime()} and \code{help(strptime)} lists them. Change, in the two examples above, the $y$-axis labels used and the limits---e.g., include a single hour or a whole week of data, check which tick labels are produced by default and then pass as an argument to \code{date\_labels} different format strings, taking into account that in addition to the \emph{conversion specification} codes, format strings can include additional text.
\end{playground}

In \emph{date} scales tick labels are created with functions \Rfunction{label\_date()} or \Rfunction{label\_date\_short()}. In the case of \emph{time} scales, tick labels are created with function \Rfunction{label\_time()}. As shown for continuous scales, calls to these functions can passed as argument to the scales.

\index{grammar of graphics!time and date scales|)}

\subsection{Discrete scales for $x$ and $y$}
\index{grammar of graphics!discrete scales|(}

In\index{plots!scales!limits} the case of ordered or unordered factors, the tick labels are by default the names of the factor levels. Consequently, one roundabout way of obtaining the desired tick labels is to set them as factor labels in the data frame. This approach is not recommended as in many cases the text of the desired tick labels may not be a valid \Rlang name making more complex by the need to \emph{scape} these names each time they are used. It is best to use simple mnemonic short names for factor levels and variables, and to set suitable labels through scales.

Scales \ggscale{scale\_x\_discrete()} and \ggscale{scale\_y\_discrete()} can be used to reorder and select the factor levels without altering the data. When using this approach to subset the data, it is necessary to pass \code{na.rm = TRUE} in the call to layer functions to avoid warnings. Below, arguments passed to \code{limits} and \code{labels} in the call \code{scale\_x\_discrete} manually convert level names to uppercase (plot not shown, identical plot shown farther down using alternative code).


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= class,} \hlkwc{y} \hlstd{= hwy))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"col"}\hlstd{,} \hlkwc{fun} \hlstd{= mean,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_discrete}\hlstd{(}\hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"compact"}\hlstd{,} \hlstr{"subcompact"}\hlstd{,} \hlstr{"midsize"}\hlstd{),}
                   \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"COMPACT"}\hlstd{,} \hlstr{"SUBCOMPACT"}\hlstd{,} \hlstr{"MIDSIZE"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

If, as above, replacement is with the same names in upper case, passing function \Rfunction{toupper()} automates the operation. In addition, the code becomes independent of the labels used in the data. This is a more general and less error-prone approach. Any function, user defined or not, that converts the values of \code{limits} into the desired values can be passed as an argument to \code{labels}. This example, for completeness, sets scale names and limits, as well as the width of the columns.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= class,} \hlkwc{y} \hlstd{= hwy))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"col"}\hlstd{,} \hlkwc{fun} \hlstd{= mean,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{0.6}\hlstd{)} \hlopt{+}
  \hlkwd{scale_x_discrete}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Vehicle class"}\hlstd{,}
                   \hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"compact"}\hlstd{,} \hlstr{"subcompact"}\hlstd{,} \hlstr{"midsize"}\hlstd{),}
                   \hlkwc{labels} \hlstd{= toupper)} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Petrol use efficiency (mpg)"}\hlstd{,} \hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{30}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-scale-discrete-10a-1} 

}


\end{knitrout}

The order of the columns in the plot follows the order of the levels in the factor, thus changing this ordering in factor \code{mpg\$class} works. This approach makes sense when the new ordering needs to be computed based on values in \code{data}, but can still be applied in the plotting code. Below, the breaks, and together with them the columns, are ordered based on the \code{mean()} of variable \code{hwy} by means of a call to \Rfunction{reorder()} within the call to \Rfunction{aes()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{reorder}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(class),} \hlkwc{X} \hlstd{= hwy,} \hlkwc{FUN} \hlstd{= mean),}
                     \hlkwc{y} \hlstd{= hwy))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"col"}\hlstd{,} \hlkwc{fun} \hlstd{= mean)}
\end{alltt}
\end{kframe}
\end{knitrout}
\index{grammar of graphics!discrete scales|)}


\subsection{Size and line width}
\index{grammar of graphics!size scales|(}
\index{grammar of graphics!linewidth scales|(}
\begin{warningbox}
  The \code{linewidth} aesthetic was added to package \ggplot in version 3.4.0. Previously, aesthetic \code{size} described the width of lines as well as the size of text and points or shapes. Below, I describe the scales according to version 3.4.0 and more recent.
\end{warningbox}

For the \code{size} \emph{aesthetic}, several scales are available, discrete, ordinal, continuous, and binned. They are similar to those already described above. Geometries \gggeom{geom\_point()}, \gggeom{geom\_text()}, and \gggeom{geom\_label()} obey the \code{size} aesthetic as expected. Size scales can be used with continuous numeric variables, date and times, and with discrete variables. Examples of the use of \ggscale{scale\_size()} and \ggscale{scale\_size\_area()} were given in section \ref{sec:plot:geom:point} on page \pageref{sec:plot:geom:point}. Scale \ggscale{scale\_size\_radius()} is rarely used as it does not match human visual size perception.

A similar set of scales is available for \code{linewidth} as there is for \code{size}, discrete, ordinal, continuous, and binned. Geometries \gggeom{geom\_line()}, \gggeom{geom\_hline()}, \gggeom{geom\_vline()}, \gggeom{geom\_abline()}, \gggeom{geom\_segment()}, \gggeom{geom\_curve()} and related ones, obey the \code{linewidth} aesthetic. Geometry \gggeom{geom\_pointrange()} obeys both aesthetics, as expected, \code{size} is used for the size of the point and \code{linewidth} for the bar segment. In geometries \gggeom{geom\_bar()}, \gggeom{geom\_col()}, \gggeom{geom\_area()}, \gggeom{geom\_ribbon()} and all other geometric elements bordered by lines, \code{linewidth} controls the width of these lines. Like lines, these borders and segments also obey the \code{linetype} aesthetic.

\begin{warningbox}
  Using \code{linewidth} makes code incompatible with versions of \ggplot prior to 3.4.0, while continuing to use \code{size} will trigger deprecation messages in newer versions of \ggplot. Eventually, use of \code{size} for lines will become an error, so when possible, it is preferable to use the new \code{linewidth} aesthetic.
\end{warningbox}

\index{grammar of graphics!linewidth scales|)}
\index{grammar of graphics!size scales|)}

\subsection{Colour and fill}
\index{grammar of graphics!colour and fill scales|(}
\index{plots!with colours|(}

The \code{colour} and \code{fill} scales are very similar, but they affect different elements of the plot. All visual elements in a plot obey the \code{colour} \emph{aesthetic}, but only elements that have an inner region and a boundary, obey both \code{colour} and \code{fill} \emph{aesthetics}. The boundary does not need to be rendered as a line when the plot is displayed, but it must exist. This is the case for \gggeom{geom\_area()} and \gggeom{geom\_ribbon()} that in recent versions of \ggplot are displayed with lines only on some edges. Only a subset of the shapes supported by \gggeom{geom\_point()} can be filled. There are separate but equivalent sets of scales available for these two \emph{aesthetics}. I will describe in more detail the \code{colour} \emph{aesthetic} and give only some examples for \code{fill}. I will, however, start by reviewing how colours are defined and used in \Rlang.

\subsubsection{Colour definitions in \Rlang}\label{sec:plot:colours}
\index{colour!definitions|(}
Colours can be specified in \Rlang not only through character strings with the names of previously defined \code{colours}, but also directly as strings describing the RGB (red, green, and blue) components as hexadecimal numbers (on base 16 expressed using 0, 1, 2, 3, 4, 6, 7, 8, 9, A, B, C, D, E, and F as ``digits'') such as \code{"\#FFFFFF"} for white or \code{"\#000000"} for black, or \code{"\#FF0000"} for the brightest available pure red.

The list of colour names\index{colour!names} known to \Rlang can be obtained be typing \Rfunction{colors()} at the \Rlang console. Differently to package \pkgname{ggplot2}, base \Rlang supports only \code{color} as the spelling.
Given the number of colours available, subsetting them based on their names is frequently a good first step. Function \code{colors()} returns a character vector. Using \code{grep()} it is possible to find the names that contain a given character substring, in this example \code{"dark"}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{length}\hlstd{(}\hlkwd{colors}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] 657
\end{verbatim}
\begin{alltt}
\hlkwd{grep}\hlstd{(}\hlstr{"dark"}\hlstd{,}\hlkwd{colors}\hlstd{(),} \hlkwc{value} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] "darkblue"        "darkcyan"        "darkgoldenrod"   "darkgoldenrod1" 
##  [5] "darkgoldenrod2"  "darkgoldenrod3"  "darkgoldenrod4"  "darkgray"       
##  [9] "darkgreen"       "darkgrey"        "darkkhaki"       "darkmagenta"    
## [13] "darkolivegreen"  "darkolivegreen1" "darkolivegreen2" "darkolivegreen3"
## [17] "darkolivegreen4" "darkorange"      "darkorange1"     "darkorange2"    
## [21] "darkorange3"     "darkorange4"     "darkorchid"      "darkorchid1"    
## [25] "darkorchid2"     "darkorchid3"     "darkorchid4"     "darkred"        
## [29] "darksalmon"      "darkseagreen"    "darkseagreen1"   "darkseagreen2"  
## [33] "darkseagreen3"   "darkseagreen4"   "darkslateblue"   "darkslategray"  
## [37] "darkslategray1"  "darkslategray2"  "darkslategray3"  "darkslategray4" 
## [41] "darkslategrey"   "darkturquoise"   "darkviolet"
\end{verbatim}
\end{kframe}
\end{knitrout}

The RGB values for an \Rlang \code{color} definition are returned by function \Rfunction{col2rgb()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{col2rgb}\hlstd{(}\hlstr{"purple"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##       [,1]
## red    160
## green   32
## blue   240
\end{verbatim}
\begin{alltt}
\hlkwd{col2rgb}\hlstd{(}\hlstr{"#FF0000"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##       [,1]
## red    255
## green    0
## blue     0
\end{verbatim}
\end{kframe}
\end{knitrout}

Colour definitions in \Rlang can contain a \emph{transparency} component described by an \code{alpha} value, which by default is not returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{col2rgb}\hlstd{(}\hlstr{"purple"}\hlstd{,} \hlkwc{alpha} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
##       [,1]
## red    160
## green   32
## blue   240
## alpha  255
\end{verbatim}
\end{kframe}
\end{knitrout}

With function \Rfunction{rgb()} one can define new colours. Enter \code{help(rgb)} for more details.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{rgb}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{0}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "#FFFF00"
\end{verbatim}
\begin{alltt}
\hlkwd{rgb}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{0}\hlstd{,} \hlkwc{names} \hlstd{=} \hlstr{"my.color"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  my.color 
## "#FFFF00"
\end{verbatim}
\begin{alltt}
\hlkwd{rgb}\hlstd{(}\hlnum{255}\hlstd{,} \hlnum{255}\hlstd{,} \hlnum{0}\hlstd{,} \hlkwc{names} \hlstd{=} \hlstr{"my.color"}\hlstd{,} \hlkwc{maxColorValue} \hlstd{=} \hlnum{255}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  my.color 
## "#FFFF00"
\end{verbatim}
\end{kframe}
\end{knitrout}

As described above, colours can be defined in the RGB \emph{colour space}; however, other colour models such as HSV (hue, saturation, value) can be also used to define colours.\qRfunction{hsv()}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hsv}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{0.25}\hlstd{,}\hlnum{0.5}\hlstd{,}\hlnum{0.75}\hlstd{,}\hlnum{1}\hlstd{),} \hlnum{0.5}\hlstd{,} \hlnum{0.5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "#804040" "#608040" "#408080" "#604080" "#804040"
\end{verbatim}
\end{kframe}
\end{knitrout}

Frequently, sets of HSV colours returned by function \Rfunction{hcl()}, using hue, chroma and luminance as inputs, are better for use in scales. While the ``value'' and ``saturation'' in HSV are based on physical values, the ``chroma'' and ``luminance'' values in HCL are based on human visual perception. Colours with equal luminance will be seen as equally bright by an ``average'' human. In a scale based on different hues but equal chroma and luminance values, as used by default by package \ggplot, all colours are perceived as equally bright. The hues need to be expressed as angles in degrees, with values between zero and 360.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hcl}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,}\hlnum{0.25}\hlstd{,}\hlnum{0.5}\hlstd{,}\hlnum{0.75}\hlstd{,}\hlnum{1}\hlstd{)} \hlopt{*} \hlnum{360}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "#FFC5D0" "#D4D8A7" "#99E2D8" "#D5D0FC" "#FFC5D0"
\end{verbatim}
\end{kframe}
\end{knitrout}

It is also important to remember that humans can only distinguish a limited set of colours, and even smaller colour gamuts can be reproduced by screens and printers. Furthermore, variation from individual to individual exists in colour perception, including different types of colour blindness. It is important to take this into account when choosing the colours used in illustrations.
\index{colour!definitions|)}

\subsection{Continuous colour-related scales}
\sloppy
Continuous colour scales \ggscale{scale\_colour\_continuous()}, \ggscale{scale\_colour\_gradient()}, \ggscale{scale\_colour\_gradient2()},  \ggscale{scale\_colour\_gradientn()}, \ggscale{scale\_colour\_date()}, and \ggscale{scale\_colour\_datetime()}, give smooth continuous gradients between two or more colours. They are used with \code{numeric}, \code{date} and \code{datetime} data. A matching set of \code{fill} scales is also available. Other scales like \ggscale{scale\_colour\_viridis\_c()} and \ggscale{scale\_colour\_distiller()} are based on the use of ready-made palettes of sets of colour gradients chosen to work well together under multiple conditions or for human vision including different types of colour blindness.

\subsection{Discrete colour-related scales}
\sloppy
Discrete colour scales, such as \ggscale{scale\_colour\_discrete()}, \ggscale{scale\_colour\_hue()}, \ggscale{scale\_colour\_gray()}, are used with categorical data stored as factors. Some discrete scales, such as \ggscale{scale\_colour\_viridis\_d()} and \ggscale{scale\_colour\_brewer()}, provide multiple discrete sets of colours selectable through palettes. A matching set of discrete \code{fill} scales is available. Ordinal scales, such as \ggscale{scale\_colour\_ordinal()} and \ggscale{scale\_fill\_ordinal()}, use palettes that set aesthetic values that ramp in steps between two extreme values. They are used when \code{ordered} factors are mapped to the aesthetics.

\subsection{Binned scales}\label{sec:binned:scales}
\index{grammar of graphics!binned scales|(}
Before version 3.3.0 of \pkgname{ggplot2}, only two types of scales were available, continuous and discrete. A third type of scales, called \emph{binned}, (implemented for all the aesthetics where relevant) was added in version 3.3.0. They are used with continuous variables, but they convert the continuous values into discrete ones, using bins corresponding to different ranges of values, and then represent them in the plot using a discrete set of aesthetic values from a gradient. We re-do the figure shown on page \pageref{chunk:plot:weighted:resid} but replacing \ggscale{scale\_colour\_gradient()} by \ggscale{scale\_colour\_binned()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{4321}\hlstd{)}
\hlstd{X} \hlkwb{<-} \hlnum{0}\hlopt{:}\hlnum{10}
\hlstd{Y} \hlkwb{<-} \hlstd{(X} \hlopt{+} \hlstd{X}\hlopt{^}\hlnum{2} \hlopt{+} \hlstd{X}\hlopt{^}\hlnum{3}\hlstd{)} \hlopt{+} \hlkwd{rnorm}\hlstd{(}\hlkwd{length}\hlstd{(X),} \hlkwc{mean} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{sd} \hlstd{=} \hlkwd{mean}\hlstd{(X}\hlopt{^}\hlnum{3}\hlstd{)} \hlopt{/} \hlnum{4}\hlstd{)}
\hlstd{df1} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(X, Y)}
\hlstd{df2} \hlkwb{<-} \hlstd{df1}
\hlstd{df2[}\hlnum{6}\hlstd{,} \hlstr{"Y"}\hlstd{]} \hlkwb{<-}\hlstd{df1[}\hlnum{6}\hlstd{,} \hlstr{"Y"}\hlstd{]} \hlopt{*} \hlnum{10}
\end{alltt}
\end{kframe}
\end{knitrout}


\pagebreak

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= df2)} \hlopt{+}
  \hlkwd{stat_fit_residuals}\hlstd{(}\hlkwc{formula} \hlstd{= y} \hlopt{~} \hlkwd{poly}\hlstd{(x,} \hlnum{3}\hlstd{,} \hlkwc{raw} \hlstd{=} \hlnum{TRUE}\hlstd{),}
                     \hlkwc{method} \hlstd{=} \hlstr{"rlm"}\hlstd{,}
                     \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,}
                                   \hlkwc{y} \hlstd{=} \hlkwd{stage}\hlstd{(}\hlkwc{start} \hlstd{= Y,}
                                             \hlkwc{after_stat} \hlstd{= y} \hlopt{*} \hlstd{weights),}
                                   \hlkwc{colour} \hlstd{=} \hlkwd{after_stat}\hlstd{(weights)),}
                     \hlkwc{show.legend} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{scale_colour_binned}\hlstd{(}\hlkwc{low} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{high} \hlstd{=} \hlstr{"blue"}\hlstd{,} \hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{),}
                     \hlkwc{guide} \hlstd{=} \hlstr{"colourbar"}\hlstd{,} \hlkwc{n.breaks} \hlstd{=} \hlnum{5}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-binned-scales-01-1} 

}


\end{knitrout}

The advantage of binned scales is that they facilitate the fast reading of the plot while their disadvantage is the decreased resolution of the scale. The use of a binned instead of a continuous scale is qualitative. The number of bins can be set by passing an argument to parameter \code{n.breaks} or alternatively, a \code{numeric} vector passed as argument to \code{breaks} can be used to explicitly set bin boundaries. When deciding how many bins to use, one needs to take into account the audience, how the figure will be rendered and displayed, and the length of time available to the viewers to peruse the plot relative to the density of information. Transformations are also allowed in these scales as in others.

\index{grammar of graphics!binned scales|)}

\subsection{Identity scales}
\index{grammar of graphics!identity colour scales|(}
In the case of identity scales, the mapping is one to-one to the data. For example, if we map the \code{colour} or \code{fill} \emph{aesthetic} to a variable using \ggscale{scale\_colour\_identity()} or \ggscale{scale\_fill\_identity()}, the mapped variable must already contain valid \Rlang \code{color} definitions. In the case of mapping \code{alpha}, the variable must contain numeric values in the range 0 to 1.

We use a data frame containing a variable \code{colours} containing character strings interpretable as the names of \code{color} definitions known to \Rlang. We then use them directly in the plot by passing \ggscale{scale\_colour\_identity()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df3} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{X} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{Y} \hlstd{=} \hlkwd{dnorm}\hlstd{(}\hlnum{10}\hlstd{),} \hlkwc{colours} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"red"}\hlstd{,} \hlstr{"blue"}\hlstd{),} \hlnum{5}\hlstd{))}

\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= df3,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= X,} \hlkwc{y} \hlstd{= Y,} \hlkwc{colour} \hlstd{= colours))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_colour_identity}\hlstd{()}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-scale-colour-10-1} 

}


\end{knitrout}

\begin{playground}
How does the plot look, if the identity scale is deleted from the example above? Edit and re-run the example code.

While using the identity scale, how would you need to change the code example above, to produce a plot with green and purple points?
\end{playground}
\index{grammar of graphics!identity colour scales|)}

\begin{explainbox}
  \index{grammar of graphics!setting default colour and fill scales}
  The \code{colour} and \code{fill} scales used by default by geometries defined in package \pkgname{ggplot2} can be changed through \Rlang options \code{"ggplot2.continuous.colour"}, \code{"ggplot2.discrete.colour"}, \code{"ggplot2.ordinal.colour"}, \code{"ggplot2.binned.colour"}, \code{"ggplot2.continuous.fill"}, \code{"ggplot2.discrete.fill"}, \code{"ggplot2.ordinal.fill"} and \code{"ggplot2.binned.fill"}.
\end{explainbox}

\index{plots!with colours|)}
\index{grammar of graphics!colour and fill scales|)}
\index{grammar of graphics!scales|)}

\section{Adding Annotations}\label{sec:plot:annotations}
\index{grammar of graphics!annotations|(}
The idea of annotations is that they add plot elements that are not directly connected individual observations in \code{data}. Some like company logos, could be called ``decorations'', but others like text indicating the number of observations or even an inset plot or table may convey information about the data set as a whole. They can be drawn referenced to the ``native'' data coordinates used to plot but the position itself does convey information. Annotations are distinct from data labels. Annotations are added to a ggplot with function \Rfunction{annotate()} as plot layers (each call to \code{annotate()} creates a new layer). To achieve the behaviour expected of annotations, \Rfunction{annotate()} does not inherit the default \code{data} or \code{mapping} of variables to \emph{aesthetics}. Annotations frequently make use of \code{"text"} or \code{"label"} \emph{geometries} with character strings as data, possibly to be parsed as expressions. In addition, for example, the \code{"segment"} geometry can be used to add arrows.

\begin{warningbox}
While layers added to a plot using \emph{geometries} and \emph{statistics} respect faceting, layers added with \Rfunction{annotate()} are replicated unchanged in all panels of a faceted plot. The reason is that annotation layers accept \emph{aesthetics} only as constant values which are the same for every panel as no grouping is possible without a \code{mapping} to \code{data}. Alternatives, using new geometries, are provided by package \ggpp.
\end{warningbox}

Function \Rfunction{annotate()} takes the name of a geometry as its argument, in the example below, \code{"text"}. Function \Rfunction{aes()} is not used, as only mappings to constant values are accepted. These values can be vectors, thus, layers added with annotate can add multiple graphic objects of the same type to a plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"text"}\hlstd{,}
           \hlkwc{label} \hlstd{=} \hlstr{"origin"}\hlstd{,}
           \hlkwc{x} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,}
           \hlkwc{colour} \hlstd{=} \hlstr{"blue"}\hlstd{,}
           \hlkwc{size}\hlstd{=}\hlnum{4}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-annotate-01-1} 

}


\end{knitrout}

\begin{playground}
Play with the values of the arguments to \Rfunction{annotate()} to vary the position, size, colour, font family, font face, rotation angle, and justification of the annotation.
\end{playground}

\index{plots!insets as annotations|(}
It is relatively common to use inset tables, plots, bitmaps, or vector graphics as annotations. In section \ref{sec:plot:insets} on page \pageref{sec:plot:insets}, \code{geoms} from package \ggpp were used to create insets in plots. An older alternative is to use \Rfunction{annotation\_custom()} to add grobs (\pkgname{grid} graphical object) to a ggplot. To add another or the same plot as an inset, it first needs to be converted it into a grob. A ggplot can be converted with function \Rfunction{ggplotGrob()}. In this example, the inset is a zoomed-in window into the main plot. In addition to the grob, coordinates for its location are passed in native data units.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlstd{p} \hlopt{+} \hlkwd{expand_limits}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{40}\hlstd{)} \hlopt{+}
  \hlkwd{annotation_custom}\hlstd{(}\hlkwd{ggplotGrob}\hlstd{(p} \hlopt{+} \hlkwd{coord_cartesian}\hlstd{(}\hlkwc{xlim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,} \hlnum{10}\hlstd{),} \hlkwc{ylim} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{20}\hlstd{,} \hlnum{40}\hlstd{))} \hlopt{+}
                               \hlkwd{theme_bw}\hlstd{(}\hlnum{10}\hlstd{)),}
                    \hlkwc{xmin} \hlstd{=} \hlnum{21}\hlstd{,} \hlkwc{xmax} \hlstd{=} \hlnum{40}\hlstd{,} \hlkwc{ymin} \hlstd{=} \hlnum{30}\hlstd{,} \hlkwc{ymax} \hlstd{=} \hlnum{60}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-inset-01-1} 

}


\end{knitrout}

This approach has the limitation, shared with the use of \Rfunction{annotate()}, that if used together with faceting, the inset is added identically to all plot panels.
\index{plots!insets as annotations|)}

In the next code example, expressions are used as annotations as well as for tick labels. Do notice that we use recycling and vectorised arithmetic for setting the breaks, as \code{c(0, 0.5, 1, 1.5, 2) * pi} is equivalent to \code{c(0, 0.5 * pi, pi, 1.5 * pi, 2 * pi}. Annotations are plotted at their own position, unrelated to any observation in the data, but using the same coordinates and units as for plotting the data.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{=} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{2} \hlopt{*} \hlstd{pi)),}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{= sin)} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}
    \hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0.5}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1.5}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,}
    \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"0"}\hlstd{,} \hlkwd{expression}\hlstd{(}\hlnum{0.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(pi),}
             \hlkwd{expression}\hlstd{(}\hlnum{1.5}\hlopt{~}\hlstd{pi),} \hlkwd{expression}\hlstd{(}\hlnum{2}\hlopt{~}\hlstd{pi)))} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{=} \hlstr{"sin(x)"}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"text"}\hlstd{,}
           \hlkwc{label} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"+"}\hlstd{,} \hlstr{"-"}\hlstd{),}
           \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlnum{1.5}\hlstd{)} \hlopt{*} \hlstd{pi,} \hlkwc{y} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlopt{-}\hlnum{0.5}\hlstd{),}
           \hlkwc{size} \hlstd{=} \hlnum{20}\hlstd{)} \hlopt{+}
  \hlkwd{annotate}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"point"}\hlstd{,}
           \hlkwc{colour} \hlstd{=} \hlstr{"red"}\hlstd{,}
           \hlkwc{shape} \hlstd{=} \hlnum{21}\hlstd{,}
           \hlkwc{fill} \hlstd{=} \hlstr{"white"}\hlstd{,}
           \hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{2}\hlstd{)} \hlopt{*} \hlstd{pi,} \hlkwc{y} \hlstd{=} \hlnum{0}\hlstd{,}
           \hlkwc{size} \hlstd{=} \hlnum{6}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-annotate-03-1} 

}


\end{knitrout}

\begin{playground}
Modify the plot above to show the cosine instead of the sine function, replacing \code{sin} with \code{cos}. This is easy, but the catch is that you will need to relocate the annotations.
\end{playground}

\begin{warningbox}
Function \Rfunction{annotate()} cannot be used with \code{geom = "vline"} or \code{geom = "hline"} as we can use \code{geom = "line"} or \code{geom = "segment"}. Instead, \gggeom{geom\_vline()} and/or  \gggeom{geom\_hline()} can be used directly passing constant arguments to them. See section \ref{sec:plot:line} on page \pageref{sec:plot:vhline}.
\end{warningbox}
\index{grammar of graphics!annotations|)}

\section{Coordinates and Circular Plots}\label{sec:plot:circular}\label{sec:plot:coord}
\index{grammar of graphics!polar coordinates|(}
\index{plots!circular|(}
The grammar of graphics, as implemented in \ggplot, allows many different combinations of its ``words'', and this is also how circular plots are created. To obtain circular plots, we use the same \emph{geometries}, \emph{statistics}, and \emph{scales} we have been using above, but combined with polar coordinates instead of the default cartesian coordinates. We override the default by adding \ggcoordinate{coord\_polar()} to the plot so that the \code{x} and \code{y} \textit{aesthetics} correspond to the angle and radial distance, respectively. 

Special systems of coordinates, such as \ggcoordinate{coord\_sf()}, used for maps, support different projections. In contrast, coordinate functions such as \ggcoordinate{coord\_flip()}, \ggcoordinate{coord\_trans()}, and \ggcoordinate{coord\_fixed()} offer variations based on the cartesian system.

\subsection{Wind-rose plots}
\index{plots!wind rose|(}
Some types of data are more naturally expressed as angles using polar coordinates than on cartesian coordinates. The clearest example is wind direction, from which the name \textit{wind-rose} derives. In some cases of time series data with a strong periodic variation, polar coordinates can be used to highlight phase shifts or changes in frequency. A more mundane application is to plot variation in a response variable through the day with a clock-face-like representation of time of day.

Wind rose plots are frequently histograms drawn on a polar system of coordinates (see section \ref{sec:plot:histogram} on page \pageref{sec:plot:histogram}). In the examples, we plot wind direction data, measured once per minute during 24~h (dataset \code{viikki\_d29.dat} from package \pkgname{learnrbook}).

A circular histogram of wind directions with 30-degree-wide bins can be created using \ggstat{stat\_bin()}. The counts represent the number of minutes during 24~h when the wind direction was within each bin, as the data set contains one observation per minute.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.wind} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= viikki_d29.dat,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= WindDir_D1_WVT))}  \hlopt{+}
  \hlkwd{stat_bin}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlstr{"gray50"}\hlstd{,} \hlkwc{geom} \hlstd{=} \hlstr{"bar"}\hlstd{,}
           \hlkwc{binwidth} \hlstd{=} \hlnum{30}\hlstd{,} \hlkwc{boundary} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
  \hlkwd{coord_polar}\hlstd{()} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{90}\hlstd{,} \hlnum{180}\hlstd{,} \hlnum{270}\hlstd{),}
                     \hlkwc{labels} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"N"}\hlstd{,} \hlstr{"E"}\hlstd{,} \hlstr{"S"}\hlstd{,} \hlstr{"W"}\hlstd{),}
                     \hlkwc{limits} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{360}\hlstd{),}
                     \hlkwc{expand} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{0}\hlstd{),}
                     \hlkwc{name} \hlstd{=} \hlstr{"Wind direction"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_y_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlstr{"Frequency (min/d)"}\hlstd{)}
\hlstd{p.wind}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-wind-05-1} 

}


\end{knitrout}

\begin{playground}
  In the example above, \gggeom{geom\_bar()} was used. Edit the code to use other geometries, e.g., \code{geom\_line()} and \code{geom\_area()}.
\end{playground}

\begin{warningbox}
A plot created using polar coordinates is not truly circular, but resembles a plot based on cartesian coordinates rolled into a circle. The difference is crucial in the case of some wind-rose plots. In a true circular plot, the data would have to be projected onto a cylinder without any discontinuity. The plot we obtain using \ggcoordinate{coord\_polar()} retains a discontinuity at the North, at the boundary between 0 and 360 degrees. Thus for a histogram computed with \ggstat{stat\_bin()}, one boundary between bins must normally coincide with this divide. In a density plot, the densities on both sides of the North divide are fitted separately, frequently resulting in odd looking plots.

One approach to centring the bins on the cardinal directions would be to pre-compute the frequencies before plotting, pooling the observations for the slices 345--360 and 0--15 degrees into the same bin, and in a separate step, plotting them using \gggeom{geom\_col()} (not shown).
\end{warningbox}



As when using other coordinates we can add facets. In this example, we create a factor based on solar time, to plot separately the observations from before or after local solar noon.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.wind} \hlopt{+}
  \hlkwd{facet_wrap}\hlstd{(}\hlopt{~}\hlkwd{factor}\hlstd{(}\hlkwd{ifelse}\hlstd{(}\hlkwd{hour}\hlstd{(solar_time)} \hlopt{<} \hlnum{12}\hlstd{,} \hlstr{"AM"}\hlstd{,} \hlstr{"PM"}\hlstd{)))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.9\textwidth]{figure/pos-wind-08-1} 

}


\end{knitrout}

\index{plots!wind rose|)}

\pagebreak

\subsection{Pie charts}
\index{plots!pie charts|(}

\begin{warningbox}
Pie charts are more difficult to read than bar charts because our brain is better at comparing lengths than angles. If used, pie charts should only be used to show composition, or fractional components that add up to a total. In this case, used only if the number of “pie slices” is small (rule of thumb: seven at most), however in general, they are best avoided.
\end{warningbox}

A pie chart of counts is like a bar plot in which instead of heights angles describe the number of counts. \gggeom{geom\_bar()}, which defaults to use \code{stat\_count()}, together with \ggcoordinate{coord\_polar()} creates a pie chart. The brewer gradient scale supplies the palette for the fills, while the colour of the border line is set with \code{colour = "black")}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mpg,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{factor}\hlstd{(}\hlnum{1}\hlstd{),} \hlkwc{fill} \hlstd{=} \hlkwd{factor}\hlstd{(class)))} \hlopt{+}
  \hlkwd{geom_bar}\hlstd{(}\hlkwc{width} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{colour} \hlstd{=} \hlstr{"black"}\hlstd{)} \hlopt{+}
  \hlkwd{coord_polar}\hlstd{(}\hlkwc{theta} \hlstd{=} \hlstr{"y"}\hlstd{)} \hlopt{+}
  \hlkwd{scale_fill_brewer}\hlstd{()} \hlopt{+}
  \hlkwd{scale_x_discrete}\hlstd{(}\hlkwc{breaks} \hlstd{=} \hlkwa{NULL}\hlstd{)} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwa{NULL}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlstr{"Vehicle class"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-main-chunk-867-1} 

}


\end{knitrout}
\index{plots!pie charts|)}
\index{plots!circular|)}
\index{grammar of graphics!polar coordinates|)}

\begin{playground}
Edit the code for the pie chart above to obtain a bar chart. Which one of the two plots is easier to read?
\end{playground}

\section{Themes}\label{sec:plot:themes}
\index{grammar of graphics!themes|(}
\index{plots!styling|(}
In \ggplot, \emph{themes} are the equivalent of style sheets. They determine how the different elements of a plot are rendered when displayed, printed, or saved to a file. \emph{Themes} do not alter what aesthetics or scales are used to plot the observations or summaries, but instead how text labels, titles, axes, tick marks, plotting-area background, grid lines, etc., are formatted and if displayed or not. Package \ggplot includes several predefined \emph{theme constructors} (usually described as \emph{themes}), and independently developed extension packages define additional ones. These constructors return complete themes, which when added to a plot, replace the theme already present. In addition to choosing among these already available \emph{complete themes}, users can modify the ones already present in a plot by adding \emph{incomplete themes}. When used in this way, \emph{incomplete themes} usually are created on the fly. It is also possible to create new theme constructors that return complete themes, similar to \code{theme\_gray()} from \ggplot.

\subsection{Complete themes}
\index{grammar of graphics!complete themes|(}
The theme used by default is \ggtheme{theme\_gray()} with default arguments. In \pkgnameNI{ggplot2}, predefined themes are defined as constructor functions, with parameters. These parameters allow changing some ``base'' properties. The \code{base\_size} for text elements is given in points, and affects all text elements in the returned theme object because the size of these elements is by default defined relative to the base size. Another parameter, \code{base\_family}, allows the font family to be set. These functions return complete themes.

\begin{warningbox}
\emph{Themes} have no effect on layers produced by \emph{geometries} as themes have no effect on \emph{mappings}, \emph{scales}, or \emph{aesthetics}. In the name \ggtheme{theme\_bw()} black-and-white refers to the colour of the background of the plotting area and labels. If the \emph{colour} or fill \emph{aesthetics} are mapped or set to a constant in the figure, these will be respected irrespective of the theme. One cannot convert a colour figure into a black-and-white one by adding a \emph{theme}. For colour gradients an alternative is to use a greyscale gradient by changing the \emph{scale} used to map values to aesthetics. For discrete scales, a different aesthetic can be used, for example, use \code{shape} or \code{linetype} instead of \code{colour}.
\end{warningbox}

Even the default \ggtheme{theme\_gray()} can be added to a plot, to replace the default one with a newly constructed one created with arguments different to the defaults ones. Below, a serif font at a larger size than the default is used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{theme_gray}\hlstd{(}\hlkwc{base_size} \hlstd{=} \hlnum{18}\hlstd{,}
             \hlkwc{base_family} \hlstd{=} \hlstr{"serif"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-themes-01-1} 

}


\end{knitrout}

\begin{playground}
Change the code in the previous chunk to use, one at a time, each of the predefined themes from \ggplot: \ggtheme{theme\_bw()}, \ggtheme{theme\_classic()}, \ggtheme{theme\_minimal()}, \ggtheme{theme\_linedraw()}, \ggtheme{theme\_light()}, \ggtheme{theme\_dark()} and \ggtheme{theme\_void()}.
\end{playground}

\begin{explainbox}
Predefined ``themes'' like \ggtheme{theme\_gray()} are, in reality, not themes but instead are constructors of theme objects. The \emph{themes} they return when called depend on the arguments passed to their parameters. In other words, \code{theme\_gray(base\_size = 15)}, creates a different theme than \code{theme\_gray(base\_size = 11)}. In this case, as sizes of different text elements are defined relative to the base size, the size of all text elements changes in coordination. Font size changes by \emph{themes} do not affect the size of text or labels in plot layers created with geometries, as their size is controlled by the \code{size} \emph{aesthetic}.
\end{explainbox}

A frequent idiom is to create a plot without specifying a theme, and then adding the theme when printing or saving it. This can save work, for example, when producing different versions of the same plot for a publication and a talk.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-}
  \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,}
         \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()}
\hlkwd{print}\hlstd{(p.base} \hlopt{+} \hlkwd{theme_bw}\hlstd{())}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-themes-03-1} 

}


\end{knitrout}

It is also possible to change the theme used by default in the current \Rlang session with \Rfunction{theme\_set()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{old_theme} \hlkwb{<-} \hlkwd{theme_set}\hlstd{(}\hlkwd{theme_bw}\hlstd{(}\hlnum{15}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Similar to other functions used to change options in \Rlang, \Rfunction{theme\_set()} returns the previous setting. By saving this value to a variable, here \code{old\_theme}, we are able to restore the previous default, or undo the change.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{theme_set}\hlstd{(old_theme)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{explainbox}
The use of a grey background as default for plots is unusual. This graphic design decision originates in typesetters' goal of maintaining a uniform average luminosity throughout the text and plots in a page. Many scientific journals require or at least prefer a more traditional graphic design. Theme \ggtheme{theme\_bw()} is the most versatile of the traditional designs supported as it works well both for individual plots as for plots with facets as it includes a box. Theme \ggtheme{theme\_classic()} lacking a box and grid works well for individual plots, but needs to be adjusted when used with facets so as to obtain nice looking plots.
\end{explainbox}
\index{grammar of graphics!complete themes|)}

\subsection{Incomplete themes}
\index{grammar of graphics!incomplete themes|(}
To create a significantly different theme, and/or reuse it in multiple plots, it is best to create a new constructor, or a modified complete theme as described in section \ref{sec:plot:theme:new} on page \pageref{sec:plot:theme:new}. In other cases, it is enough to tweak individual theme settings for a single plot. Below, overlapping $x$-axis tick labels are avoided by rotation the axis tick labels. When rotating the labels, it is also necessary to change their justification, as justification is relative to the orientation of the text.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= fake2.data,}
       \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= z} \hlopt{+} \hlnum{1000}\hlstd{,} \hlkwc{y} \hlstd{= y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{breaks} \hlstd{= scales}\hlopt{::}\hlkwd{pretty_breaks}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{8}\hlstd{))} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlnum{33}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{vjust} \hlstd{=} \hlnum{1}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-themes-11-1} 

}


\end{knitrout}

\begin{playground}
Play with the code in the last chunk above, modifying the values used for \code{angle}, \code{hjust} and \code{vjust}. (Angles are expressed in degrees, and justification with values between 0 and 1).
\end{playground}

A less elegant approach is to use a smaller font size. Within \Rfunction{theme()}, function \Rfunction{rel()} can be used to set size relative to the base size. In this example, we use \code{axis.text.x} so as to change the size of tick labels only for the $x$ axis.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(fake2.data,} \hlkwd{aes}\hlstd{(z} \hlopt{+} \hlnum{100}\hlstd{, y))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{breaks} \hlstd{= scales}\hlopt{::}\hlkwd{pretty_breaks}\hlstd{(}\hlkwc{n} \hlstd{=} \hlnum{20}\hlstd{))} \hlopt{+}
  \hlkwd{theme}\hlstd{(}\hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{size} \hlstd{=} \hlkwd{rel}\hlstd{(}\hlnum{0.6}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}

Theme definitions follow a hierarchy, allowing us to modify the formatting of groups of similar elements, as well as of individual elements. In the chunk above, using \code{axis.text} instead of \code{axis.text.x}, would have affected the tick labels in both $x$ and $y$ axes.

\begin{playground}
Modify the example above, so that the tick labels on the $x$-axis are blue and those on the $y$-axis red, and the font size is the same for both axes, but changed from the default. Consult the documentation for \code{theme()} to find out the names of the elements that need to be given new values. For examples, see \citebooktitle{Wickham2016} \autocite{Wickham2016} and \citebooktitle{Chang2018} \autocite{Chang2018}.
\end{playground}

Formatting of other text elements can be adjusted in a similar way, as well as thickness of axes, length of tick marks, grid lines, etc. However, in most cases, these are graphic design elements that are best kept consistent throughout sets of plots and best handled by creating a new \emph{theme}.

\begin{warningbox}
If you both add a \emph{complete theme} and want to modify some of its elements, you should add the whole theme before modifying it with \code{+ theme(...)}. This may seem obvious once one has a good grasp of the grammar of graphics, but can be at first disconcerting.
\end{warningbox}

It is also possible to modify the default theme used for rendering all subsequent plots.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{old_theme} \hlkwb{<-} \hlkwd{theme_update}\hlstd{(}\hlkwc{text} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"darkred"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Having saved the previous default to \code{old\_theme} it can be restored when needed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{theme_set}\hlstd{(old_theme)}
\end{alltt}
\end{kframe}
\end{knitrout}
\index{grammar of graphics!incomplete themes|)}

\subsection{Defining a new theme}\label{sec:plot:theme:new}
\index{grammar of graphics!creating a theme|(}
Themes can be defined both from scratch, or by modifying existing saved themes, and saving the modified version. As discussed above, it is also possible to define a new, parameterised theme constructor function.

Unless we plan to widely reuse the new theme, there is usually no need to define a new function. We can simply save the modified theme to a variable and add it to different plots as needed. As we will be adding a ``ready-build'' theme object rather than a function, we do not use parentheses.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_theme} \hlkwb{<-} \hlkwd{theme_bw}\hlstd{(}\hlnum{15}\hlstd{)} \hlopt{+} \hlkwd{theme}\hlstd{(}\hlkwc{text} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{colour} \hlstd{=} \hlstr{"darkred"}\hlstd{))}
\hlstd{p.base} \hlopt{+} \hlstd{my_theme}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-themes-21-1} 

}


\end{knitrout}

\begin{explainbox}
Creating a new theme constructor similar to those from package \ggplot can be fairly simple if the changes are few. As the implementation details of theme objects may change in future versions of \ggplot, the safest approach is to rely only on the public interface of the package. The functions exported by package \ggplot can be wrapped inside a new function that modifies the theme before returning it. The interface, parameters, of the wrapped function can be included in the new one and the arguments passed along to the wrapped function, as is or modified. If needed, additional parameters can be handled by code in the wrapper function. Below, a wrapper on \ggtheme{theme\_gray()} is constructed retaining a compatible interface, but adding a new base parameter, \code{base\_colour}. A different default is used for \code{base\_family}. The key detail is passing \code{complete = TRUE} to \Rfunction{theme()}, as this tags the returned theme as being usable by itself, resulting in replacement of any theme already in a plot when it is added.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_theme_gray} \hlkwb{<-}
  \hlkwa{function} \hlstd{(}\hlkwc{base_size} \hlstd{=} \hlnum{11}\hlstd{,}
            \hlkwc{base_family} \hlstd{=} \hlstr{"serif"}\hlstd{,}
            \hlkwc{base_line_size} \hlstd{= base_size}\hlopt{/}\hlnum{22}\hlstd{,}
            \hlkwc{base_rect_size} \hlstd{= base_size}\hlopt{/}\hlnum{22}\hlstd{,}
            \hlkwc{base_colour} \hlstd{=} \hlstr{"darkblue"}\hlstd{) \{}

    \hlkwd{theme_gray}\hlstd{(}\hlkwc{base_size} \hlstd{= base_size,}
               \hlkwc{base_family} \hlstd{= base_family,}
               \hlkwc{base_line_size} \hlstd{= base_line_size,}
               \hlkwc{base_rect_size} \hlstd{= base_rect_size)} \hlopt{+}

    \hlkwd{theme}\hlstd{(}\hlkwc{line} \hlstd{=} \hlkwd{element_line}\hlstd{(}\hlkwc{colour} \hlstd{= base_colour),}
          \hlkwc{rect} \hlstd{=} \hlkwd{element_rect}\hlstd{(}\hlkwc{colour} \hlstd{= base_colour),}
          \hlkwc{text} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{colour} \hlstd{= base_colour),}
          \hlkwc{title} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{colour} \hlstd{= base_colour),}
          \hlkwc{axis.text} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{colour} \hlstd{= base_colour),}
          \hlkwc{complete} \hlstd{=} \hlnum{TRUE}\hlstd{)}
  \hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

Our own theme constructor, created without too much effort, is ready to be used. To avoid surprising users, it is good to make \code{my\_theme\_grey()} a synonym of \code{my\_theme\_gray()} following \ggplot practice.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_theme_grey} \hlkwb{<-} \hlstd{my_theme_gray}
\end{alltt}
\end{kframe}
\end{knitrout}

A plot created using \code{my\_theme\_gray()} with text colour set to dark red.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlopt{+} \hlkwd{my_theme_gray}\hlstd{(}\hlnum{15}\hlstd{,} \hlkwc{base_colour} \hlstd{=} \hlstr{"darkred"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.495\textwidth]{figure/pos-themes-33-1} 

}


\end{knitrout}
\end{explainbox}
\index{grammar of graphics!creating a theme|)}
\index{plots!styling|)}
\index{grammar of graphics!themes|)}

\section{Composing Plots}\label{sec:plot:composing}
\index{plots!composing|(}
While facets make it possible to create plots with panels that share the same mappings and data (see section \ref{sec:plot:facets} on page \pageref{sec:plot:facets}), plot composition makes it possible to combine separately created \code{"gg"} plot objects into a single plot. Composition before rendering makes it possible to automate the correct alignments, ensure consistency of text size and even merge duplicate guide or keys. Composite plots can save space on the screen or page, but more importantly can bring together data visualisations that need to be compared or read as a whole.

Package \pkgname{patchwork} defines a simple grammar for composing plots created with \ggplot, that I have used earlier in the chapter to display pairs of plots side by side. Composition with \pkgname{patchwork} can also include grid graphical objects. The plot composition grammar uses operators \Roperator{+}, \Roperator{|} and \Roperator{/}, although \pkgname{patchwork} provides additional tools for defining complex layouts of panels. While \Roperator{+} allows different layouts, \Roperator{|} composes panels side by side, and \Roperator{/} composes panels on top of each other. The plots to be used as panels can be grouped using parentheses. The operands must be whole plots, below, this ensured by saving each plot to a variable. When composing anonymous plots they must be enclosed in parentheses, to ensure that the correct operators are dispatched.

Three simple plots, \code{p1}, \code{p2} and \code{p3} will be used below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mpg,} \hlkwd{aes}\hlstd{(displ, cty,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
        \hlkwd{geom_point}\hlstd{()} \hlopt{+}
        \hlkwd{theme}\hlstd{(}\hlkwc{legend.position} \hlstd{=} \hlstr{"top"}\hlstd{)}
\hlstd{p2} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mpg,} \hlkwd{aes}\hlstd{(displ, cty,} \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(year)))} \hlopt{+}
        \hlkwd{geom_point}\hlstd{()} \hlopt{+}
        \hlkwd{theme}\hlstd{(}\hlkwc{legend.position} \hlstd{=} \hlstr{"top"}\hlstd{)}
\hlstd{p3} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(mpg,} \hlkwd{aes}\hlstd{(}\hlkwd{factor}\hlstd{(model), cty))} \hlopt{+}
        \hlkwd{geom_point}\hlstd{()} \hlopt{+}
        \hlkwd{theme}\hlstd{(}\hlkwc{axis.text.x} \hlstd{=}
                \hlkwd{element_text}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlnum{90}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{vjust} \hlstd{=} \hlnum{0.5}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}



\begin{playground}
A combined plot can be simply assembled using the operators (plot not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{|} \hlstd{(p2} \hlopt{/} \hlstd{p3)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{(p1} \hlopt{|} \hlstd{p2)} \hlopt{/} \hlstd{p3}
\end{alltt}
\end{kframe}
\end{knitrout}

The operators used for composition are the arithmetic ones, and even if used for a different purpose still obey the precedence rules of mathematics. The order of precedence can be altered, as done above, using parentheses. Run the examples above after creating three plots. Modify the code trying different ways of organising the three panels.
\end{playground}

A title for the whole plot and a letter as tag for each panel are added as a whole-plot annotation.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{((p1} \hlopt{|} \hlstd{p2)} \hlopt{/} \hlstd{p3)} \hlopt{+}
   \hlkwd{plot_annotation}\hlstd{(}\hlkwc{title} \hlstd{=} \hlstr{"Fuel use in city traffic:"}\hlstd{,} \hlkwc{tag_levels} \hlstd{=} \hlstr{'a'}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.9\textwidth]{figure/pos-patchwork-03-1} 

}


\end{knitrout}



Package \pkgname{patchwork} has in recent versions tools for the creation of complex layouts, addition of insets and combining in the same layout plots and other graphic objects such as bitmaps, photographs, and even tables.

\begin{advplayground}
Package \pkgname{patchwork} can be very useful. Study the documentation and its examples, and try to think how it could be useful to you. Then try to compose plots like those you could use in your work or studies.
\end{advplayground}

\index{plots!composing|)}

\section[Using \texttt{plotmath} Expressions]{Using \code{plotmath} Expressions}\label{sec:plot:plotmath}
\index{plotmath}
\index{plots!math expressions|(}
Plotmath expression are similar to \Rlang expressions, but they are targeted at the creation of mathematical annotations. In some respects, they are similar to the math mode in \LaTeX. They are used in graphical output like plots. The syntax sometimes feels awkward and takes some time to be learnt, but it gets the job done.

\begin{explainbox}
The main limitation to producing rich text annotations in \Rlang similar to those possible using \LaTeX\ or using HTML is at the core of the \Rpgrm program. There is work in progress and improvements can be expected in coming years. Meanwhile, the already implemented enhancements gradually appear as enhanced features in \ggplot and its extensions.

Package \pkgname{ggtext} provides rich-text (basic \langname{HTML} and \Markdown) support for \ggplot, both for annotations and for data visualisation. This is an alternative to the use of \Rlang expressions.
\end{explainbox}

In sections \ref{sec:plot:function} and \ref{sec:plot:text}, simple examples of the use of \Rlang expressions for labelling plots were given. The \code{demo(plotmath)} demo and the help page \code{help(plotmath)} provide enough information to start using expressions in plots. Although expressions are shown here in the context of plotting, they are also used in other contexts in \Rlang code.

In general, it is possible to create \emph{expressions} explicitly with function \Rfunction{expression()} or by parsing a character string. In the case of \ggplot for some plot elements, layers created with \gggeom{geom\_text()} and \gggeom{geom\_label()}, and the strip labels of facets the parsing is delayed and applied to mapped character variables in \code{data}. In contrast, for titles, subtitles, captions, axis-labels, etc. (anything that is defined within \Rfunction{labs()}), the expressions have to be entered explicitly, or saved as such into a variable, and the variable passed as an argument.

When plotting expressions using \gggeom{geom\_text()}, the parsing of character strings is signalled by passing \code{parse = TRUE} in the call to the layer function. In the case of facets' strip labels, parsing or not depends on the \emph{labeller} function used. An additional twist is the possibility of combining static character strings with values taken from \code{data} (see section \ref{sec:plot:facets} on page \pageref{sec:plot:facets}).

The most difficult thing to remember when writing expressions is how to connect the different parts. A tilde (\code{\textasciitilde}) adds space in between symbols. Asterisk (\code{*}) can be also used as a connector. The \code{*} is usually needed when dealing with numbers next to symbols. Using whitespace is allowed in some situations, but not in others. To include within an expression text that should not be parsed, it must be enclosed in quotation marks, which may need themselves to be quoted. For a long list of examples, have a look at the output and code displayed by \code{demo(plotmath)} at the \Rlang command prompt.

Expressions are frequently used for axis labels, e.g., when the units or symbols require the use of superscripts or Greek letters. In this case, they are usually entered as expressions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p1} \hlopt{+} \hlkwd{labs}\hlstd{(}\hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(}\hlstr{"Fuel use"}\hlopt{~~}\hlstd{(m}\hlopt{~}\hlstd{g}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
          \hlkwc{x} \hlstd{=} \hlstr{"Engine displacement (L)"}\hlstd{,}
          \hlkwc{colour} \hlstd{=} \hlstr{"Engine\textbackslash{}ncylinders"}\hlstd{)} \hlopt{+}
          \hlkwd{theme}\hlstd{(}\hlkwc{legend.position} \hlstd{=} \hlstr{"right"}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plotmath-00-1} 

}


\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{54321}\hlstd{)} \hlcom{# make sure we always generate the same data}
\hlstd{my.data} \hlkwb{<-}
  \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,}
             \hlkwc{y} \hlstd{=} \hlkwd{rnorm}\hlstd{(}\hlnum{5}\hlstd{),}
             \hlkwc{greek.label} \hlstd{=} \hlkwd{paste}\hlstd{(}\hlstr{"alpha["}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlstr{"]"}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

In the example below, the $x$-axis label is a Greek $\alpha$ character with $i$ as subscript, and the $y$-axis label includes a superscript in the units. The title we use is a character string, while the subtitle is a rather complex expression.

Each observation has as data label a subscripted $alpha$. When using a \emph{geometry}, instead of directly using an expression, we map to the \code{label} \emph{aesthetic} character strings to be parsed into expressions. In other words, character strings, that are written using the syntax of expressions. We need to set \code{parse = TRUE} in the call to the \emph{geometry} so that the strings instead of being plotted as is, are parsed into expressions before the plot is rendered.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(my.data,} \hlkwd{aes}\hlstd{(x, y,} \hlkwc{label} \hlstd{= greek.label))} \hlopt{+}
   \hlkwd{geom_point}\hlstd{()} \hlopt{+}
   \hlkwd{geom_text}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlnum{45}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{1.2}\hlstd{,} \hlkwc{parse} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{+}
   \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{expression}\hlstd{(alpha[i]),}
        \hlkwc{y} \hlstd{=} \hlkwd{expression}\hlstd{(Speed}\hlopt{~~}\hlstd{(m}\hlopt{~}\hlstd{s}\hlopt{^}\hlstd{\{}\hlopt{-}\hlnum{1}\hlstd{\})),}
        \hlkwc{title} \hlstd{=} \hlstr{"Using expressions"}\hlstd{,}
        \hlkwc{subtitle} \hlstd{=} \hlkwd{expression}\hlstd{(}\hlkwd{sqrt}\hlstd{(alpha[}\hlnum{1}\hlstd{]} \hlopt{+} \hlkwd{frac}\hlstd{(beta, gamma))))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plotmath-02-1} 

}


\end{knitrout}

As parsing character strings is an alternative way of creating expressions, this approach can be also used in other situations. For example, a character string stored in a variable can be parsed with \Rfunction{parse()} as done below for \code{subtitle}. Tick labels are also set to expressions, taking advantage that \Rfunction{expression()} accepts multiple arguments separated by commas returning a vector of expressions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_eq.char} \hlkwb{<-} \hlstr{"alpha[i]"}
\hlkwd{ggplot}\hlstd{(my.data,} \hlkwd{aes}\hlstd{(x, y))} \hlopt{+}
   \hlkwd{geom_point}\hlstd{()} \hlopt{+}
   \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlkwd{parse}\hlstd{(}\hlkwc{text} \hlstd{= my_eq.char))} \hlopt{+}
   \hlkwd{scale_x_continuous}\hlstd{(}\hlkwc{name} \hlstd{=} \hlkwd{expression}\hlstd{(alpha[i]),}
                      \hlkwc{breaks} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{3}\hlstd{,}\hlnum{5}\hlstd{),}
                      \hlkwc{labels} \hlstd{=} \hlkwd{expression}\hlstd{(alpha[}\hlnum{1}\hlstd{], alpha[}\hlnum{3}\hlstd{], alpha[}\hlnum{5}\hlstd{]))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-plotmath-02a-1} 

}


\end{knitrout}

A different approach (no example shown) would be to call \Rfunction{parse()} explicitly for each individual label, something that might be needed if the tick labels need to be ``assembled'' programmatically instead of set as constants.

\begin{explainbox}
\textbf{Differences between \Rfunction{parse()} and \Rfunction{expression()}}. Function \Rfunction{parse()} takes as an argument a character string. This is very useful as the character string can be created programmatically. When using \code{expression()} this is not possible, except for substitution at execution time of the value of variables into the expression. See the help pages for both functions.

Function \Rfunction{expression()} accepts its arguments without any delimiters. Function \Rfunction{parse()} takes a single character string as an argument to be parsed, in which case quotation marks within the string need to be \emph{escaped} (using \code{\backslash"} where a literal \code{"} is desired). In both cases, a character string can be embedded using one of the functions \Rfunction{plain()}, \Rfunction{italic()}, \Rfunction{bold()} or \Rfunction{bolditalic()} which also affect the font used. The argument to these functions needs to be a character string delimited by quotation marks if it is not to be parsed.

When using \Rfunction{expression()}, bare quotation marks can be embedded,

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(cars,} \hlkwd{aes}\hlstd{(speed, dist))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{xlab}\hlstd{(}\hlkwd{expression}\hlstd{(x[}\hlnum{1}\hlstd{]}\hlopt{*}\hlstr{"  test"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

while in the case of \Rfunction{parse()} they need to be \emph{escaped},

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(cars,} \hlkwd{aes}\hlstd{(speed, dist))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{xlab}\hlstd{(}\hlkwd{parse}\hlstd{(}\hlkwc{text} \hlstd{=} \hlstr{"x[1]*\textbackslash{}"  test\textbackslash{}""}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

and in some cases will be enclosed within a format function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(cars,} \hlkwd{aes}\hlstd{(speed, dist))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{xlab}\hlstd{(}\hlkwd{parse}\hlstd{(}\hlkwc{text} \hlstd{=} \hlstr{"x[1]*italic(\textbackslash{}"  test\textbackslash{}")"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Some additional remarks. If \Rfunction{expression()} is passed multiple arguments, it returns a vector of expressions. Where \Rfunction{ggplot()} expects a single value as an argument, as in the case of axis labels, only the first member of the vector will be used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(cars,} \hlkwd{aes}\hlstd{(speed, dist))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{xlab}\hlstd{(}\hlkwd{expression}\hlstd{(x[}\hlnum{1}\hlstd{],} \hlstr{"  test"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Depending on the location within a expression, spaces maybe ignored, or illegal. To juxtapose elements without adding space, use \code{*}, and to explicitly insert whitespace, use \code{\textasciitilde}. As shown above, spaces are accepted within quoted text. Consequently, the following alternatives can also be used.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
  \hlkwd{xlab}\hlstd{(}\hlkwd{parse}\hlstd{(}\hlkwc{text} \hlstd{=} \hlstr{"x[1]~~~~\textbackslash{}"test\textbackslash{}""}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
  \hlkwd{xlab}\hlstd{(}\hlkwd{parse}\hlstd{(}\hlkwc{text} \hlstd{=} \hlstr{"x[1]~~~~plain(test)"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

However, unquoted whitespace is discarded.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
  \hlkwd{xlab}\hlstd{(}\hlkwd{parse}\hlstd{(}\hlkwc{text} \hlstd{=} \hlstr{"x[1]*plain(   test)"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Finally, it can be surprising that trailing zeros in numeric values appearing within an expression are dropped.
\end{explainbox}

Function \Rfunction{paste()} was used above to insert values stored in a variable; functions \Rfunction{format()}, \Rfunction{sprintf()} and \Rfunction{strftime()} allow the conversion into character strings of other values. These functions can be used when creating plots to generate suitable character strings for the \code{label} \emph{aesthetic} out of numeric, logical, date, time, and even character values. They can be, for example, used to create labels within a call to \code{aes()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sprintf}\hlstd{(}\hlstr{"log(%.3f) = %.3f"}\hlstd{,} \hlnum{5}\hlstd{,} \hlkwd{log}\hlstd{(}\hlnum{5}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "log(5.000) = 1.609"
\end{verbatim}
\begin{alltt}
\hlkwd{sprintf}\hlstd{(}\hlstr{"log(%.3g) = %.3g"}\hlstd{,} \hlnum{5}\hlstd{,} \hlkwd{log}\hlstd{(}\hlnum{5}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "log(5) = 1.61"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Study the chunk above. If you are familiar with \langname{C} or \langname{C++} function \Rfunction{sprintf()} will already be familiar to you, otherwise study its help page.

Play with functions \Rfunction{format()}, \Rfunction{sprintf()} and \Rfunction{strftime()}, using them to convert and format different types of data into character strings with different numbers of significant digits, scientific notation, decimal format, different field width, justification, etc.
\end{playground}

It is also possible to substitute the value of variables or, in fact, the result of evaluation, into a new expression, allowing on the fly construction of expressions. Such expressions are frequently used as labels in plots. This is achieved through use of \emph{quoting} and \emph{substitution}.

Function \Rfunction{bquote()} can be used to substitute variables or expressions enclosed in \code{.( )} by their value. Be aware that the argument to \Rfunction{bquote()} needs to be written as an expression; in this example, a tilde, \code{\textasciitilde}, inserts a space between words. Furthermore, if the expressions include variables, these will be searched for in the environment rather than within \code{data}, except within calls to \code{aes()} or \code{vars()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(cars,} \hlkwd{aes}\hlstd{(speed, dist))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlkwd{bquote}\hlstd{(Time}\hlopt{~}\hlstd{zone}\hlopt{:} \hlkwd{.}\hlstd{(}\hlkwd{Sys.timezone}\hlstd{())),}
       \hlkwc{subtitle} \hlstd{=} \hlkwd{bquote}\hlstd{(Date}\hlopt{:} \hlkwd{.}\hlstd{(}\hlkwd{as.character}\hlstd{(}\hlkwd{today}\hlstd{())))}
       \hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-expr-bquote-01-1} 

}


\end{knitrout}

In the case of \Rfunction{substitute()} a named list can be passed as argument.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(cars,} \hlkwd{aes}\hlstd{(speed, dist))} \hlopt{+}
  \hlkwd{geom_point}\hlstd{()} \hlopt{+}
  \hlkwd{labs}\hlstd{(}\hlkwc{title} \hlstd{=} \hlkwd{substitute}\hlstd{(Time}\hlopt{~}\hlstd{zone}\hlopt{:} \hlstd{tz,} \hlkwd{list}\hlstd{(}\hlkwc{tz} \hlstd{=} \hlkwd{Sys.timezone}\hlstd{())),}
       \hlkwc{subtitle} \hlstd{=} \hlkwd{substitute}\hlstd{(Date}\hlopt{:} \hlstd{date,} \hlkwd{list}\hlstd{(}\hlkwc{date} \hlstd{=} \hlkwd{as.character}\hlstd{(}\hlkwd{today}\hlstd{())))}
       \hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-expr-substitute-01-1} 

}


\end{knitrout}

For example, substitution can be used to assemble an expression within a function based on the arguments passed. One case of interest is to retrieve the name of the object passed as an argument, from within a function.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{deparse_test} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{) \{}
  \hlkwd{print}\hlstd{(}\hlkwd{deparse}\hlstd{(}\hlkwd{substitute}\hlstd{(x)))}
\hlstd{\}}

\hlstd{a} \hlkwb{<-} \hlstr{"saved in variable"}

\hlkwd{deparse_test}\hlstd{(}\hlstr{"constant"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "\"constant\""
\end{verbatim}
\begin{alltt}
\hlkwd{deparse_test}\hlstd{(}\hlnum{1} \hlopt{+} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "1 + 2"
\end{verbatim}
\begin{alltt}
\hlkwd{deparse_test}\hlstd{(a)}
\end{alltt}
\begin{verbatim}
## [1] "a"
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{plots!math expressions|)}

\section{Creating Complex Data Displays}\label{sec:plot:composition}
\index{plots!modular construction|(}

The grammar of graphics\index{grammar of graphics}\index{plots!layers} allows one to build and test plots incrementally. In daily use, when creating a completely new plot, it is best to start with a simple design for a plot, \code{print()} this plot, checking that the output is as expected and the code error-free. Afterwards, one can map additional \emph{aesthetics} and add \emph{geometries} and \emph{statistics} gradually. The final steps are then to add \emph{annotations} and the text or expressions used for titles, and axis and key labels. Another approach is to start with an existing plot and modify it, e.g.,  by using the same plotting code with different \code{data} or mapping different variables. When reusing code for a different data set, scale \code{limits} and \code{names} are likely to need to be edited.

\begin{playground}
  Build a graphically complex data plot of your interest, step by step, taking advantage of the layered structure to test intermediate versions in an iterative design process, first by building up the complex plot in stages as a tool in debugging, and later using iteration in the processes of improving the graphic design of the plot, its readability, and effectiveness in conveying information.
\end{playground}

\section{Creating Sets of Plots}\label{sec:plot:sets:of}
\index{plots!consistent styling}\index{plots!programatic construction|(}
Plots to be presented at a given occasion or published as part of the same work need to be consistent in various respects: themes, scales and palettes, annotations, titles, and captions. To guarantee this consistency, we need to build plots modularly and avoid repetition by assigning names to the ``modules'' that need to be used multiple times.

A simple version of this approach was used in many examples above, where a base plot was modified by addition of different layers or scales.

\subsection{Saving plot layers and scales in variables}

When creating plots with \ggplot,\index{plots!reusing parts of} objects are composed using operator \code{+} to assemble together the individual components. The functions that create plot layers, scales, etc.\ are constructors of objects and the objects they return can be stored in variables, and once saved, added to multiple plots at a later time.

A plot can be saved to a variable, here \code{p.base}, and, e.g., the value returned by a call to function \code{labs()}, into a different variable, here, \code{p.labels}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
                 \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,}
                 \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
          \hlkwd{geom_point}\hlstd{()}

\hlstd{p.labels} \hlkwb{<-} \hlkwd{labs}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"Engine displacement)"}\hlstd{,}
                 \hlkwc{y} \hlstd{=} \hlstr{"Gross horsepower"}\hlstd{,}
                 \hlkwc{colour} \hlstd{=} \hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{,}
                 \hlkwc{shape} \hlstd{=} \hlstr{"Number of\textbackslash{}ncylinders"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{warningbox}
 When composing plots with the \code{+} operator, the left-hand-side operand must be a \code{"gg"} object. The right-hand-side operand is added to the \code{"gg"} plot object and the result returned as a new \code{"gg"} plot object.
\end{warningbox}

The final plot can be assembled from the objects saved to variables. This is useful when creating several plots that should have consistent labels. The same approach can be used with other components. Below, the objects are combined with additional components to create different versions of the same plot.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.base}
\hlstd{p.base} \hlopt{+} \hlstd{p.labels} \hlopt{+} \hlkwd{theme_bw}\hlstd{(}\hlnum{16}\hlstd{)}
\hlstd{p.base} \hlopt{+} \hlstd{p.labels} \hlopt{+} \hlkwd{theme_bw}\hlstd{(}\hlnum{16}\hlstd{)} \hlopt{+} \hlkwd{ylim}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{NA}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can also save intermediate results.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.log} \hlkwb{<-} \hlstd{p.base} \hlopt{+} \hlkwd{scale_y_log10}\hlstd{(}\hlkwc{limits}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{8}\hlstd{,}\hlnum{55}\hlstd{))}
\hlstd{p.log} \hlopt{+} \hlstd{p.labels} \hlopt{+} \hlkwd{theme_bw}\hlstd{(}\hlnum{16}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Saving plot layers and scales in lists}

If the pieces to be put together do not include a \code{"gg"} object, they can be collected into a list and saved. When the list is added to a \code{"gg"} plot object, the members of the list are added one by one to the plot respecting their order.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{p.parts} \hlkwb{<-} \hlkwd{list}\hlstd{(p.labels,} \hlkwd{theme_bw}\hlstd{(}\hlnum{16}\hlstd{))}
\hlstd{p1} \hlopt{+} \hlstd{p.parts}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Revise the code you wrote for the ``playground'' exercise in section \ref{sec:plot:composition}, but this time, pre-building and saving groups of elements that you expect to be useful unchanged when composing a different plot of the same type, or a plot of a different type from the same data.
\end{playground}

\subsection{Using functions as building blocks}

The ``packaged'' plots parts sometimes should adjust their behaviour at the time they are added to a plot. In this case a function that accepts the necessary arguments can be written, rather similarly as in the example for creating a new theme by wrapping function \ggtheme{theme\_grey()} (see section \ref{sec:plot:theme:new} on page \pageref{sec:plot:theme:new}). These functions can return a \code{"gg"} object, a list of plot components, or a single plot component. The simplest use is to alter some defaults in existing constructor functions returning \code{"gg"} objects or layers. The ellipsis (\code{...}) allows passing named arguments to a nested function. In this case, every single argument passed by name to \code{bw\_ggplot()} will be copied as an argument to the nested call to \code{ggplot()}. Be aware that supplying arguments by position, is possible only for parameters explicitly included in the definition of the wrapper function, thus, not supported with a function like this, with \code{...} as its only formal parameter.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{bw_ggplot} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{...}\hlstd{) \{}
  \hlkwd{ggplot}\hlstd{(...)} \hlopt{+}
  \hlkwd{theme_bw}\hlstd{()}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

which could be used as follows.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{bw_ggplot}\hlstd{(}\hlkwc{data} \hlstd{= mtcars,}
          \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= disp,} \hlkwc{y} \hlstd{= mpg,}
          \hlkwc{colour} \hlstd{=} \hlkwd{factor}\hlstd{(cyl)))} \hlopt{+}
          \hlkwd{geom_point}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\index{plots!programatic construction|)}
\index{plots!modular construction|)}

\section{Generating Output Files}\label{sec:plot:render}
\index{devices!output|see{graphic output devices}}
\index{plots!saving to file|see{plots, rendering}}
\index{graphic output devices|(}
\index{plots!rendering|(}
It is possible, when using \RStudio, to directly export the displayed plot to a file using a menu. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In \Rlang,\index{plots!printing}\index{plots!saving}\index{plots!output to files} files are created by printing to different devices. Printing is directed to a currently open device such a window in \RStudio. Some devices produce screen output, while others write files. Devices depend on drivers. There are both devices that are part of \Rlang and additional ones defined in contributed packages.

Creating a file involves opening a device, printing and closing the device in sequence. In most cases, the file remains locked until the device is close.

For example, when rendering a plot to\index{plots!PDF output}\index{file formats!PDF} PDF, Encapsulated Postscript, SVG or other vector graphics formats, arguments passed to \code{width} and \code{height} are expressed in inches.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fig1} \hlkwb{<-} \hlkwd{ggplot}\hlstd{(}\hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlopt{-}\hlnum{3}\hlopt{:}\hlnum{3}\hlstd{),} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= x))} \hlopt{+}
  \hlkwd{stat_function}\hlstd{(}\hlkwc{fun} \hlstd{= dnorm)}
\hlkwd{pdf}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"fig1.pdf"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{8}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{6}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

For Encapsulated Postscript\index{plots!Postscript output}\index{file formats!PS, EPS} and SVG\index{plots!SVG output}\index{file formats!SVG} output, we only need to substitute \code{pdf()} with \code{postscript()} or \code{svg()}, respectively.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{postscript}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"fig1.eps"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{8}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{6}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

In the case of graphics devices for\index{plots!bitmap output}\index{file formats!JPEG}\index{file formats!PNG}\index{file formats!TIFF}\index{file formats!BMP} file output in BMP, JPEG, PNG, and TIFF bitmap formats, arguments passed to \code{width} and \code{height} are expressed in pixels.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{tiff}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"fig1.tiff"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{1000}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{800}\hlstd{)}
\hlkwd{print}\hlstd{(fig1)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}
\index{plots!rendering|)}
\index{graphic output devices|)}

\begin{warningbox}
Some graphics devices are part of base-\Rlang and others are implemented in contributed packages. In some cases, there are multiple graphic devices available for rendering graphics in a given file format. These devices usually use different libraries, or have been designed with different aims. These alternative graphic devices can also differ in their function signature, i.e., have differences in the parameters and their names.

Differences also exist in their limitations and supported features, so in cases when rendering fails inexplicably, it is worthwhile to switch to an alternative graphics device to find out if the problem is in the plot or in the rendering engine. Several of the new features added to \pkgname{grid} in \Rlang versions 4.1.0, 4.2.0, and 4.3.0 are currently supported only by some of the graphics devices.
\end{warningbox}

\section{Debugging Ggplots}

\Rlang package \pkgname{gginnards} provides methods \code{str()} (enhanced), \code{num\_layers()}, \code{top\_layer()}, \code{bottom\_layer()}, and \code{mapped\_vars()}. It also defines \code{geoms} and \code{stats} that instead of creating a layer, pass to a function such as \code{print()} the data frame they receive through parameter \code{data}. These are simple functions that even if dependent on \ggplot internals are not prone to easily break with \ggplot updates.

Package \pkgname{ggtrace} provides much more detailed and sophisticated approaches to explore the internals of \code{"gg"} plot objects. Package \ggplot itself gives access to some object components.

Of these tools, \gggeom{geom\_debug()} is probably the most intuitive to use, both on its own and as an argument to \code{stats}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Petal.Length,} \hlkwc{y} \hlstd{= Species))} \hlopt{+}
  \hlkwd{stat_summary}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"debug"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# No summary function supplied, defaulting to `mean\_se()`}}\begin{verbatim}
## [1] "Summary of input 'data' to 'draw_panel()':"
##   y group     x     xmin     xmax PANEL flipped_aes
## 1 1     1 1.462 1.437440 1.486560     1        TRUE
## 2 2     2 4.260 4.193545 4.326455     1        TRUE
## 3 3     3 5.552 5.473950 5.630050     1        TRUE
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-debug-01-1} 

}


\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ggplot}\hlstd{(}\hlkwc{data} \hlstd{= iris,} \hlkwc{mapping} \hlstd{=} \hlkwd{aes}\hlstd{(}\hlkwc{x} \hlstd{= Petal.Length))} \hlopt{+}
  \hlkwd{stat_bin}\hlstd{(}\hlkwc{geom} \hlstd{=} \hlstr{"debug"}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# `stat\_bin()` using `bins = 30`. Pick better value with `binwidth`.}}\begin{verbatim}
## [1] "Summary of input 'data' to 'draw_panel()':"
##    y count        x      xmin     xmax     width    density     ncount
## 1  2     2 1.017241 0.9155172 1.118966 0.2034483 0.06553672 0.07692308
## 2  9     9 1.220690 1.1189655 1.322414 0.2034483 0.29491525 0.34615385
## 3 26    26 1.424138 1.3224138 1.525862 0.2034483 0.85197740 1.00000000
## 4 11    11 1.627586 1.5258621 1.729310 0.2034483 0.36045198 0.42307692
## 5  2     2 1.831034 1.7293103 1.932759 0.2034483 0.06553672 0.07692308
## 6  0     0 2.034483 1.9327586 2.136207 0.2034483 0.00000000 0.00000000
##     ndensity flipped_aes PANEL group ymax ymin
## 1 0.07692308       FALSE     1    -1    2    0
## 2 0.34615385       FALSE     1    -1    9    0
## 3 1.00000000       FALSE     1    -1   26    0
## 4 0.42307692       FALSE     1    -1   11    0
## 5 0.07692308       FALSE     1    -1    2    0
## 6 0.00000000       FALSE     1    -1    0    0
\end{verbatim}
\end{kframe}

{\centering \includegraphics[width=.7\textwidth]{figure/pos-ggplot-debug-02-1} 

}


\end{knitrout}

\section{Further Reading}
An\index{further reading!grammar of graphics}\index{further reading!plotting} in-depth discussion of the many extensions to package \pkgname{ggplot2} is outside the scope of this book. Several books describe in detail the use of \pkgname{ggplot2}, being \citebooktitle{Wickham2016} \autocite{Wickham2016} the one written by the main author of the package. For inspiration or worked out examples, the book \citebooktitle{Chang2018} \autocite{Chang2018} is an excellent reference. In depth explanations of the technical aspects of \Rlang graphics are available in the book \citebooktitle{Murrell2019} \autocite{Murrell2019}.






%See section \ref{sec:plot:composition} on page \pageref{sec:plot:composition} on plot composition for an explanation of the code below.


% !Rnw root = appendix.main.Rnw



\chapter{Base \Rlang and Extensions: Data Sharing}\label{chap:R:data:io}\label{sec:data:io}

\begin{VF}
Most programmers have seen them, and most good programmers realise they've written at least one. They are huge, messy, ugly programs that should have been short, clean, beautiful programs.

\VA{John Bentley}{\emph{Programming Pearls}, 1986}
\end{VF}



\section{Aims of This Chapter}

Base \Rlang and the recommended packages (installed by default) include several functions for importing and exporting data. Contributed packages provide both replacements for some of these functions and support for several additional file formats. In the present chapter, I aim at describing both data input and output covering in detail only the most common ``foreign'' data formats (those not native to \Rlang).

Data file formats that are foreign to \Rlang are not always well defined, making it necessary to reverse-engineer the algorithms needed to read them. These formats, even when clearly defined, may be updated by the developers of the foreign software that writes the files. Consequently, developing software to read and write files using foreign formats can easily result in long, messy, and ugly \Rlang scripts. We can also unwillingly write code that usually works but occasionally fails with specific files, or even worse, occasionally silently corrupts the imported data. The aim of this chapter is to provide guidance for finding functions for reading data encoded using foreign formats, covering both base \Rlang, including the \pkgname{foreign} package, and independently contributed packages. Such functions are well tested or validated.

In this chapter you will familiarise yourself with how to exchange data between \Rlang and other applications. The functions \code{save()} and \code{load()}, and \code{saveRDS()} and  \code{readRDS()}, all of which save and read data in \Rlang's native formats, are described in sections \ref{sec:data:rda} and \ref{sec:data:rds} starting on page \pageref{sec:data:rda}.

\begin{warningbox}
  Several examples in this chapter make use of functions from the \pkgname{tidyverse} for data wrangling because some of the packages used to import data in ``foreign'' formats are themselves part of the \pkgname{tidyverse}. Some of the functions used appear in this chapter for the first time in the book.
\end{warningbox}

\section{Introduction}

The first step in any data analysis with \Rlang is to input or read-in the data. Available sources of data are many and data can be stored or transmitted using various formats, both based on text or binary encodings. It is crucial that data is not altered (corrupted) when read and that in the eventual case of an error, errors are clearly reported. Most dangerous are silent non-catastrophic errors.

The very welcome increase of awareness of the need for open availability of data, makes the output of data from \Rlang into well-defined data-exchange formats another crucial step. Consequently, in many cases an important step in data analysis is to export the data for submission to a repository, in addition to publication of the results of the analysis.

Faster internet access to data sources and cheaper random-access memory (RAM) has made it possible to efficiently work with relatively large data sets in \Rlang. That \Rlang keeps all data in memory (RAM), imposes limits to the size of data \Rlang functions can operate on. For data sets large enough not to fit in computer RAM, one can use selective reading of data from flat files, or from databases outside of \Rlang.

Some contributed \Rlang packages support import of data saved in the same formats already supported by base \Rlang, but using different compromises between reliability, easy of use and performance. Functions in base \Rlang tend to prioritise reliability and protection from data corruption while some contributed packages prioritise performance. Other contributed packages make it possible to import and export data stored in file formats not supported by base \Rlang functions. Some of these formats are subject-area specific while others are in widespread use. Packages supporting direct download of data sets from public repositories are becoming also common.

\section{Packages Used in This Chapter}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(learnrbook}\hlopt{::}\hlstd{pkgs_ch10_2ed)}
\end{alltt}
\end{kframe}
\end{knitrout}

To run the examples included in this chapter, you need first to load some packages from the library (see section \ref{sec:script:packages} on page \pageref{sec:script:packages} for details on the use of packages).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(learnrbook)}
\hlkwd{library}\hlstd{(tibble)}
\hlkwd{library}\hlstd{(purrr)}
\hlkwd{library}\hlstd{(stringr)}
\hlkwd{library}\hlstd{(dplyr)}
\hlkwd{library}\hlstd{(tidyr)}
\hlkwd{library}\hlstd{(readr)}
\hlkwd{library}\hlstd{(readxl)}
\hlkwd{library}\hlstd{(xlsx)}
\hlkwd{library}\hlstd{(readODS)}
\hlkwd{library}\hlstd{(pdftools)}
\hlkwd{library}\hlstd{(foreign)}
\hlkwd{library}\hlstd{(haven)}
\hlkwd{library}\hlstd{(xml2)}
\hlkwd{library}\hlstd{(XML)}
\hlkwd{library}\hlstd{(ncdf4)}
\hlkwd{library}\hlstd{(tidync)}
\hlkwd{library}\hlstd{(lubridate)}
\hlkwd{library}\hlstd{(jsonlite)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{warningbox}
Some data sets used in this and other chapters are available in package \pkgname{learnrbook}. In addition to the \Rlang data objects, the package includes files saved in \emph{foreign} formats used in examples of importing data. The files can be either read from the \Rlang library, or from a copy in a local folder. In this chapter the code examples assume the user has copied the folder \code{"extdata"} from the package to the current working folder.

The files can be copied by running the two statements below, assuming the current folder is the one that will be used to run the code examples in this chapter.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pkg.path} \hlkwb{<-} \hlkwd{system.file}\hlstd{(}\hlstr{"extdata"}\hlstd{,} \hlkwc{package} \hlstd{=} \hlstr{"learnrbook"}\hlstd{)}
\hlkwd{file.copy}\hlstd{(pkg.path,} \hlstr{"."}\hlstd{,} \hlkwc{overwrite} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{recursive} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Some examples write files to disk, and the statements below ensure that the folder used in these examples exists, creating it if not found.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{save.path} \hlkwb{=} \hlstr{"./data"}
\hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{dir.exists}\hlstd{(save.path)) \{}
  \hlkwd{dir.create}\hlstd{(save.path)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{warningbox}

\section{File Names and Operations}\label{sec:files:filenames}
\index{file names!portable}
\index{file operations|(}
The naming of files affects data sharing irrespective of the format used for its encoding. The main difficulty is that different operating systems have different rules governing the syntax used for file names and file paths. In many cases, like when depositing data files in a public repository, we need to ensure that file names are valid across multiple operating systems (OSs). If the script used to create the files is itself expected to be OS agnostic, queries for file names and paths in \Rlang code should not make assumptions on the naming rules or available OS commands. This is especially important when developing \Rlang packages.

\begin{warningbox}
\index{file names!script portability}
For maximum portability, file names should never contain white-space characters and contain at most one dot. For the widest possible portability, underscores should be avoided using dashes instead. As an example, instead of \code{my data.2019.csv}, use \code{my-data-2019.csv}.
\end{warningbox}

\Rlang provides functions which help with portability, by hiding the idiosyncrasies of the different OSs from \Rlang code. In scripts these functions should be preferred over direct call to OS commands (i.e., avoid calls to functions \Rfunction{shell()} or \Rfunction{system()} with OS commands as arguments) whenever possible. As the algorithm needed to extract a file name from a file path is OS specific, \Rlang provides functions such as \Rfunction{basename()}, whose implementation is OS specific but from the side of \Rlang code behave identically---these functions hide the differences among OSs from the user of \Rlang. The chunk below can be expected to work correctly under any OS for which \Rlang is available.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{basename}\hlstd{(}\hlstr{"extdata/my-file.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "my-file.txt"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{warningbox}
\index{file paths!script portability}
\index{folders|see{file paths}}
\index{file paths!parsing|(}
While in \pgrmname{Unix} and \pgrmname{Linux} folder nesting in file paths is marked with a forward slash character (\verb|/|), under \pgrmname{MS-Windows} it is marked with a backslash character (\verb|\|). Backslash (\verb|\|) is an escape character in \Rlang and interpreted as the start of an embedded special character (see section \ref{sec:calc:character} on page \pageref{sec:calc:character}), while in \Rlang a forward slash (\verb|/|) can be used for file paths under any OS, and escaped backslash (\verb|\\|) is valid only under MS-Windows. Consequently, \verb|/| should be always preferred to \verb|\\| to ensure portability, and is the approach used in this book.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{basename}\hlstd{(}\hlstr{"extdata/my-file.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "my-file.txt"
\end{verbatim}
\begin{alltt}
\hlkwd{basename}\hlstd{(}\hlstr{"extdata\textbackslash{}\textbackslash{}my-file.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "my-file.txt"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{warningbox}

The complementary function to \code{basename()} is \Rfunction{dirname()} and extracts from a full file path the bare path to the containing folder.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dirname}\hlstd{(}\hlstr{"extdata/my-file.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "extdata"
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{file paths!parsing|)}
\index{working directory|(}
Functions \Rfunction{getwd()} and \Rfunction{setwd()} can be used to get the path to the current working directory and to set a directory as current, respectively.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlkwd{getwd}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{setwd()} returns the path to the current working directory, allowing to portably restore the working directory to the previous one. Both relative paths (relative to the current working directory), as in the example, or absolute paths (given in full) are accepted as an argument. In mainstream OSs ``\code{.}'' indicates the current directory and ``\code{..}'' the directory above the current one.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlstd{oldwd} \hlkwb{<-} \hlkwd{setwd}\hlstd{(}\hlstr{".."}\hlstd{)}
\hlkwd{getwd}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

The returned value is always an absolute full path, so it remains valid even if the path to the working directory changes more than once before being restored.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# not run}
\hlstd{oldwd}
\hlkwd{setwd}\hlstd{(oldwd)}
\hlkwd{getwd}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}
\index{working directory|)}

\index{listing files or directories|(}
Function \Rfunction{list.files()} returns a list of names of files and/or directories (= disk folders) portably across OSs. Function \Rfunction{list.dirs()} returns only the names of directories.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{list.files}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] "abbrev.sty"                                           
## [2] "anscombe.svg"                                         
## [3] "Aphalo-CR-9781032518435-Learn-R-proofs-2024-01-26.pdf"
## [4] "Aphalo-CR-9781032518435-Learn-R.pdf"                  
## [5] "aphalo-Learn-R-2ed-crc-2023-06-14.pdf"                
## [6] "aphalo-learn-R-2ed-draft-2022-02-01.pdf"
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{list.dirs}\hlstd{())}
\end{alltt}
\begin{verbatim}
## [1] "."                "./.git"           "./.git/hooks"     "./.git/info"     
## [5] "./.git/logs"      "./.git/logs/refs"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
In these functions the default argument for parameter \code{path} is the current working directory, under Windows, Unix, and Linux indicated by \code{"."}. Convince yourself that this is indeed the default by calling the functions with an explicit argument. After this, play with the functions passing as argument to \code{path} other existing and non-existent file and directory paths.
\end{playground}

\begin{playground}
Pass different arguments to parameter \code{full.names} of \Rfunction{list.files()} to obtain either a list of file paths or bare file names. Similarly, investigate how the returned list of files is affected by the argument passed to \code{all.names}.
\end{playground}
\index{listing files or directories|)}

Base \Rlang provides several functions for portably working with files, and they are listed in the help page for \code{files} and in individual help pages. Use \code{help("files")} to access the help for this ``family'' of functions. The chunk below exercises some of these functions.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{file.exists}\hlstd{(}\hlstr{"xxx.txt"}\hlstd{)) \{}
  \hlkwd{file.create}\hlstd{(}\hlstr{"xxx.txt"}\hlstd{)}
\hlstd{\}}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{file.size}\hlstd{(}\hlstr{"xxx.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{file.info}\hlstd{(}\hlstr{"xxx.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##         size isdir mode               mtime               ctime
## xxx.txt    0 FALSE  666 2024-02-17 03:39:31 2024-02-17 03:39:31
##                       atime exe
## xxx.txt 2024-02-17 03:39:31  no
\end{verbatim}
\begin{alltt}
\hlkwd{file.rename}\hlstd{(}\hlstr{"xxx.txt"}\hlstd{,} \hlstr{"zzz.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{file.exists}\hlstd{(}\hlstr{"xxx.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] FALSE
\end{verbatim}
\begin{alltt}
\hlkwd{file.exists}\hlstd{(}\hlstr{"zzz.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\begin{alltt}
\hlkwd{file.remove}\hlstd{(}\hlstr{"zzz.txt"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Function \Rfunction{file.path()} can be used to construct a file path from its components in a way that is portable across OSs. Look at the help page and play with the function to assemble some paths that exist in the computer you are using.
\end{playground}
\index{file operations|)}

\section{Opening and Closing File Connections}\label{sec:io:connections}

Examples\index{file connections} in the rest of this chapter use as an argument for the \code{file} formal parameter literal paths or URLs, and complete the reading or writing operations within the call to a function. Sometimes it is necessary to read or write a text file sequentially, one row or record at a time. In such cases it is most efficient to keep the file open between reads and close the connection only when it is no longer needed. See \code{help(connections)} for details about the various functions available and their behaviour in different OSs. The code below opens a file connection, reads two lines, first the top one with column headers, then in a separate call to \Rfunction{readLines()}, the two lines or records with data, and finally closes the connection.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{f1} \hlkwb{<-} \hlkwd{file}\hlstd{(}\hlstr{"extdata/not-aligned-ASCII-UK.csv"}\hlstd{,} \hlkwc{open} \hlstd{=} \hlstr{"r"}\hlstd{)} \hlcom{# open for reading}
\hlkwd{readLines}\hlstd{(f1,} \hlkwc{n} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "col1,col2,col3,col4"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{readLines}\hlstd{(f1,} \hlkwc{n} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "1.0,24.5,346,ABC" "23.4,45.6,78,Z Y"
\end{verbatim}
\begin{alltt}
\hlkwd{close}\hlstd{(f1)}
\end{alltt}
\end{kframe}
\end{knitrout}

When \Rpgrm is used in batch mode, the ``files'' \code{stdin}, \code{stdout} and \code{stderror} can be opened, and data read from, or written to. These \emph{standard} sources and sinks, so familiar to \Clang programmers, allow the use of \Rlang scripts as tools in data pipes coded as shell scripts under Unix and other OSs.

\section{Plain-Text Files}\label{sec:files:txt}
\index{importing data!text files|(}\index{file formats!plain text}
In general, text files are the most portable approach to data storage but usually also the least efficient with respect to the size of the file. Text files are composed of encoded characters. This makes them easy to edit with text editors and easy to read from programs written in most programming languages. On the other hand, how the data encoded as characters is arranged can be based on two different approaches: positional or using a specific character as a separator.

The positional approach is more concise but almost unreadable to humans as the values run into each other. Reading of data stored using a positional approach requires access to a format definition and was common in FORTRAN and COBOL at the time when punch cards were used to store data. In the case of separators, different separators are in common use. Comma-separated values (CSV) encodings use either a comma or semicolon to separate the fields or columns. Tabulator, or tab-separated values (TSV) use the tab character as a column separator. Sometimes whitespace is used as a separator, most commonly when all values are to be converted to \code{numeric}.

\begin{explainbox}
\textbf{Not all text files are born equal.}\index{importing data!R names} When reading text files, and \emph{foreign} binary files which may contain embedded text strings, there is potential for their misinterpretation during the import operation. One common source of problems, is that column headers are to be read as \Rlang names. As earlier discussed, there are strict rules, such as avoiding spaces or special characters if the names are to be used with the normal \Rlang syntax. On import, some functions will attempt to sanitise the names, but others not. Most such names are still accessible in \Rlang statements, but a special syntax is needed to protect them from triggering syntax errors through their interpretation as something different than variable or function names---in \Rlang jargon we say that they need to be quoted.

Some of the things we need to be on the watch for are:
1) Mismatches between the character encoding expected by the function used to read the file, and the encoding used for saving the file---usually because of different locales, i.e., language and country settings.
2) Leading or trailing (invisible) spaces present in the character values or column names---which are almost invisible when data frames are printed.
3) Wrongly guessed column classes---a typing mistake affecting a single value in a column, e.g.,  the wrong kind of decimal marker, can prevent the column from being recognised as numeric.
4) Mismatched decimal marker in \code{CSV} files---the marker depends on the locale (language and country settings).

If you encounter problems after import, such as failure of extraction of data frame columns by name, use function \code{names()} to get the names printed to the console as a character vector. This is useful because character vectors are always printed with each string delimited by quotation marks making leading and trailing spaces clearly visible. The same applies to use of \code{levels()} with factors created with data that might have contained mistakes or whitespace.

To demonstrate some of these problems, I create a data frame with name sanitation disabled, and in the second statement with sanitation enabled. The first statement is equivalent to the default behaviour of functions in package \pkgname{readr} and the second is equivalent to the behaviour of base \Rlang functions. \pkgname{readr} prioritises the integrity of the original data while \Rlang prioritises compatibility with \Rlang's naming rules.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlstd{,} \hlstr{"a "} \hlstd{=} \hlnum{2}\hlstd{,} \hlstr{" a"} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{check.names} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   a a   a
## 1 1  2  3
\end{verbatim}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{a} \hlstd{=} \hlnum{1}\hlstd{,} \hlstr{"a "} \hlstd{=} \hlnum{2}\hlstd{,} \hlstr{" a"} \hlstd{=} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   a a. X.a
## 1 1  2   3
\end{verbatim}
\end{kframe}
\end{knitrout}

An even more subtle case is when characters can be easily confused by the user reading the output, or typing in the data: zero and o (\code{a0} vs.\ \code{aO}) or el and one (\code{al} vs.\ \code{a1}) can be difficult to distinguish in some fonts. When using encodings capable of storing many character shapes, such as unicode, in some cases two characters with almost identical visual shape may be encoded as different characters.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data.frame}\hlstd{(}\hlkwc{al} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{a1} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{aO} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{a0} \hlstd{=} \hlnum{4}\hlstd{)}
\end{alltt}
\begin{verbatim}
##   al a1 aO a0
## 1  1  2  3  4
\end{verbatim}
\end{kframe}
\end{knitrout}

Reading\index{importing data!text encodings} data from a text file can result in very odd-looking values stored in \Rlang variables because of a mismatch in encoding, e.g., when a CSV file saved with \pgrmname{MS-Excel} is silently encoded using 16-bit unicode format, but read as an 8-bit unicode encoded file.

The hardest part of all these problems is to diagnose their origin, as function arguments and working environment options can in most cases be used to force the correct decoding of text files with diverse characteristics, origins and vintages once one knows what is required. Function \code{tools:::showNonASCIIfile()}\qRfunction{showNonASCIIfile()} from the \Rlang \pkgname{tools} package, which is not exported, but available in recent and current (4.4.0) versions of \Rpgrm, can be used to test files for the presence on non-ASCII characters. This function takes as an argument the path to a file, and its companion function \code{tools:::showNonASCII()}\qRfunction{showNonASCII()} a \code{character} string.
\end{explainbox}

\subsection[Base \Rlang and \pkgnameNI{utils}]{Base \Rlang and \pkgname{utils}}
\index{text files!with field markers}
Text files containing data in columns can be divided into two broad groups. Those with fixed-width fields and those with delimited fields. Fixed-width fields were especially common in the early days of \langname{FORTRAN} and \langname{COBOL} when data storage capacity was very limited. These formats are frequently capable of encoding information using fewer characters than when delimited fields are used. The best way of understanding the differences is with examples. Although in this section we exemplify the use of functions by passing a file name as an argument, URLs, and open file descriptors are also accepted (see section \ref{sec:io:connections} on page \pageref{sec:io:connections}).

\begin{warningbox}
Wether columns containing character strings that cannot be converted into numbers are converted into factors or remain as character strings in the returned data frame depends on the value passed to parameter \code{stringsAsFactors}. The default changed in \Rlang version 4.0.0 from \code{TRUE} into \code{FALSE}. If code is to work consistently in old and new versions of \Rlang \code{stringsAsFactors = FALSE} has to be passed explicitly in calls to \Rfunction{read.csv()} (the approach used in the book).
\end{warningbox}

In\index{text files!CSV files}\index{text files!TSV files} the first example a file with fields solely delimited by ``,'' is read. This is what is called comma-separated-values (CSV) format that can be read and written with \Rfunction{read.csv()} and \Rfunction{write.csv()}, respectively.

The contents of file \code{not-aligned-ASCII-UK.csv} are shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
col1,col2,col3,col4
1.0,24.5,346,ABC
23.4,45.6,78,Z Y
\end{verbatim}
\end{kframe}
\end{knitrout}

The file is read and the returned value stored in a variable named \code{from\_csv\_a.df}, and printed.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_a.df} \hlkwb{<-}
  \hlkwd{read.csv}\hlstd{(}\hlstr{"extdata/not-aligned-ASCII-UK.csv"}\hlstd{,} \hlkwc{stringsAsFactors} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_a.df}
\end{alltt}
\begin{verbatim}
##   col1 col2 col3 col4
## 1  1.0 24.5  346  ABC
## 2 23.4 45.6   78  Z Y
\end{verbatim}
\begin{alltt}
\hlstd{from_csv_a.df[[}\hlstr{"col4"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] "ABC" "Z Y"
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(from_csv_a.df, class)}
\end{alltt}
\begin{verbatim}
##        col1        col2        col3        col4 
##   "numeric"   "numeric"   "integer" "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Read the file \code{not-aligned-ASCII-UK.csv} with function \Rfunction{read.csv2()} instead of \Rfunction{read.csv()}. Although this may look like a waste of time, the point of the exercise is for you to get familiar with \Rlang behaviour in case of such a mistake. This will help you recognise similar errors when they happen accidentally, which is quite common when files are shared.
\end{playground}

Example file \code{aligned-ASCII-UK.csv} contains comma-separated-values with added whitespace to align the columns, to make it easier to read by humans.

The contents of file \code{aligned-ASCII-UK.csv} are shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
col1, col2, col3, col4
 1.0, 24.5,  346,  ABC
23.4, 45.6,   78,  Z Y
\end{verbatim}
\end{kframe}
\end{knitrout}

The file is read and the returned value stored in a variable named \code{from\_csv\_b.df}, and printed.
Although space characters are read as part of the fields, they are ignored when conversion to numeric takes place.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_b.df} \hlkwb{<-}
  \hlkwd{read.csv}\hlstd{(}\hlstr{"extdata/aligned-ASCII-UK.csv"}\hlstd{,} \hlkwc{stringsAsFactors} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_b.df}
\end{alltt}
\begin{verbatim}
##   col1 col2 col3  col4
## 1  1.0 24.5  346   ABC
## 2 23.4 45.6   78   Z Y
\end{verbatim}
\begin{alltt}
\hlstd{from_csv_b.df[[}\hlstr{"col4"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] "  ABC" "  Z Y"
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(from_csv_b.df, class)}
\end{alltt}
\begin{verbatim}
##        col1        col2        col3        col4 
##   "numeric"   "numeric"   "integer" "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

By default, column names are sanitised but whitespace in character strings kept. Passing an additional argument changes this default so that leading and trailing whitespace are discarded. Most likely the default has been chosen so that by default data integrity is maintained.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_c.df} \hlkwb{<-}
  \hlkwd{read.csv}\hlstd{(}\hlstr{"extdata/aligned-ASCII-UK.csv"}\hlstd{,}
           \hlkwc{stringsAsFactors} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{strip.white} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_c.df}
\end{alltt}
\begin{verbatim}
##   col1 col2 col3 col4
## 1  1.0 24.5  346  ABC
## 2 23.4 45.6   78  Z Y
\end{verbatim}
\begin{alltt}
\hlstd{from_csv_c.df[[}\hlstr{"col4"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] "ABC" "Z Y"
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(from_csv_c.df, class)}
\end{alltt}
\begin{verbatim}
##        col1        col2        col3        col4 
##   "numeric"   "numeric"   "integer" "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
When\index{importing data!character to factor conversion} character strings are converted into factors, leading and trailing whitespace is retained in the labels of factor levels. Leading and trailing whitespace are difficult to see when data frames are printed, as shown below. This example shows what problems were frequently encountered in earlier versions of \Rlang, and can still occur when factors are created. The recommended approach is to use the default \code{stringsAsFactors = FALSE} and do the conversion into factors in a separate step.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_csv_b.df} \hlkwb{<-}
  \hlkwd{read.csv}\hlstd{(}\hlstr{"extdata/aligned-ASCII-UK.csv"}\hlstd{,} \hlkwc{stringsAsFactors} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Using \code{levels()} it can be seen that the labels of the automatically created factor levels contain leading spaces.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sapply}\hlstd{(from_csv_b.df, class)}
\end{alltt}
\begin{verbatim}
##      col1      col2      col3      col4 
## "numeric" "numeric" "integer"  "factor"
\end{verbatim}
\begin{alltt}
\hlstd{from_csv_b.df[[}\hlstr{"col4"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1]   ABC   Z Y
## Levels:   ABC   Z Y
\end{verbatim}
\begin{alltt}
\hlkwd{levels}\hlstd{(from_csv_b.df[[}\hlstr{"col4"}\hlstd{]])}
\end{alltt}
\begin{verbatim}
## [1] "  ABC" "  Z Y"
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}

Decimal\index{importing data!decimal marker} points and exponential notation are allowed for floating point values. In English-speaking locales, the decimal mark is a point, while in many other locales it is a comma. The behaviour of \Rlang functions does not change when run under different locales. When a comma is used as decimal marker, we can a semicolon (\verb|;|) is used as field marker.

This handled by using functions \Rfunction{read.csv2()} and \Rfunction{write.csv2()}. Furthermore, parameters \code{dec} and \code{sep} allow setting the decimal marker and field separator to arbitrary character strings.

Function \Rfunction{read.table()} does the actual work and functions like \Rfunction{read.csv()} only differ in the default arguments for the different parameters. By default, \Rfunction{read.table()} expects fields to be separated by whitespace (one or more spaces, tabs, new lines, or carriage return).

The contents of file \code{aligned-ASCII.txt} are shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
col1 col2 col3 col4
 1.0 24.5  346 ABC
23.4 45.6   78 "Z Y"
\end{verbatim}
\end{kframe}
\end{knitrout}

The file is read and the returned value stored in a variable named \code{from\_txt\_b.df}, and printed.
Leading and trailing whitespace are removed because they are recognised as part of the separators. For character strings containing embedded spaces to be decoded as a single value they need to be quoted in the file as in \code{aligned-ASCII.txt} above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_txt_b.df} \hlkwb{<-}
  \hlkwd{read.table}\hlstd{(}\hlstr{"extdata/aligned-ASCII.txt"}\hlstd{,}
             \hlkwc{stringsAsFactors} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{header} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_txt_b.df}
\end{alltt}
\begin{verbatim}
##   col1 col2 col3 col4
## 1  1.0 24.5  346  ABC
## 2 23.4 45.6   78  Z Y
\end{verbatim}
\begin{alltt}
\hlstd{from_txt_b.df[[}\hlstr{"col4"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] "ABC" "Z Y"
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(from_txt_b.df, class)}
\end{alltt}
\begin{verbatim}
##        col1        col2        col3        col4 
##   "numeric"   "numeric"   "integer" "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\index{text files!fixed width fields}
With a fixed-width format, no delimiters are needed. Decoding is based solely on the position of the characters in the line or record. A file like this cannot be interpreted without a description of the format used for saving the data. Files containing data stored in \emph{fixed width format} can be read with function \Rfunction{read.fwf()}. Records for a single observation can be stored in a single or multiple lines. In either case, each line has fields of different but fixed known widths.

Function\index{text files!FORTRAN formatted data transfer} \Rfunction{read.fortran()} is a wrapper on \Rfunction{read.fwf()} that accepts format definitions similar to those used in \langname{FORTRAN}. One particularity of \langname{FORTRAN} \emph{formatted data transfer} is that the decimal marker can be omitted in the saved file and its position specified as part of the format definition, a trick used to make text files (or stacks of punch cards!) smaller. Modern versions of \langname{FORTRAN} support reading from and writing to other formats like those using field delimiters described above.

The contents of file \code{aligned-ASCII.fwf} are shown below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
 10245346ABC
234456 78Z Y
\end{verbatim}
\end{kframe}
\end{knitrout}

The file is read and the returned value stored in a variable named \code{from\_fwf\_a.df}, and printed. The format definition is passed as a separate character vector argument, e.g., \code{"2F3.1"} describes the format of the first two columns, \code{"I3"} describes the third column and \code{"A3"} the fourth.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_fwf_a.df} \hlkwb{<-}
  \hlkwd{read.fortran}\hlstd{(}\hlstr{"extdata/aligned-ASCII.fwf"}\hlstd{,}
               \hlkwc{format} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"2F3.1"}\hlstd{,} \hlstr{"I3"}\hlstd{,} \hlstr{"A3"}\hlstd{),}
               \hlkwc{col.names} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"col1"}\hlstd{,} \hlstr{"col2"}\hlstd{,} \hlstr{"col3"}\hlstd{,} \hlstr{"col4"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{from_fwf_a.df}
\end{alltt}
\begin{verbatim}
##   col1 col2 col3 col4
## 1  1.0 24.5  346  ABC
## 2 23.4 45.6   78  Z Y
\end{verbatim}
\begin{alltt}
\hlstd{from_fwf_a.df[[}\hlstr{"col4"}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## [1] "ABC" "Z Y"
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(from_fwf_a.df, class)}
\end{alltt}
\begin{verbatim}
##        col1        col2        col3        col4 
##   "numeric"   "numeric"   "integer" "character"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
  The file reading functions described above share with \Rfunction{read.table()} the same parameters. In addition to those described above, other frequently useful parameters are \code{skip} and \code{n}, which can be used to skip lines at the top of a file and limit the number of lines (or records) to read; \code{header}, which accepts a logical argument indicating if the fields in the first text line read should be decoded as column names rather than data; \code{na.strings}, to which can be passed a character vector with strings to be interpreted as \code{NA}; and \code{colClasses}, which provides control of the conversion of the fields to \Rlang classes and possibly skipping some columns altogether. All these parameters are described in the corresponding help pages.
\end{explainbox}

\begin{playground}
In reality  \Rfunction{read.csv()}, \code{read.csv2()} and \Rfunction{read.table()} are the same function with different default arguments to several of their parameters. Study the help page, and by passing suitable arguments, make \Rfunction{read.csv()} behave like \Rfunction{read.table()}, then make \Rfunction{read.table()} behave like \Rfunction{read.csv2()}.
\end{playground}

\begin{explainbox}
A text file can be read as character strings, without attempting to decode them. This is occasionally useful, such as when the decoding is done in a script, or when needs to print a file as is. In this case, the function used is \code{readLines()}. The returned value is a character vector in which each member string corresponds to one line or record in the file, with the end-of-line markers stripped (see example in section \ref{sec:io:connections} on page \pageref{sec:io:connections}).
\end{explainbox}
\index{importing data!text files|)}

\index{exporting data!text files|(}
The next example shows how a \emph{write} function matching one of the \emph{read} functions described above can be used to save a data frame to a text file. The \Rfunction{write.csv()} function takes as an argument a data frame, or an object that can be coerced into a data frame, converts it to character strings, and saves them to a text file. A data frame, \code{my.df} with five rows is enough for a demonstration.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.df} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlkwc{y} \hlstd{=} \hlnum{5}\hlopt{:}\hlnum{1} \hlopt{/} \hlnum{10}\hlstd{,} \hlkwc{z} \hlstd{= letters[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{])}
\end{alltt}
\end{kframe}
\end{knitrout}

We write \code{my.df} to a CSV file suitable for an English language locale, and then display its contents.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{write.csv}\hlstd{(my.df,} \hlkwc{file} \hlstd{=} \hlstr{"my-file1.csv"}\hlstd{,} \hlkwc{row.names} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\hlkwd{file.show}\hlstd{(}\hlstr{"my-file1.csv"}\hlstd{,} \hlkwc{pager} \hlstd{=} \hlstr{"console"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
"x","y","z"
1,0.5,"a"
2,0.4,"b"
3,0.3,"c"
4,0.2,"d"
5,0.1,"e"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
In most cases setting, as above, \code{row.names = FALSE} when writing a CSV file will help when it is read. Of course, if row names do contain important information, such as gene tags, you cannot skip writing the row names to the file unless you first copy these data into a column in the data frame. (Row names are stored separately as an attribute in \code{data.frame} objects, see section \ref{sec:calc:attributes} on page \pageref{sec:calc:attributes} for details.)
\end{explainbox}

\begin{playground}
Write the data frame \code{my.df} into text files with functions \Rfunction{write.csv2()} and \Rfunction{write.table()} instead of \Rfunction{read.csv()} and display the files.
\end{playground}

Function \Rfunction{cat()} takes \Rlang objects and writes them after conversion to character strings to the console or a file, inserting one or more characters as separators, by default, a space. This separator can be set through parameter \code{sep}. In our example we set \code{sep} to a new line (entered as the escape sequence \code{"\textbackslash n"}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my.lines} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"abcd"}\hlstd{,} \hlstr{"hello world"}\hlstd{,} \hlstr{"123.45"}\hlstd{)}
\hlkwd{cat}\hlstd{(my.lines,} \hlkwc{file} \hlstd{=} \hlstr{"my-file2.txt"}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{"\textbackslash{}n"}\hlstd{)}
\hlkwd{file.show}\hlstd{(}\hlstr{"my-file2.txt"}\hlstd{,} \hlkwc{pager} \hlstd{=} \hlstr{"console"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
abcd
hello world
123.45
\end{verbatim}
\end{kframe}
\end{knitrout}
\index{exporting data!text files|)}

\subsection[\pkgnameNI{readr}]{\pkgname{readr}}\label{sec:files:readr}
\index{importing data!text files|(}



Package \pkgname{readr} is part of the \pkgname{tidyverse} suite. It defines functions that have different default behaviour and that are designed to be faster under different situations than those native to  \Rlang. The functions from package \pkgname{readr} can sometimes wrongly decode their input and rarely even do this silently. The \pkgname{readr} functions guess more properties of the text file format; in most cases they succeed, which is very handy, but occasionally they fail. Automatic guessing can be overridden by passing arguments and this is recommended for scripts that will be reused to read different files in the future. Another important advantage is that these functions read character strings formatted as dates or times directly into columns of class \code{POSIXct}. All \code{write} functions defined in \pkgname{readr} have an \code{append} parameter, which can be used to change the default behaviour of overwriting an existing file with the same name, to appending the output at its end.

Although in this section we exemplify the use of these functions by passing a file name as an argument, as is the case with \Rlang native functions, URLs, and open file descriptors are also accepted (see section \ref{sec:io:connections} on page \pageref{sec:io:connections}). Furthermore,\index{file formats!compressed} if the file name ends in a tag recognisable as indicating a compressed file format, e.g., \code{.gz} or \code{.zip}, the file will be uncompressed on the fly.

\begin{warningbox}
Functions ``equivalent'' to native \Rlang functions described in the previous section have names formed by replacing the dot with an underscore, e.g.,  \Rfunction{read\_csv()} $\approx$ \Rfunction{read.csv()}. The similarity refers to the format of the files read, but not the order, names, or roles of their formal parameters. For example, function \code{read\_table()} has a slightly different behaviour than \Rfunction{read.table()}, although they both read fields separated by whitespace. Row names are not set in the returned \Rclass{tibble}, which inherits from \Rclass{data.frame}, but is not fully compatible (see section \ref{sec:data:tibble} on page \pageref{sec:data:tibble}).
\end{warningbox}

\begin{warningbox}
  Package \pkgname{readr} is under active development, and functions with the same name from different major versions are not fully compatible. Code for some examples from the first edition of the book no longer work because the updated implementation fails to recognise escaped special characters. Function \Rfunction{read\_table2()} has been renamed \Rfunction{read\_table()}.
\end{warningbox}

These functions report to the console the specifications of the columns, which is important when these are guessed from the file contents, or even only from rows near the top of the file.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_csv}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/aligned-ASCII-UK.csv"}\hlstd{,} \hlkwc{show_col_types} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # A tibble: 2 x 4
##    col1  col2  col3 col4 
##   <dbl> <dbl> <dbl> <chr>
## 1   1    24.5   346 ABC  
## 2  23.4  45.6    78 Z Y
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_csv}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/not-aligned-ASCII-UK.csv"}\hlstd{,} \hlkwc{show_col_types} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # A tibble: 2 x 4
##    col1  col2  col3 col4 
##   <dbl> <dbl> <dbl> <chr>
## 1   1    24.5   346 ABC  
## 2  23.4  45.6    78 Z Y
\end{verbatim}
\end{kframe}
\end{knitrout}

Package \pkgname{readr} is under active development, and different major versions are not fully compatible with each other. Because of the misaligned fields in file \code{"not-aligned-ASCII.txt"} in the past we needed to use \Rfunction{read\_table2()}, which allowed misalignment of fields, similarly to \Rfunction{read.table()}. This function has been renamed as \Rfunction{read\_table()} and \Rfunction{read\_table2()} deprecated. However, parsing of both files fails if they are read with \Rfunction{read\_table()}, quoted strings containing whitespace are no longer recognised. See above example using \Rfunction{read.table()}. Examples below are not run, but kept as they may work again in the future.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_table}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/aligned-ASCII.txt"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_table}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/not-aligned-ASCII.txt"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{read\_delim()} with space as the delimiter succeeds only with the not-aligned file as in this file the separator is in all cases a single space.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_delim}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/not-aligned-ASCII.txt"}\hlstd{,}
           \hlkwc{delim} \hlstd{=} \hlstr{" "}\hlstd{,} \hlkwc{show_col_types} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # A tibble: 2 x 4
##    col1  col2  col3 col4 
##   <dbl> <dbl> <dbl> <chr>
## 1   1    24.5   346 ABC  
## 2  23.4  45.6    78 Z Y
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{read\_tsv()} reads files encoded with the tab character as the delimiter, and \Rfunction{read\_fwf()} reads files with fixed width fields. There is, however, no equivalent to \Rfunction{read.fortran()}, supporting implicit decimal points.

\begin{playground}
Use the "wrong" \code{read\_} functions to read the example files used above and/or your own files. As mentioned earlier, forcing errors will help you learn how to diagnose when such errors are caused by coding or data entry mistakes. In this case, as wrongly read data are not always accompanied by error or warning messages, carefully check the returned tibbles for misread data values.
\end{playground}

\begin{explainbox}
The functions from \Rlang's package \pkgname{utils} read the whole file as text before attempting to guess the class of the columns or their alignment. This is reliable but slow for text files with many lines. The functions from \pkgname{readr} read by default only the top 1000 lines when guessing the format and class, and then rather blindly read the whole files assuming that the guessed properties also apply to the remaining lines of the file. This is more efficient in the case of such files, but somehow risky. In contrast, the functions from \Rlang's package \pkgname{utils} are much faster than those from package \pkgname{readr} at reading files with many fields (or columns) per line.

In earlier versions of \pkgname{readr}, a typical failure to correctly decode fields was when numbers are in increasing order and the field widths continue increasing in the lines below those used for guessing, but this case seems to be, at the time of writing correctly, handled. A guess based on the top 1000 lines of a text file also means that in cases values in lines below \code{guess\_max} lines cannot be converted to numeric, instead of returning a column of character strings as functions from \Rlang's package \pkgname{utils}, their values are replaced by numeric \code{NA} values with a warning. To demonstrate this a very small value for \code{guess\_max} is used to demonstrate the behaviour with a file only a few lines in length.



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_table}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/miss-aligned-ASCII.txt"}\hlstd{,} \hlkwc{show_col_types} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # A tibble: 4 x 4
##   col1   col2  col3 col4 
##   <chr> <dbl> <dbl> <chr>
## 1 1.0    24.5   346 ABC  
## 2 2.4    45.6    78 XYZ  
## 3 20.4   45.6    78 XYZ  
## 4 a      20    2500 abc
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{read_table}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/miss-aligned-ASCII.txt"}\hlstd{,} \hlkwc{show_col_types} \hlstd{=} \hlnum{FALSE}\hlstd{,}
           \hlkwc{guess_max} \hlstd{=} \hlnum{3L}\hlstd{)}
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: 1 parsing failure.\\\#\# row \ col expected actual \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ file\\\#\# \ \ 4 col1 a double \ \ \ \ \ a 'extdata/miss-aligned-ASCII.txt'}}\begin{verbatim}
## # A tibble: 4 x 4
##    col1  col2  col3 col4 
##   <dbl> <dbl> <dbl> <chr>
## 1   1    24.5   346 ABC  
## 2   2.4  45.6    78 XYZ  
## 3  20.4  45.6    78 XYZ  
## 4  NA    20    2500 abc
\end{verbatim}
\end{kframe}
\end{knitrout}
\end{explainbox}
\index{importing data!text files|)}



\index{exporting data!text files|(}
The \code{write\_} functions from \pkgname{readr} are the counterpart to \code{write.} functions from \pkgname{utils}. In addition to the expected \Rfunction{write\_csv()}, \Rfunction{write\_csv2()}, \Rfunction{write\_tsv()} and \Rfunction{write\_delim()}, \pkgname{readr} provides functions that write \pgrmname{MS-Excel}-friendly CSV files. Function \Rfunction{write\_excel\_csv()} saves a text file with comma-separated fields suitable for import into \pgrmname{MS-Excel}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{write_excel_csv}\hlstd{(my.df,} \hlkwc{file} \hlstd{=} \hlstr{"my-file6.csv"}\hlstd{)}
\hlkwd{file.show}\hlstd{(}\hlstr{"my-file6.csv"}\hlstd{,} \hlkwc{pager} \hlstd{=} \hlstr{"console"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{verbatim}
"x","y","z"
1,0.5,"a"
2,0.4,"b"
3,0.3,"c"
4,0.2,"d"
5,0.1,"e"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Compare the output from \Rfunction{write\_excel\_csv()} and \Rfunction{write\_csv()}. What is the difference? Does it matter when you import the written CSV file into Excel (in the version you are using, and with the locale settings of your computer)?
\end{playground}

The pair of functions \Rfunction{read\_lines()} and \Rfunction{write\_lines()} read and write character vectors without conversion, similarly to base \Rlang \code{readLines()} and \code{writeLines()}. Functions \Rfunction{read\_file()} and \Rfunction{write\_file()} read and write the contents of a whole text file into, and from, a single character string. Functions \Rfunction{read\_file()} and \Rfunction{write\_file()} can also be used with raw vectors to read and write binary files or text files of unknown encoding.

The contents of the whole file are returned as a character vector of length one, with the embedded new line markers. We use \code{cat()} to print it so these new line characters force the start of a new print-out line.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{one.str} \hlkwb{<-} \hlkwd{read_file}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/miss-aligned-ASCII.txt"}\hlstd{)}
\hlkwd{length}\hlstd{(one.str)}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlkwd{cat}\hlstd{(one.str)}
\end{alltt}
\begin{verbatim}
## col1  col2 col3 col4
## 1.0   24.5  346 ABC
## 2.4   45.6   78 XYZ
## 20.4   45.6   78 XYZ
##  a    20     2500 abc
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Use \Rfunction{write\_file()} to write a file that can be read with \Rfunction{read\_csv()}.
\end{advplayground}
\index{exporting data!text files|)}

\section{XML and HTML Files}
\index{importing data!XML and HTML files|(}
\index{file formats!HTML}\index{file formats!XML}
XML files contain text with special markup. Several modern data exchange formats are based on the \langname{XML} standard (see \url{https://www.w3.org/TR/xml/}) which uses schemas for flexibility. Schemas define specific formats, allowing reading of formats not specifically targeted during development of the read functions. Even the modern \langname{XHTML} standard used for web pages is based on such schemas, while \langname{HTML} only differs slightly in its syntax.

\subsection[\pkgnameNI{xml2}]{\pkgname{xml2}}



Package \pkgname{xml2} provides functions for reading and parsing \langname{XTML} and \langname{HTML} files. This is a vast subject, of which I will only give a brief example.

Function \Rfunction{read\_html()} can be used to read an HTML document, either locally or from an URL as below.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{web_page} \hlkwb{<-} \hlkwd{read_html}\hlstd{(}\hlstr{"https://www.learnr-book.info/"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{html\_structure()} displays the structure of an HTML document (long text output not shown).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{html_structure}\hlstd{(web_page)}
\end{alltt}
\end{kframe}
\end{knitrout}

Function \Rfunction{xml\_text()} extracts the text content of a field. Function \Rfunction{xml\_find\_all()} returns a field searched by name. Here used to extract the text from the \code{title} attribute, using functions \Rfunction{xml\_find\_all()} and .

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{xml_text}\hlstd{(}\hlkwd{xml_find_all}\hlstd{(web_page,} \hlstr{".//title"}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] "Learn R: As a Language"
\end{verbatim}
\end{kframe}
\end{knitrout}

The functions defined in this package can be used to ``harvest'' data from web pages, but also to read data from files using formats that are defined through \langname{XML} schemas.
\index{importing data!XML and HTML files|)}

\section{GPX Files}
\index{importing data!GPX files|(}\index{file formats!GPX}
GPX\index{importing data!geographic positioning system} (GPS Exchange Format) files use an XML scheme designed for saving and exchanging data from geographic positioning systems (GPS). There is some variation on the variables saved depending on the settings of the GPS receiver. The example data used here is from a Transmeta BT747 GPS logger. The example below reads the data into a \code{tibble} as character strings. For plotting, the character values representing numbers and dates would need to be converted to numeric and datetime (\code{POSIXct}) values, respectively. In the case of plotting tracks on a map, it is preferable to use package \pkgname{sf} to import the tracks directly from the \code{.gpx} file into a layer (use of \Rlang pipe operator is described in section \ref{sec:script:pipes} on page \pageref{sec:script:pipes}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{xmlTreeParse}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/GPSDATA.gpx"}\hlstd{,} \hlkwc{useInternalNodes} \hlstd{=} \hlnum{TRUE}\hlstd{) |>}
\hlkwd{xmlRoot}\hlstd{(}\hlkwc{x} \hlstd{= _) |>}
\hlkwd{xmlToList}\hlstd{(}\hlkwc{node} \hlstd{= _) |>}
\hlstd{_[[}\hlstr{"trk"}\hlstd{]] |>}
\hlkwd{assign}\hlstd{(}\hlkwc{x} \hlstd{=} \hlstr{"temp"}\hlstd{,} \hlkwc{value} \hlstd{= _) |>}
\hlstd{_[}\hlkwd{names}\hlstd{(}\hlkwc{x} \hlstd{= temp)} \hlopt{==} \hlstr{"trkseg"}\hlstd{] |>}
\hlkwd{unlist}\hlstd{(}\hlkwc{x} \hlstd{= _,} \hlkwc{recursive} \hlstd{=} \hlnum{FALSE}\hlstd{) |>}
\hlkwd{map_df}\hlstd{(}\hlkwc{.x} \hlstd{= _,} \hlkwc{.f} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{x}\hlstd{)} \hlkwd{as_tibble}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{t}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{unlist}\hlstd{(}\hlkwc{x} \hlstd{= x))))}
\end{alltt}
\begin{verbatim}
## # A tibble: 199 x 7
##   time                     speed  name         type  fix   .attrs.lat .attrs.lon
##   <chr>                    <chr>  <chr>        <chr> <chr> <chr>      <chr>     
## 1 2018-12-08T23:09:02.000Z 0.0366 trkpt-2018-~ T     3d    -34.912071 138.660595
## 2 2018-12-08T23:09:04.000Z 0.0884 trkpt-2018-~ T     3d    -34.912067 138.660543
## 3 2018-12-08T23:09:06.000Z 0.0147 trkpt-2018-~ T     3d    -34.912102 138.660554
## # i 196 more rows
\end{verbatim}
\begin{alltt}
\hlkwd{rm}\hlstd{(temp)} \hlcom{# cleanup}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
  To understand what data transformation takes place in each statement of this pipe, start by running the first statement by itself, excluding the pipe operator, and continue adding one statement at a time, and at each step check the returned value and look out for what has changed from the previous step. Optionally you can insert a line \code{print() |>} at the point where you wish to see the data being ``piped''.
\end{playground}

\index{importing data!GPX files|)}

\section{Worksheets}\label{sec:files:worksheets}
\index{importing data!worksheets and workbooks|(}

Microsoft Office, Open Office and Libre Office are the most frequently used suites containing programs based on the worksheet paradigm. There is available a standardised file format for exchange of worksheet data, but it does not support all the features present in native file formats. We will start by considering \pgrmname{MS-Excel}. The file format used by \pgrmname{MS-Excel} has changed significantly over the years, and old formats tend to be less well supported by available \Rlang packages and may require the file to be updated to a more modern format with \pgrmname{MS-Excel} itself before import into \Rlang. The current format is based on XML and relatively simple to decode, whereas older binary formats are more difficult. Worksheets contain code as equations in addition to the actual data. In all cases, only values entered as such or those computed by means of the embedded equations can be imported into \Rlang rather than the equations themselves.

\begin{warningbox}
When directly reading from a worksheet, a column of cells with mixed type, can introduce \code{NA} values. A wrongly selected cell range from the worksheet can result in missing columns or rows, if the area is too small, or in rows or columns filled with \code{NA} values, if the range includes empty cells in the worksheet. Depending on the function used, it may be possible to ignore empty cells, by passing an argument.

Many problems related to the import of data from work sheets and work books are due to translation between two different formats that impose different restrictions on what is allowed or not. While in a worksheet it is allowed to set the ``format'' (as called in \pgrmname{Excel}, and roughly equivalent to \code{mode} in \Rlang) of individual cells, a variable (column) in an \Rlang data frame is expected to be vector, and thus contain members belonging the same \code{mode} or type. For the import to work as expected, the ``format'' must be consistent, i.e., all cells in a column to be imported are marked as one of the \code{Number}, \code{Date}, \code{Time} or \code{Text} formats, with the possible exception of a \emph{single row} of column headers with the names of the variables as \code{Text}. The default format \code{General} also works but as it does not ensure consistency, it makes more difficult to see format inconsistencies at a glance in Excel.

When reading a \code{CSV} file, text representing numbers will be recognised and converted, but only if the decimal point is encoded as expected from the arguments passed to the function call. So a single number with a comma instead of a dot as decimal marker (or vice versa) will result in most cases in the column not being decoded as numbers and returned as a \code{character} vector (or column) in the data frame. In the case of package \pkgname{readr} a \code{numeric} vector containing \code{NA} values for the non-decoded text may be returned instead of a \code{character} vector depending on whether the wrong decimal marker appears near the top or near the end of the file.

When importing data from a worksheet or workbook, my recommendation is first to check it in the original software to ensure that the cells to be imported are encoded as expected. When using a \code{CSV} as an intermediate step, it is crucial to also open this file in a plain-text editor such as the editor pane in \RStudio (or \pgrmname{Notepad} in \pgrmnameNI{Windows} or \pgrmname{Nano}, \pgrmname{Emacs}, etc., in \pgrmnameNI{Unix} and \pgrmnameNI{Linux}). Based on what field separator, decimal mark, and possibly character encoding has been used, which depends on the locale settings in the operating system of the computer and in the worksheet program, select a suitable function to call and the necessary arguments to pass to it.
\end{warningbox}

\subsection{CSV files as middlemen}

If we have access to the original software used for creating a worksheet or workbook, then exporting worksheets to text files in CSV format and importing them into \Rlang using the functions described in sections \ref{sec:files:txt} and \ref{sec:files:readr} starting on pages \pageref{sec:files:txt} and \pageref{sec:files:readr} provides a broadly compatible route for importing data---with the caveat that one must ensure that delimiters and decimal marks match the expectations of the functions used. This approach is not ideal from the perspective of having to create intermediate \code{CSV} formatted text files. A better approach is, when feasible, to import the data directly from the workbook or worksheets into \Rlang.

\subsection[\pkgnameNI{readxl}]{\pkgname{readxl}}\label{sec:files:excel}
\index{importing data!.xlsx files|(}\index{file formats!xlsx}



Package \pkgname{readxl} supports reading of \pgrmname{MS-Excel} workbooks, and selecting worksheets and regions within worksheets specified in ways similar to those used by \pgrmname{MS-Excel} itself. The interface is simple, and the package easy to install. We will import a file that in \pgrmname{MS-Excel} looks like the screen capture below.

\begin{center}
\includegraphics[width=0.75\textwidth]{figures/Book1-xlsx.png}
\end{center}

Function \Rfunction{excel\_sheets()} lists the sheets contained in the workbook.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{sheets} \hlkwb{<-} \hlkwd{excel_sheets}\hlstd{(}\hlstr{"extdata/Book1.xlsx"}\hlstd{)}
\hlstd{sheets}
\end{alltt}
\begin{verbatim}
## [1] "my data"
\end{verbatim}
\end{kframe}
\end{knitrout}

In this case, the argument passed to \code{sheet} is redundant, as there is only a single worksheet in the file. It is possible to use either the name of the sheet or a positional index (in this case \code{1} would be equivalent to \code{"my data"}). Function \Rfunction{read\_excel()} with no range specification imports the whole worksheet into a tibble, as can be expected from a package included in the \pkgname{tidyverse}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Book1.df} \hlkwb{<-} \hlkwd{read_excel}\hlstd{(}\hlstr{"extdata/Book1.xlsx"}\hlstd{,}
                       \hlkwc{sheet} \hlstd{=} \hlstr{"my data"}\hlstd{)}
\hlstd{Book1.df}
\end{alltt}
\begin{verbatim}
## # A tibble: 10 x 3
##   sample group observation
##    <dbl> <chr>       <dbl>
## 1      1 a               1
## 2      2 a               5
## 3      3 a               7
## # i 7 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

It is also possible to read a region instead of the whole worksheet.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Book1_region.df} \hlkwb{<-} \hlkwd{read_excel}\hlstd{(}\hlstr{"extdata/Book1.xlsx"}\hlstd{,}
                              \hlkwc{sheet} \hlstd{=} \hlstr{"my data"}\hlstd{,}
                              \hlkwc{range} \hlstd{=} \hlstr{"A1:B8"}\hlstd{)}
\hlstd{Book1_region.df}
\end{alltt}
\begin{verbatim}
## # A tibble: 7 x 2
##   sample group
##    <dbl> <chr>
## 1      1 a    
## 2      2 a    
## 3      3 a    
## # i 4 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

Of the remaining arguments, the most useful ones have the same names and play similar roles as in \pkgname{readr} (see section \ref{sec:files:readr} on page \pageref{sec:files:readr}). For example, new names for the columns can be passed as an argument to override the names in the worksheet.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Book1_region.df} \hlkwb{<-} \hlkwd{read_excel}\hlstd{(}\hlstr{"extdata/Book1.xlsx"}\hlstd{,}
                              \hlkwc{sheet} \hlstd{=} \hlstr{"my data"}\hlstd{,}
                              \hlkwc{range} \hlstd{=} \hlstr{"A2:B8"}\hlstd{,}
                              \hlkwc{col_names} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"A"}\hlstd{,} \hlstr{"B"}\hlstd{))}
\hlstd{Book1_region.df}
\end{alltt}
\begin{verbatim}
## # A tibble: 7 x 2
##       A B    
##   <dbl> <chr>
## 1     1 a    
## 2     2 a    
## 3     3 a    
## # i 4 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection[\pkgnameNI{xlsx}]{\pkgname{xlsx}}



Package \pkgname{xlsx} can be more difficult to install as it uses Java functions to do the actual work. However, it is more comprehensive, with functions both for reading and writing \pgrmname{MS-Excel} worksheets and workbooks, in different formats including the older binary ones. Similar to \pkgname{readr} it allows selected regions of a worksheet to be imported.

Function \Rfunction{read.xlsx()} can be used indexing the worksheet by name. The returned value is a data frame, and following the expectations of \Rlang package \pkgnameNI{utils}, character columns are \emph{no longer} converted into factors by default.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Book1_xlsx.df} \hlkwb{<-} \hlkwd{read.xlsx}\hlstd{(}\hlstr{"extdata/Book1.xlsx"}\hlstd{,}
                           \hlkwc{sheetName} \hlstd{=} \hlstr{"my data"}\hlstd{)}
\hlstd{Book1_xlsx.df}
\end{alltt}
\begin{verbatim}
##    sample group observation
## 1       1     a         1.0
## 2       2     a         5.0
## 3       3     a         7.0
## 4       4     a         2.0
## 5       5     a         5.0
## 6       6     b         0.0
## 7       7     b         2.0
## 8       8     b         3.0
## 9       9     b         1.0
## 10     10     b         1.5
\end{verbatim}
\begin{alltt}
\hlkwd{sapply}\hlstd{(Book1_xlsx.df, class)}
\end{alltt}
\begin{verbatim}
##      sample       group observation 
##   "numeric" "character"   "numeric"
\end{verbatim}
\end{kframe}
\end{knitrout}

With function \Rfunction{write.xlsx()} we can write data frames out to Excel worksheets and even append new worksheets to an existing workbook.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{456321}\hlstd{)}
\hlstd{my.data} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{x} \hlstd{=} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{y} \hlstd{= letters[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{])}
\hlkwd{write.xlsx}\hlstd{(my.data,}
           \hlkwc{file} \hlstd{=} \hlstr{"extdata/my-data.xlsx"}\hlstd{,}
           \hlkwc{sheetName} \hlstd{=} \hlstr{"first copy"}\hlstd{)}
\hlkwd{write.xlsx}\hlstd{(my.data,}
           \hlkwc{file} \hlstd{=} \hlstr{"extdata/my-data.xlsx"}\hlstd{,}
           \hlkwc{sheetName} \hlstd{=} \hlstr{"second copy"}\hlstd{,}
           \hlkwc{append} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

When opened in Excel, we get a workbook containing two worksheets, named using the arguments we passed through \code{sheetName} in the code chunk above.
% screen capture to be replaced!!
\begin{center}
\includegraphics[width=0.75\textwidth]{figures/my-data-xlsx.png}
\end{center}

\begin{playground}
If you have some worksheet files available, import them into \Rlang to get a feel for how data is organised in the worksheets affects how easy or difficult it is to import them into \Rlang.
\end{playground}
\index{importing data!.xlsx files|)}

\subsection[\pkgnameNI{readODS}]{\pkgname{readODS}}
\index{importing data!.ods files|(}\index{file formats!ODS}

Package \pkgname{readODS} provides functions for reading data saved in files that follow the \emph{Open Documents Standard}. Function \Rfunction{read\_ods()} has a similar user interface to that of \code{read\_excel()} and reads one worksheet at a time, with support only for skipping top rows and selecting ranges of columns and rows. The value returned is a tibble or, optionally, a data frame. Function \Rfunction{read\_fods()} reads flat ODS files.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{list_ods_sheets}\hlstd{(}\hlstr{"extdata/Book1.ods"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "my_data"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{ods.df} \hlkwb{<-} \hlkwd{read_ods}\hlstd{(}\hlstr{"extdata/Book1.ods"}\hlstd{,} \hlkwc{sheet} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{ods.df}
\end{alltt}
\begin{verbatim}
## # A tibble: 10 x 3
##   sample group observation
##    <dbl> <chr>       <dbl>
## 1      1 a               1
## 2      2 a               5
## 3      3 a               7
## # i 7 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

Functions \Rfunction{write\_ods()} and \Rfunction{write\_fods()} write a data frame into an ODS or FODS file.
\index{importing data!.ods files|)}
\index{importing data!worksheets and workbooks|)}

\section{Statistical Software}\label{sec:files:stat}
\index{importing data!other statistical software|(}

There are two different comprehensive packages for importing data saved from other statistical programs such as SAS, Statistica, SPSS, etc. The longtime ``standard'' is package \pkgname{foreign} included in base \Rlang, and package \pkgname{haven} is a newer contributed extension. In the case of files saved with old versions of statistical programs, functions from \pkgname{foreign} tend to be more robust than those from \pkgname{haven}.

\subsection[\pkgnameNI{foreign}]{\pkgname{foreign}}



Functions\index{importing data!from SAS}\index{importing data!from Stata}\index{importing data!from SPSS}\index{importing data!from Systat} in package \pkgname{foreign} allow us to import data from files saved by several statistical analysis programs, including \pgrmname{SAS}, \pgrmname{Stata}, \pgrmname{SPSS}, \pgrmname{Systat}, \pgrmname{Octave} among others, and a function for writing data into files with formats native to \pgrmname{SAS}, \pgrmname{Stata}, and \pgrmname{SPSS}. \Rlang documents the use of these functions in detail in the \emph{R Data Import/Export} manual. As a simple example, we use function \Rfunction{read.spss()} to read a \texttt{.sav} file, saved a few years ago with the then current version of \pgrmname{SPSS}. Only the first six rows and seven columns of the data frame are shown, including a column with dates, which appears as numeric.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_spss.df} \hlkwb{<-} \hlkwd{read.spss}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/my-data.sav"}\hlstd{,} \hlkwc{to.data.frame} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{my_spss.df[}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlnum{17}\hlstd{)]}
\end{alltt}
\begin{verbatim}
##   block       treat mycotreat water1 pot harvest harvest_date
## 1     0 Watered, EM         1      1  14       1  13653705600
## 2     0 Watered, EM         1      1  52       1  13653705600
## 3     0 Watered, EM         1      1 111       1  13653705600
## 4     0 Watered, EM         1      1 127       1  13653705600
## 5     0 Watered, EM         1      1 230       1  13653705600
## 6     0 Watered, EM         1      1 258       1  13653705600
\end{verbatim}
\end{kframe}
\end{knitrout}

A second example, this time with a simple \code{.sav} file saved 15 years ago.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{thiamin.df} \hlkwb{<-} \hlkwd{read.spss}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/thiamin.sav"}\hlstd{,} \hlkwc{to.data.frame} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{head}\hlstd{(thiamin.df)}
\end{alltt}
\begin{verbatim}
##   THIAMIN CEREAL
## 1     5.2  wheat
## 2     4.5  wheat
## 3     6.0  wheat
## 4     6.1  wheat
## 5     6.7  wheat
## 6     5.8  wheat
\end{verbatim}
\end{kframe}
\end{knitrout}

Another example, for a \pgrmname{Systat} file saved on an PC more than 20 years ago, and read with \Rfunction{read.systat()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_systat.df} \hlkwb{<-} \hlkwd{read.systat}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/BIRCH1.SYS"}\hlstd{)}
\hlkwd{head}\hlstd{(my_systat.df)}
\end{alltt}
\begin{verbatim}
##   CONT DENS BLOCK SEEDL VITAL BASE ANGLE HEIGHT DIAM
## 1    1    1     1     2    44    2     0      1   53
## 2    1    1     1     2    41    2     1      2   70
## 3    1    1     1     2    21    2     0      1   65
## 4    1    1     1     2    15    3     0      1   79
## 5    1    1     1     2    37    3     0      1   71
## 6    1    1     1     2    29    2     1      1   43
\end{verbatim}
\end{kframe}
\end{knitrout}

Not all functions in \pkgname{foreign} return data frames by default, but all of them can be coerced to do so.

\subsection[\pkgnameNI{haven}]{\pkgname{haven}}



Package \pkgname{haven} is less ambitious with respect to the number of formats supported, or their vintages, providing read and write functions for only three file formats: \pgrmname{SAS}, \pgrmname{Stata} and \pgrmname{SPSS}. On the other hand, \pkgname{haven} provides flexible ways to convert the different labelled values that cannot be directly mapped to \Rlang modes. They also decode dates and times according to the idiosyncrasies of each of these file formats. In cases when the imported file contains labelled values the returned \Rclass{tibble} object needs some additional attention from the user. Labelled numeric columns in \pgrmname{SPSS} are not necessarily equivalent to factors, although they sometimes are. Consequently, conversion to factors cannot be automated and must be done manually in a separate step.

Function \Rfunction{read\_sav()} can be used to import a \code{.sav} file saved by a recent version of \pgrmname{SPSS}. As in the previous section, we display only the first six rows and seven columns of the data frame, including a column \code{treat} containing a labelled numeric vector and \code{harvest\_date} with dates encoded as \Rlang date values.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{my_spss.tb} \hlkwb{<-} \hlkwd{read_sav}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/my-data.sav"}\hlstd{)}
\hlstd{my_spss.tb[}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwd{c}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{6}\hlstd{,} \hlnum{17}\hlstd{)]}
\end{alltt}
\begin{verbatim}
## # A tibble: 6 x 7
##   block treat           mycotreat water1   pot harvest harvest_date
##   <dbl> <dbl+lbl>           <dbl>  <dbl> <dbl>   <dbl> <date>      
## 1     0 1 [Watered, EM]         1      1    14       1 2015-06-15  
## 2     0 1 [Watered, EM]         1      1    52       1 2015-06-15  
## 3     0 1 [Watered, EM]         1      1   111       1 2015-06-15  
## # i 3 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

In this case, the dates are correctly decoded.

Next, we import an \pgrmname{SPSS}'s \code{.sav} file saved 15 years ago.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{thiamin.tb} \hlkwb{<-} \hlkwd{read_sav}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"extdata/thiamin.sav"}\hlstd{)}
\hlstd{thiamin.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 24 x 2
##   THIAMIN CEREAL   
##     <dbl> <dbl+lbl>
## 1     5.2 1 [wheat]
## 2     4.5 1 [wheat]
## 3     6   1 [wheat]
## # i 21 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{thiamin.tb} \hlkwb{<-} \hlkwd{as_factor}\hlstd{(thiamin.tb)}
\hlstd{thiamin.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 24 x 2
##   THIAMIN CEREAL
##     <dbl> <fct> 
## 1     5.2 wheat 
## 2     4.5 wheat 
## 3     6   wheat 
## # i 21 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Compare the values returned by different \code{read} functions when applied to the same file on disk. Use \Rfunction{names()}, \Rfunction{str()} and \Rfunction{class()} as tools in your exploration. If you are brave, also use \Rfunction{attributes()}, \Rfunction{mode()}, \Rfunction{dim()}, \Rfunction{dimnames()}, \Rfunction{nrow()} and \Rfunction{ncol()}.
\end{playground}

\begin{playground}
If you use or have in the past used other statistical software or a general-purpose language like \langname{Python}, look for some old files and import them into \Rlang.
\end{playground}
\index{importing data!other statistical software|)}

\section{NetCDF Files}\label{sec:dataio:netcdf}
\index{importing data!NeCDF files|(}\index{file formats!NetCDF}

In some fields, including geophysics and meteorology, \pgrmname{NetCDF} is a very common format for the exchange of data. It is also used in other contexts in which data are referenced to a grid of locations, like with data read from Affymetrix microarrays used to study gene expression. \pgrmname{NetCDF} files are binary but use a format that allows the storage of metadata describing each variable together with the data itself in a well-organised and standardised format, which is ideal for exchange of moderately large data sets measured on a spatial or spatio-temporal grid.

Officially described as follows:
\begin{quote}
\pgrmname{NetCDF} is a set of software libraries [from Unidata] and self-describing, machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
\end{quote}

That \pgrmname{NetCDF} files be selectively read, extracting the data from individual variables, is important as it allows computations in \Rlang with data sets too big to fit in a computer's RAM. Selective reading is possible using functions from packages \pkgname{ncdf4} or \pkgname{RNetCDF}. As a consequence of this flexibility, contrary to other data file reading operations, reading a \pgrmname{NetCDF} file is done in multiple steps---i.e., opening the file, reading metadata describing the variables and spatial grid, and finally selectively reading the data of interest.

\subsection[\pkgnameNI{ncdf4}]{\pkgname{ncdf4}}



Package \pkgname{ncdf4} supports reading of files using \pgrmname{NetCDF} version 4 or earlier formats. Functions in \pkgname{ncdf4} not only allow reading and writing of these files, but also their modification.

Below, first file \code{pevpr.sfc.mon.ltm.nc}, containing meteorological data, is opened with function \Rfunction{nc\_open()}. The object returned is saved to \code{meteo\_data.nc}. This object contains only an index to the file contents, whose structure is displayed with a call to \code{str()}, it plays the role of a file connection.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{meteo_data.nc} \hlkwb{<-} \hlkwd{nc_open}\hlstd{(}\hlstr{"extdata/pevpr.sfc.mon.ltm.nc"}\hlstd{)}
\hlkwd{str}\hlstd{(meteo_data.nc,} \hlkwc{max.level} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\begin{verbatim}
## List of 15
##  $ filename   : chr "extdata/pevpr.sfc.mon.ltm.nc"
##  $ writable   : logi FALSE
##  $ id         : int 65536
##  $ error      : logi FALSE
##  $ safemode   : logi FALSE
##  $ format     : chr "NC_FORMAT_NETCDF4_CLASSIC"
##  $ is_GMT     : logi FALSE
##  $ groups     :List of 1
##  $ fqgn2Rindex:List of 1
##  $ ndims      : num 4
##  $ natts      : num 8
##  $ dim        :List of 4
##  $ unlimdimid : num -1
##  $ nvars      : num 3
##  $ var        :List of 3
##  - attr(*, "class")= chr "ncdf4"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{advplayground}
Increase \code{max.level} in the call to \Rfunction{str()} above and study how the connection object stores information on the dimensions and for each data variable. You can also \code{print(meteo\_data.nc)} for a more complete printout once you have understood the structure of the object.
\end{advplayground}

The dimensions of the data array are stored as metadata, in the file used mapping indexes to a grid of latitudes and longitudes and into a time vector as a third dimension. The dates are returned as character strings. The variables describing the grid are read one at a time with function \Rfunction{ncvar\_get()}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{time.vec} \hlkwb{<-} \hlkwd{ncvar_get}\hlstd{(meteo_data.nc,} \hlstr{"time"}\hlstd{)}
\hlkwd{head}\hlstd{(time.vec)}
\end{alltt}
\begin{verbatim}
## [1] -657073 -657042 -657014 -656983 -656953 -656922
\end{verbatim}
\begin{alltt}
\hlstd{longitude} \hlkwb{<-}  \hlkwd{ncvar_get}\hlstd{(meteo_data.nc,} \hlstr{"lon"}\hlstd{)}
\hlkwd{head}\hlstd{(longitude)}
\end{alltt}
\begin{verbatim}
## [1] 0.000 1.875 3.750 5.625 7.500 9.375
\end{verbatim}
\begin{alltt}
\hlstd{latitude} \hlkwb{<-} \hlkwd{ncvar_get}\hlstd{(meteo_data.nc,} \hlstr{"lat"}\hlstd{)}
\hlkwd{head}\hlstd{(latitude)}
\end{alltt}
\begin{verbatim}
## [1] 88.5420 86.6531 84.7532 82.8508 80.9473 79.0435
\end{verbatim}
\end{kframe}
\end{knitrout}
\pagebreak

The \code{time} vector contains only monthly values as the file contains a long-term series of monthly averages, expressed as days from 1800-01-01 corresponding to the first day of each month of year "1". We use package \pkgname{lubridate} for the conversion. To find the indexes for the grid point of interest, it is necessary to study the vectors \code{longitude} and \code{latitude} saved above.

Next the potential evapotranspiration is read for one grid point, and used to construct a data frame, with some values recycled.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pet.tb} \hlkwb{<-}
    \hlkwd{tibble}\hlstd{(}\hlkwc{time} \hlstd{= time.vec,}
           \hlkwc{month} \hlstd{=} \hlkwd{month}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"1800-01-01"}\hlstd{)} \hlopt{+} \hlkwd{days}\hlstd{(time)),}
           \hlkwc{lon} \hlstd{= longitude[}\hlnum{6}\hlstd{],}
           \hlkwc{lat} \hlstd{= latitude[}\hlnum{2}\hlstd{],}
           \hlkwc{pet} \hlstd{=} \hlkwd{ncvar_get}\hlstd{(meteo_data.nc,} \hlstr{"pevpr"}\hlstd{)[}\hlnum{6}\hlstd{,} \hlnum{2}\hlstd{, ]}
           \hlstd{)}
\hlstd{pet.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 12 x 5
##        time month   lon   lat   pet
##   <dbl[1d]> <dbl> <dbl> <dbl> <dbl>
## 1   -657073    12  9.38  86.7  4.28
## 2   -657042     1  9.38  86.7  5.72
## 3   -657014     2  9.38  86.7  4.38
## # i 9 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

To to read in several grid points, several different approaches are available. However, the order of nesting of dimensions can make adding the dimensions as columns error prone. It is much simpler to use package \pkgnameNI{tidync} described next.

\subsection[\pkgnameNI{tidync}]{\pkgname{tidync}}



Package \pkgname{tidync} provides functions that make it easy to extract subsets of the data from an \pgrmname{NetCDF} file. The initial steps are the  same operations as in the examples for \pkgnameNI{ncdf4}.

Function \Rfunction{tidync()} is used to open the file and simultaneously activate the first grid. The returned object is saved as \code{meteo\_data.tnc}. This object is subsequently used to access the file, and when printed displays a summary of the file structure and data encoding.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{meteo_data.tnc} \hlkwb{<-} \hlkwd{tidync}\hlstd{(}\hlstr{"extdata/pevpr.sfc.mon.ltm.nc"}\hlstd{)}
\hlstd{meteo_data.tnc}
\end{alltt}
\begin{verbatim}
## 
## Data Source (1): pevpr.sfc.mon.ltm.nc ...
## 
## Grids (5) <dimension family> : <associated variables> 
## 
## [1]   D0,D1,D2 : pevpr, valid_yr_count    **ACTIVE GRID** ( 216576  values per variable)
## [2]   D3,D2    : climatology_bounds
## [3]   D0       : lon
## [4]   D1       : lat
## [5]   D2       : time
## 
## Dimensions 4 (3 active): 
##   
##   dim   name  length     min     max start count    dmin    dmax unlim coord_dim 
##   <chr> <chr>  <dbl>   <dbl>   <dbl> <int> <int>   <dbl>   <dbl> <lgl> <lgl>     
## 1 D0    lon      192  0       3.58e2     1   192  0       3.58e2 FALSE TRUE      
## 2 D1    lat       94 -8.85e1  8.85e1     1    94 -8.85e1  8.85e1 FALSE TRUE      
## 3 D2    time      12 -6.57e5 -6.57e5     1    12 -6.57e5 -6.57e5 FALSE TRUE      
##   
## Inactive dimensions:
##   
##   dim   name  length   min   max unlim coord_dim 
##   <chr> <chr>  <dbl> <dbl> <dbl> <lgl> <lgl>     
## 1 D3    nbnds      2     1     2 FALSE FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{hyper\_dims()} returns a description of the grid for which observations are available.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hyper_dims}\hlstd{(meteo_data.tnc)}
\end{alltt}
\begin{verbatim}
## # A tibble: 3 x 7
##   name  length start count    id unlim coord_dim
##   <chr>  <dbl> <int> <int> <int> <lgl> <lgl>    
## 1 lon      192     1   192     0 FALSE TRUE     
## 2 lat       94     1    94     1 FALSE TRUE     
## 3 time      12     1    12     2 FALSE TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{hyper\_vars()} returns a description of the observations or variables available at each grid point.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hyper_vars}\hlstd{(meteo_data.tnc)}
\end{alltt}
\begin{verbatim}
## # A tibble: 2 x 6
##      id name           type     ndims natts dim_coord
##   <int> <chr>          <chr>    <int> <int> <lgl>    
## 1     4 pevpr          NC_FLOAT     3    14 FALSE    
## 2     5 valid_yr_count NC_FLOAT     3     4 FALSE
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{hyper\_tibble()} extracts a subset of the data into a tibble in long (or tidy) format. The selection of the grid point is done in the same operation and in this case using \code{signif()} to test for an approximate match to actual longitude and latitude values. A pipe is used to add the decoded dates, using the pipe operator (\code{|>}) and methods from \pkgname{dplyr} (see section \ref{sec:dplyr:group:wise} on page \pageref{sec:dplyr:group:wise}). The decoding of dates is done using functions from package \pkgname{lubridate} (see section \ref{sec:data:datetime} on page \pageref{sec:data:datetime}).

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hyper_tibble}\hlstd{(meteo_data.tnc,}
             \hlkwc{lon} \hlstd{=} \hlkwd{signif}\hlstd{(lon,} \hlnum{1}\hlstd{)} \hlopt{==} \hlnum{9}\hlstd{,}
             \hlkwc{lat} \hlstd{=} \hlkwd{signif}\hlstd{(lat,} \hlnum{2}\hlstd{)} \hlopt{==} \hlnum{87}\hlstd{) |>}
  \hlkwd{mutate}\hlstd{(}\hlkwc{.data} \hlstd{= _,} \hlkwc{month} \hlstd{=} \hlkwd{month}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"1800-01-01"}\hlstd{)} \hlopt{+} \hlkwd{days}\hlstd{(time))) |>}
  \hlkwd{select}\hlstd{(}\hlkwc{.data} \hlstd{= _,} \hlopt{-}\hlstd{time)}
\end{alltt}
\begin{verbatim}
## # A tibble: 12 x 5
##   pevpr valid_yr_count   lon   lat month
##   <dbl>          <dbl> <dbl> <dbl> <dbl>
## 1  4.28       1.19e-39  9.38  86.7    12
## 2  5.72       1.19e-39  9.38  86.7     1
## 3  4.38       1.29e-39  9.38  86.7     2
## # i 9 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

In this second example, data is extracted for all grid points along latitudes by omitting the test for \code{lat} from the chunk above. The tibble is assembled automatically and columns for the active dimensions added. The decoding of the months remains the same as above.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hyper_tibble}\hlstd{(meteo_data.tnc,}
             \hlkwc{lon} \hlstd{=} \hlkwd{signif}\hlstd{(lon,} \hlnum{1}\hlstd{)} \hlopt{==} \hlnum{9}\hlstd{) |>}
  \hlkwd{mutate}\hlstd{(}\hlkwc{.data} \hlstd{= _,} \hlkwc{month} \hlstd{=} \hlkwd{month}\hlstd{(}\hlkwd{ymd}\hlstd{(}\hlstr{"1800-01-01"}\hlstd{)} \hlopt{+} \hlkwd{days}\hlstd{(time))) |>}
  \hlkwd{select}\hlstd{(}\hlkwc{.data} \hlstd{= _,} \hlopt{-}\hlstd{time)}
\end{alltt}
\begin{verbatim}
## # A tibble: 1,128 x 5
##   pevpr valid_yr_count   lon   lat month
##   <dbl>          <dbl> <dbl> <dbl> <dbl>
## 1  1.02       1.19e-39  9.38  88.5    12
## 2  4.28       1.19e-39  9.38  86.7    12
## 3  3.03       9.18e-40  9.38  84.8    12
## # i 1,125 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{playground}
Instead of extracting data for one longitude across latitudes, extract data across longitudes for one latitude near the Equator.
\end{playground}
\index{importing data!NeCDF files|)}

\section{Remotely Located Data}\label{sec:files:remote}
\index{importing data!remote connections|(}

Many\index{importing data!remotely}\index{importing data!using URL}\index{files!downloading} of the functions described above accept an URL address in place of a file name. Consequently files can be read remotely without having to first download and save a copy in the local file system. This can be useful, especially when file names are generated within a script. However, one should avoid, especially in the case of servers open to public access, repeatedly downloading the same file as this unnecessarily increases network traffic and workload on the remote server. Because of this, our first example reads a small file from my own web site. See section \ref{sec:files:txt} on page \pageref{sec:files:txt} for details on the use of these and other functions for reading text files.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{logger.df} \hlkwb{<-}
      \hlkwd{read.csv2}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"http://r4photobiology.info/learnr/logger_1.txt"}\hlstd{,}
                \hlkwc{header} \hlstd{=} \hlnum{FALSE}\hlstd{,}
                \hlkwc{col.names} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"time"}\hlstd{,} \hlstr{"temperature"}\hlstd{))}
\hlkwd{sapply}\hlstd{(logger.df, class)}
\end{alltt}
\begin{verbatim}
##        time temperature 
## "character"   "numeric"
\end{verbatim}
\end{kframe}
\end{knitrout}

While functions in package \pkgname{readr} support the use of URLs, those in packages \pkgname{readxl} and \pkgname{xlsx} do not. Consequently, the file has to be first downloaded and saved locally, and subsequently imported as described in section \ref{sec:files:excel} on page \pageref{sec:files:excel}. Function \Rfunction{download.file()} in the \Rlang \pkgname{utils} package can be used to download files using URLs. It supports different modes such as binary or text for the contents, and write or append for the local file, and different methods such as \code{"internal"}, \code{"wget"} and \code{"libcurl"}.

\begin{warningbox}
For portability, \pgrmname{MS-Excel} files should be downloaded in binary mode, setting \code{mode = "wb"}, which is required under \osname{MS-Windows}.
\end{warningbox}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{download.file}\hlstd{(}\hlstr{"http://r4photobiology.info/learnr/my-data.xlsx"}\hlstd{,}
              \hlstr{"data/my-data-dwn.xlsx"}\hlstd{,}
              \hlkwc{mode} \hlstd{=} \hlstr{"wb"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\pagebreak

Functions in package \pkgname{foreign}, as well as those in package \pkgname{haven}, support URLs. See section \ref{sec:files:stat} on page \pageref{sec:files:stat} for more information about importing this kind of data into \Rlang.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{remote_thiamin.df} \hlkwb{<-}
  \hlkwd{read.spss}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"http://r4photobiology.info/learnr/thiamin.sav"}\hlstd{,}
            \hlkwc{to.data.frame} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{head}\hlstd{(remote_thiamin.df)}
\end{alltt}
\begin{verbatim}
##   THIAMIN CEREAL
## 1     5.2  wheat
## 2     4.5  wheat
## 3     6.0  wheat
## 4     6.1  wheat
## 5     6.7  wheat
## 6     5.8  wheat
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{remote_my_spss.tb} \hlkwb{<-}
    \hlkwd{read_sav}\hlstd{(}\hlkwc{file} \hlstd{=} \hlstr{"http://r4photobiology.info/learnr/thiamin.sav"}\hlstd{)}
\hlstd{remote_my_spss.tb}
\end{alltt}
\begin{verbatim}
## # A tibble: 24 x 2
##   THIAMIN CEREAL   
##     <dbl> <dbl+lbl>
## 1     5.2 1 [wheat]
## 2     4.5 1 [wheat]
## 3     6   1 [wheat]
## # i 21 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

In this example we use a downloaded NetCDF file of long-term means for potential evapotranspiration from NOOA, the same used above in the \pkgname{ncdf4} example. This is a moderately large file at 444~KB. In this case, it is no possible to directly open the connection to the NetCDF file, and it has to be downloaded. The \code{if} statement ensures that the file is downloaded only if the local copy is missing (to refresh the local copy simply delete the existing one). Once downloaded, the file can be opened as in section \ref{sec:dataio:netcdf} on page \pageref{sec:dataio:netcdf}.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{file.exists}\hlstd{(}\hlstr{"extdata/pevpr.sfc.mon.ltm.nc"}\hlstd{)) \{}
  \hlstd{my.url} \hlkwb{<-} \hlkwd{paste}\hlstd{(}\hlstr{"ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis.derived/"}\hlstd{,}
                  \hlstr{"surface_gauss/pevpr.sfc.mon.ltm.nc"}\hlstd{,}
                  \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{)}
  \hlkwd{download.file}\hlstd{(my.url,}
                \hlkwc{mode} \hlstd{=} \hlstr{"wb"}\hlstd{,}
                \hlkwc{destfile} \hlstd{=} \hlstr{"extdata/pevpr.sfc.mon.ltm.nc"}\hlstd{)}
\hlstd{\}}
\hlstd{pet_ltm.nc} \hlkwb{<-} \hlkwd{nc_open}\hlstd{(}\hlstr{"extdata/pevpr.sfc.mon.ltm.nc"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{warningbox}
For portability, \pgrmname{NetCDF} files should be downloaded in binary mode, setting \code{mode = "wb"}, which is required under \osname{MS-Windows}.
\end{warningbox}
\index{importing data!remote connections|)}

\begin{warningbox}
  Some NetCDF file servers support the OPeNDAP protocol. In these servers it is possible to open the files remotely, and only download a part of the file. Function \Rfunction{open.nc()} from package \pkgname{RNetCDF} transparently supports OPeNDAP URLs.
\end{warningbox}

\section{Databases}\label{sec:data:db}
\index{importing data!databases|(}






One of the advantages of using databases is that subsets of cases and variables can be retrieved, even remotely, making it possible to work in \Rlang both locally and remotely with huge data sets. One should remember that \Rlang natively keeps whole objects in RAM, and consequently, available machine memory limits the size of data sets with which it is possible to work. Package \pkgname{dbplyr} provides the tools to work with data in databases using the same verbs as when using \pkgname{dplyr} with data stored in memory (RAM) (see chapter \ref{chap:R:data}). This is an important subject, but extensive enough to be outside the scope of this book. We provide a few simple examples to show the very basics but interested readers should consult \citebooktitle{Wickham2023a} \autocite{Wickham2023a}.

The additional steps compared to using \pkgname{dplyr} start with the need to establish a connection to a local or remote database. We will use \Rlang package \pkgname{RSQLite} to create a local temporary \pgrmname{SQLite} database. \pkgname{dbplyr} backends supporting other database systems are also available. We will use meteorological data from \pkgname{learnrbook} for this example.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(dplyr)}
\hlstd{con} \hlkwb{<-} \hlstd{DBI}\hlopt{::}\hlkwd{dbConnect}\hlstd{(RSQLite}\hlopt{::}\hlkwd{SQLite}\hlstd{(),} \hlkwc{dbname} \hlstd{=} \hlstr{":memory:"}\hlstd{)}
\hlkwd{copy_to}\hlstd{(con, weather_wk_25_2019.tb,} \hlstr{"weather"}\hlstd{,}
        \hlkwc{temporary} \hlstd{=} \hlnum{FALSE}\hlstd{,}
        \hlkwc{indexes} \hlstd{=} \hlkwd{list}\hlstd{(}
          \hlkwd{c}\hlstd{(}\hlstr{"month_name"}\hlstd{,} \hlstr{"calendar_year"}\hlstd{,} \hlstr{"solar_time"}\hlstd{),}
          \hlstr{"time"}\hlstd{,}
          \hlstr{"sun_elevation"}\hlstd{,}
          \hlstr{"was_sunny"}\hlstd{,}
          \hlstr{"day_of_year"}\hlstd{,}
          \hlstr{"month_of_year"}
        \hlstd{)}
\hlstd{)}
\hlstd{weather.db} \hlkwb{<-} \hlkwd{tbl}\hlstd{(con,} \hlstr{"weather"}\hlstd{)}
\hlkwd{colnames}\hlstd{(weather.db)}
\end{alltt}
\begin{verbatim}
##  [1] "time"           "PAR_umol"       "PAR_diff_fr"    "global_watt"   
##  [5] "day_of_year"    "month_of_year"  "month_name"     "calendar_year" 
##  [9] "solar_time"     "sun_elevation"  "sun_azimuth"    "was_sunny"     
## [13] "wind_speed"     "wind_direction" "air_temp_C"     "air_RH"        
## [17] "air_DP"         "air_pressure"   "red_umol"       "far_red_umol"  
## [21] "red_far_red"
\end{verbatim}
\begin{alltt}
\hlstd{weather.db |>}
  \hlkwd{filter}\hlstd{(}\hlkwc{.data} \hlstd{= _, sun_elevation} \hlopt{>} \hlnum{5}\hlstd{) |>}
  \hlkwd{group_by}\hlstd{(}\hlkwc{.data} \hlstd{= _, day_of_year) |>}
  \hlkwd{summarise}\hlstd{(}\hlkwc{.data} \hlstd{= _,} \hlkwc{energy_Wh} \hlstd{=} \hlkwd{sum}\hlstd{(global_watt,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)} \hlopt{*} \hlnum{60} \hlopt{/} \hlnum{3600}\hlstd{)}
\end{alltt}
\begin{verbatim}
## # Source:   SQL [?? x 2]
## # Database: sqlite 3.45.0 [:memory:]
##   day_of_year energy_Wh
##         <dbl>     <dbl>
## 1         162     7500.
## 2         163     6660.
## 3         164     3958.
## # i more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Package \pkgname{dbplyr} translates data pipes that use \pkgname{dplyr} syntax into SQL queries to databases, either local or remote. As long as there are no problems with the backend, the use of a database is almost transparent to the \Rlang user.
\end{explainbox}
\index{importing data!databases|)}

\begin{explainbox}
It is always good to clean up, and in the case of the book, the best way to test that the examples
can be run in a ``clean'' system.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{unlink}\hlstd{(}\hlstr{"./data"}\hlstd{,} \hlkwc{recursive} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{unlink}\hlstd{(}\hlstr{"./extdata"}\hlstd{,} \hlkwc{recursive} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{explainbox}

\section{Data Acquisition from Physical Devices}\label{sec:data:acquisition}
\index{importing data!physical devices|(}\index{file formats!JSON}

Numerous\index{internet-of-things} modern data acquisition devices based on microcontrollers, including internet-of-things (IoT) devices, have servers (or daemons) that can be queried over a network connection to retrieve either real-time or logged data. Formats based on XML schemas or the JSON format are commonly used for data.

\subsection[\pkgnameNI{jsonlite}]{\pkgname{jsonlite}}



\index{importing data!jsonlite}\index{YoctoPuce modules}
The next example retrieves data from USB module from \href{http://www.yoctopuce.com/}{YoctoPuce} using a software hub running locally. The module used in this example is a YoctoMeteo.

\begin{warningbox}
This example needs enabling data recording in the YoctoPuce module, collecting data and replacing in the call to function \Rfunction{fromJSON()} \code{"C1-Meteo"} by the ID assigned to the module used. The example uses a Yocto VirtualHub running locally and listening at port 4444, the default. The same code can be used over the network by editing the string saved in \code{hub.url}.
\end{warningbox}

Function \Rfunction{fromJSON()} from package \pkgname{jsonlite} retrieves logged data from one sensor.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hub.url} \hlkwb{<-} \hlstr{"http://localhost:4444/"}
\hlstd{Meteo01.df} \hlkwb{<-}
    \hlkwd{fromJSON}\hlstd{(}\hlkwd{paste}\hlstd{(hub.url,} \hlstr{"byName/C1-Meteo/dataLogger.json"}\hlstd{,}
                   \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{),} \hlkwc{flatten} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{str}\hlstd{(Meteo01.df,} \hlkwc{max.level} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 'data.frame':	3 obs. of  4 variables:
##  $ id     : chr  "humidity" "pressure" "temperature"
##  $ unit   : chr  "g/m3" "mbar" "'C"
##  $ calib  : chr  "0," "0," "0,"
##  $ streams:List of 3
##   ..$ :'data.frame':	436 obs. of  5 variables:
##   ..$ :'data.frame':	433 obs. of  5 variables:
##   ..$ :'data.frame':	436 obs. of  5 variables:
\end{verbatim}
\end{kframe}
\end{knitrout}

The minimum, mean, and maximum values for each logging interval need to be split from a single vector. We do this by indexing with a logical vector (recycled). The data returned is in long form, with quantity names and units also returned by the module, as well as the time.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Meteo01.df[[}\hlstr{"streams"}\hlstd{]][[}\hlkwd{which}\hlstd{(Meteo01.df}\hlopt{$}\hlstd{id} \hlopt{==} \hlstr{"temperature"}\hlstd{)]] |>}
  \hlkwd{as_tibble}\hlstd{(}\hlkwc{x} \hlstd{= _) |>}
  \hlstd{dplyr}\hlopt{::}\hlkwd{transmute}\hlstd{(}\hlkwc{.data} \hlstd{= _,}
                   \hlkwc{utc.time} \hlstd{=} \hlkwd{as.POSIXct}\hlstd{(utc,} \hlkwc{origin} \hlstd{=} \hlstr{"1970-01-01"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"UTC"}\hlstd{),}
                   \hlkwc{t_min} \hlstd{=} \hlkwd{unlist}\hlstd{(val)[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{)],}
                   \hlkwc{t_mean} \hlstd{=} \hlkwd{unlist}\hlstd{(val)[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)],}
                   \hlkwc{t_max} \hlstd{=} \hlkwd{unlist}\hlstd{(val)[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{)])} \hlkwb{->} \hlstd{temperature.df}

\hlstd{Meteo01.df[[}\hlstr{"streams"}\hlstd{]][[}\hlkwd{which}\hlstd{(Meteo01.df}\hlopt{$}\hlstd{id} \hlopt{==} \hlstr{"humidity"}\hlstd{)]] |>}
  \hlkwd{as_tibble}\hlstd{(}\hlkwc{x} \hlstd{= _) |>}
  \hlstd{dplyr}\hlopt{::}\hlkwd{transmute}\hlstd{(}\hlkwc{.data} \hlstd{= _,}
                   \hlkwc{utc.time} \hlstd{=} \hlkwd{as.POSIXct}\hlstd{(utc,} \hlkwc{origin} \hlstd{=} \hlstr{"1970-01-01"}\hlstd{,} \hlkwc{tz} \hlstd{=} \hlstr{"UTC"}\hlstd{),}
                   \hlkwc{hr_min} \hlstd{=} \hlkwd{unlist}\hlstd{(val)[}\hlkwd{c}\hlstd{(}\hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{)],}
                   \hlkwc{hr_mean} \hlstd{=} \hlkwd{unlist}\hlstd{(val)[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{,} \hlnum{FALSE}\hlstd{)],}
                   \hlkwc{hr_max} \hlstd{=} \hlkwd{unlist}\hlstd{(val)[}\hlkwd{c}\hlstd{(}\hlnum{FALSE}\hlstd{,} \hlnum{FALSE}\hlstd{,} \hlnum{TRUE}\hlstd{)])} \hlkwb{->} \hlstd{humidity.df}

\hlkwd{full_join}\hlstd{(temperature.df, humidity.df)}
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Joining with `by = join\_by(utc.time)`}}\begin{verbatim}
## # A tibble: 114 x 7
##   utc.time            t_min t_mean t_max hr_min hr_mean hr_max
##   <dttm>              <dbl>  <dbl> <dbl>  <dbl>   <dbl>  <dbl>
## 1 2023-10-15 18:06:00  26.1   26.1  26.3   10.4    10.5   10.6
## 2 2023-10-15 19:00:00  25.8   26.0  26.1   10.5    10.7   10.8
## 3 2023-10-15 20:00:00  25.7   26.0  26.0   10.6    10.8   10.9
## # i 111 more rows
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{explainbox}
Most YoctoPuce input modules have a built-in datalogger, and the stored data can also be downloaded as a \code{CSV} file through a physical or virtual hub. As shown above, it is possible to control them through the HTML server in the physical or virtual hubs. Alternatively the \Rlang package \pkgname{reticulate} can be used to control YoctoPuce modules by means of the \langname{Python} library giving access to their full API.
\end{explainbox}
\index{importing data!physical devices|)}

\section{Further Reading}

\Rpgrm includes the manual "R Data Import/Export", a very useful reference.

Since\index{further reading!elegant R code}\index{further reading!idiosyncracies or R} this is the end of the book, I recommend as further reading the writings of \citeauthor{Burns1998} as they are full of insight. Having arrived at the end of \emph{Learn R: As a Language} you should read \citebooktitle{Burns1998} \autocite{Burns1998} and \citebooktitle{Burns2012} \autocite{Burns2012}. If you want to never get caught unaware by \Rlang's idiosyncrasies, read also \citebooktitle{Burns2011} \autocite{Burns2011}.





\backmatter

\printbibliography

\printindex\label{idx:general}

\printindex[rindex]\label{idx:rindex}

\indexprologue{\noindent\Rlang names and symbols grouped into the categories `classes and modes', `constant and special values', 
`control of execution', `data objects', `functions and methods', `names and their scope', and `operators'.} 
\printindex[rcatsidx]\label{idx:rcats}

\indexprologue{Frequently asked questions and their answers appear in the body of the book preceded by the icon \faqicon 
and highlighted by a marginal bar of the same colour as the icon.}\label{index:faq}
\printindex[faqindex]\label{idx:faqindex}

\end{document}

\appendix

\chapter{Build information}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{Sys.info}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.98, 0.98, 0.98}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sessionInfo}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

\end{document}


