% !Rnw root = using-r.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
opts_knit$set(unnamed.chunk.label = 'more-plotting-chunk')
@

\chapter[Extensions to ggplot]{Extensions to \ggplot}\label{chap:R:more:ggplotting}

\begin{VF}
What this means is that we shouldn't abbreviate the truth but rather get a new method of presentation.

\VA{Edward Tufte}{}
\end{VF}

%\dictum[Edward Tufte]{What this means is that we shouldn't abbreviate the truth but rather get a new method of presentation.}

\section{Aims of this chapter}

In this chapter I describe packages that add additional functionality or \emph{graphical designs} of plots to package \pkgname{ggplot2}. Several new packages were written after \pkgname{ggplot2} version 2.0.0 was released, because this version for the first time made it straightforward to write these extensions. To keep up-to-date with the release of new extensions I recommend to regularly check the site `ggplot2 Extensions' (maintained by Daniel Emaasit) at \url{https://www.ggplot2-exts.org/}.

In contrast with previous chapters, I expect readers to first browse through the whole chapter so as to get an idea of what is possible and then cherry pick the sections they find useful and worth of detailed study. Some of the packages are generally useful, but others are more specialized. I have tried to cover a wide array of plot types, but, I have described in more depth packages that I have written myself, or that I am more familiar with---i.e.\ the space dedicated to each package description is not to be taken as a measure of their usefulness for your own work.

\begin{warningbox}
  In this chapter we use mostly the modernized data frames of package \pkgname{tibble}. The main reason is that the \Rfunction{tibble()} constructor does not by default convert character variables into factors as the \Rfunction{data.frame()} constructor does. The format used for printing is also improved. It is possible to use \Rfunction{data.frame()} instead of \Rfunction{tibble()} in most examples given in this chapter, but in some cases you will need to add \code{stringsAsFactors = FALSE} to the call.
\end{warningbox}

As the previous chapter, the present one focuses mainly on how to construct different types of graphical data displays using the grammar of graphics. We also discuss how to alter the ``graphical design'' of the plots produced, but in less depth, mostly leaving for the reader to try by herself/himself the different combinations of types of plots and themes and color palettes described. There is no book covering the use of all the packages described here, and for each package additional examples and explanations will be found in their documentation, which in many cases includes vignettes with extended use examples.

\section{Packages used in this chapter}

The list of packages used in the current chapter is very long. However, there are only few incompatibilities among them. Even if one is not attempting to use functions from different packages within the same plot, one may want to use them to create different figures within the same document when using the literate approach to programming and scripting (see \ref{sec:script:readability} on page \pageref{sec:script:readability}), with incompatibilities requiring additional coding to work around them.

If the packages used in this chapter are not yet installed in your computer, you can install them with the code shown below, as long as package \pkgname{learnrbook} is already installed.

<<eval=FALSE>>=
packages_at_cran <- setdiff(learnrbook::pkgs_ch_ggplotext, learnrbook::pkgs_at_github)
install.packages(packages_at_cran)
for (p in learnrbook::pkgs_at_github) {
  devtools::install_github(p)
}
@

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(learnrbook)
library(tibble)
library(magrittr)
library(lubridate)
library(ggplot2)
library(showtext)
library(viridis)
library(pals)
library(ggsignif)
library(ggrepel)
library(ggforce)
library(ggpmisc)
library(ggseas)
library(gganimate)
library(ggstance)
library(ggbiplot)
library(ggalt)
library(ggbeeswarm)
library(ggExtra)
library(network)
library(ggnetwork)
library(geomnet)
library(ggsci)
library(ggthemes)
library(xts)
library(MASS)
library(gginnards)
# library(ggfortify) # loaded later
# library(ggtern) # loaded later
@

We set a font larger size than the default
<<>>=
theme_set(theme_grey(14))
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`showtext']{\pkgname{showtext}}\label{sec:plot:fonts}

<<>>=
citation(package = "showtext")
@

Package \pkgname{showtext}\index{plots!text in}\index{plots!fonts} allows portable use of different system fonts or fonts from Google in plots created with ggplot.

A font with Chinese characters is included in the package. This example is borrowed from the package vignette, but modified to use default fonts, of which \code{"wqy-microhei"} is a Chinese font included by package \pkgname{showtext}.

<<showtext-0, fig.showtext=TRUE>>=
ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(),
          axis.text = element_blank()) +
    annotate("text", 1, 1.1, family = "wqy-microhei", size = 12,
             label = "\u4F60\u597D\uFF0C\u4E16\u754C") +
    annotate("text", 1, 0.9, label = 'Chinese for "Hello, world!"',
             family = "sans", fontface = "italic", size = 8)
@

Next we load some system fonts, the same we are using for the text of this book. Within code chunks when using \pkgname{knitr} we can enable \code{showtext} with chunk option \code{fig.showtext = TRUE} as done here (but not visible). In a script or at the console we can use \Rfunction{showtext.auto()}, or \Rfunction{showtext.begin()} and \Rfunction{showtext.end()}. As explained in the package vignette, using \code{showtext} can increase the size of the PDF files created, but on the other hand, it makes embedding of fonts unnecessary.

Function \Rfunction{font.families()} lists the fonts known to R, and function \Rfunction{font.add()} can be used to make \emph{system fonts} visible to R. We set families, and indicate the font names for each \emph{face}. The fonts shown in this example are likely not to be available in your own computer, so you may need to replace the font names for those of fonts you have available.

<<showtext-1>>=
font.families()

font.add(family = "Lucida.Sans",
         regular = "LucidaSansOT.otf",
         italic = "LucidaSansOT-Italic.otf",
         bold = "LucidaSansOT-Demi.otf",
         bolditalic = "LucidaSansOT-DemiItalic.otf")

font.add(family = "Lucida.Bright",
         regular = "LucidaBrightOT.otf",
         italic = "LucidaBrightOT-Italic.otf",
         bold = "LucidaBrightOT-Demi.otf",
         bolditalic = "LucidaBrightOT-DemiItalic.otf")

font.families()
@

We can then select these fonts in the usual way.

<<showtext-1a, fig.showtext=TRUE>>=
ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(),
          axis.text = element_blank()) +
    annotate("text", 1, 1.1, label = 'Lucida Bright Demi "Hello, world!"',
             family = "Lucida.Bright", fontface = "bold", size = 6) +
    annotate("text", 1, 0.9, label = 'Lucida Sans Italic "Hello, world!"',
             family = "Lucida.Sans", fontface = "italic", size = 6)
@

<<showtext-2, fig.showtext=TRUE>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = c("a", "b", "c", "d", "e"))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust=1.5, family = "Lucida.Sans", fontface = "italic") +
  geom_point()
@

<<showtext-3, fig.showtext=TRUE>>=
ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust=1.5, family = "Lucida.Bright") +
  geom_point()
@

The examples that follow, using function \Rfunction{font.add.google()} to add Google fonts, are more portable. This is so because as long as internet access is available, fonts can be downloaded if not available locally. You can browse the available fonts at \url{https://fonts.google.com/}. The names used in the statements below are those under which the fonts are listed.

<<showtext-4, cache = FALSE>>=
## Loading Google fonts (http://www.google.com/fonts)
font.add.google(name = "Permanent Marker", family = "Marker")
font.add.google(name = "Courgette")
font.add.google(name = "Lato")
@

<<showtext-5, fig.showtext=TRUE>>=
ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(),
          axis.text = element_blank()) +
    annotate("text", 1, 1.1, label = 'Courgette "Hello, world!"',
             family = "Courgette", size = 6) +
    annotate("text", 1, 0.9, label = 'Permanent Marker "Hello, world!"',
             family = "Marker", size = 6)
@

In all the examples above we used \gggeom{geom\_text()}, but \gggeom{geom\_label()} can be used similarly. In the case of the title, axis-labels, tick-labels, and similar components the use of fonts is controlled through the theme. Here we change the base family used. Please, see section \ref{sec:plot:themes} on page \pageref{sec:plot:themes} for examples of how to set the \code{family} for individual elements of the plot.

<<showtext-6, fig.showtext=TRUE>>=
font.add.google(name = "Lora", regular.wt = 400, bold.wt = 700)
font.families()

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(vjust = -1.2,
            family = "Lora",
            fontface = "bold",
            size = 8) +
  geom_point() +
  theme_classic(base_size = 15, base_family = "Lora")
@

\begin{warningbox}
Be aware that in \emph{geometries} the equivalent of \code{face} in theme text elements is called \code{fontface}, while the character string values they accept are the same.
\end{warningbox}

\begin{playground}
Practice using additional font families and faces in plots created with \pkgname{ggplot2}. Be aware that depending on the font or the operating system in use, the special characters available will vary.
\end{playground}

\section[`viridis']{\viridis}\label{sec:plot:viridis}

<<>>=
citation(package = "viridis")
@

Package \viridis defines color palettes\index{plots!color palettes} and fill\index{plots!scales!fill} and color\index{plots!scales!color} scales with colour selected based on human perception, with special consideration of visibility for those with different kinds of color blindness and well as in grey-scale reproduction.

<<viridis-00>>=
set.seed(56231)
my.data <- tibble(x = rnorm(500),
             y = c(rnorm(250, -1, 1), rnorm(250, 1, 1)),
             group = factor(rep(c("A", "B"), c(250, 250))) )
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

Using \ggscale{scale\_fill\_viridis()} replaces the default palette. In the first two examples we use \emph{statistics}, and consequently map variable \code{level}, returned by the statistic to the \code{fill} \emph{aesthetic}.

<<viridis-01>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis()
@

Function \ggscale{scale\_fill\_viridis()} supports several different palettes, which can be selected through an argument passed to parameter \code{option}.

<<viridis-02>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "magma")
@

\begin{playground}
  Above we set \code{option = "magma"} to use a different palette. Modify the code to use palettes \code{"inferno"} and \code{"plasma"}. Think whether using different palettes may affect how we perceive a given plot, and how this can be used to enhance readability and/or understanding.
\end{playground}

In the next two examples, we variables in \code{my.data} are mapped directly onto \code{aesthetics}. We also set the value used for \code{bins}.

<<viridis-05>>=
ggplot(my.data, aes(x, y)) +
  geom_bin2d(bins = 8) +
  facet_wrap(~group) +
  scale_fill_viridis()
@

<<viridis-06>>=
ggplot(my.data, aes(x, y)) +
  geom_hex(bins = 8) +
  facet_wrap(~group) +
  scale_fill_viridis()
@

\begin{playground}
  In the two last examples above, pass various different values to \code{bins} and try to understand what is its effect. As a second step, plays with data sets with very different numbers of observations, and find the values which result in the best figure for each data set, according to your own judgement.
\end{playground}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`pals']{\pkgname{pals}}\label{sec:plot:pals}
\index{plots!color palettes}\index{color palettes}
<<>>=
citation(package = "pals")
@

Package \pkgname{pals}\index{plots!color palettes}\index{color palettes}\index{color maps} fulfils a very specific role: it provides definitions for palettes and color maps, and also palette evaluation tools. Being a specialized package, we describe it briefly and recommend readers to read the vignette and other documentation included with the package.

We modify some of the examples from the previous section to show how to use the palettes and colormaps defined in this package.

<<pals-00>>=
set.seed(56231)
my.data <- tibble(x = rnorm(500),
             y = c(rnorm(250, -1, 1), rnorm(250, 1, 1)),
             group = factor(rep(c("A", "B"), c(250, 250))) )
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

First we simply reproduce the first example obtaining the same plot as by use of \ggscale{scale\_fill\_viridis()}.

<<pals-01>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_gradientn(colours = viridis(100), guide = "colourbar")
@

The biggest advantage is that we can in the same way use any of the very numerous colormaps and palettes, and choose how smooth a color map we use.

<<pals-02>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_gradientn(colours = viridis(10), guide = "colourbar")
@

We can compare different colormaps with \Rfunction{pal.bands()}. In this example we compare those included in package \pkgname{viridis} with some of the other palettes defined in package \pkgname{pals}.

<<pals-03>>=
pal.bands(viridis, magma, inferno, plasma, coolwarm, tol.rainbow, parula)
@

How does the luminance of the red, green and blue colour channels vary along the palette or color map gradient? We can see this with \Rfunction{pal.channels()}.

<<pals-04>>=
pal.channels(viridis, main = "viridis")
@

How would \code{viridis} look in monochrome, and to persons with different kinds of color blindness? We can see this with \Rfunction{pal.safe()}.

<<pals-05>>=
pal.safe(viridis, main = "viridis")
@

A brief example with a discrete palette follows using \Rfunction{tol()}.

<<pals-10>>=
ggplot(data = mtcars,
    aes(x = disp, y = mpg, color = factor(cyl))) +
    geom_point() +
    scale_color_manual(values = tol(n = 3))
@

Parameter \code{n} gives the number of discrete values in the palette. Discrete palettes have a maximum value for \code{n}, in the case of tol, 12 discrete steps.

<<pals-11>>=
pal.bands(tol(n = 3), tol(n = 6), tol())
@

\begin{playground}
Play with the argument passed to \code{n} to test what happens when the number of values in the scale is smaller or larger than the number of levels of the factor mapped to the color \emph{aesthetic}.
\end{playground}

Is this palette safe?

<<pals-12>>=
pal.safe(tol(n = 3))
@

\begin{playground}
Explore the available palettes until you find a nice one that is also safe with three steps. Be aware that color maps, like \Rfunction{viridis()} can be used to define a discrete color scale using \ggscale{scale\_color\_manual()} in exactly the same way as palettes like \Rfunction{tol()}. Colormaps, however, may be perceived as gradients, rather than un-ordered discrete categories, so care is needed.
\end{playground}

\section[`gganimate']{\pkgname{gganimate}}\label{sec:plot:gganimate}
\index{plots!animation}
<<>>=
citation(package = "gganimate")
@

Package \pkgname{gganimate}\index{plots!animation} allows the use of package \pkgname{animation} in ggplots with a syntax consistent with the grammar of graphics. It adds a new aesthetic \code{frame}, which can be used to map \emph{groups} of data to \emph{frames} in the animation.

Use of the package is extremely easy, but installation can be somehow tricky because of system requirements. Just, make sure to have \pgrmname{ImageMagick} installed and included in the search \code{PATH}.

We modify an example from section \ref{sec:simple:points:lines} on page \ref{sec:simple:points:lines}. We add the \code{frame} aesthetic to the earlier figure.
<<gganimate-1>>=
p <- ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl), frame  = cyl)) +
  geom_point()
@

Now we can print \code{p} as a normal plot, with \Rfunction{print()}, here called automatically.

<<gganimate-2>>=
p
@

Or display an animation with \Rfunction{gganimate()} (Renamed from \Rfunction{gg\_animate()} in package version > 0.1.0). The animation will look differently depending on the output format, and the program used for viewing it. For example, in this PDF files, the animation will work when viewed with Adobe Viewer or Adobe Acrobat but not in Sumatra PDF viewer. We add \code{title\_frame = FALSE} as a title does not seem useful in this simple animation.

<<gganimate-3, fig.show='animate'>>=
gganimate(p, title_frame = FALSE)
@

Or save it to a file.

<<gganimate-4, eval = FALSE>>=
gganimate(p, "p-animation.gif")
@

Cumulative animations are also supported. We here use the same example with three frames, but this type of animation is particularly effective for time series data. To achieve this we only need to add \code{cumulative = TRUE} to the aesthetics mappings.

<<gganimate-1a>>=
p <- ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl),
           frame  = cyl, cumulative = TRUE)) +
  geom_point()
@

Now we can print \code{p} as a normal plot,

<<gganimate-2a>>=
p
@

Or display an animation with \Rfunction{gganimate()}. The animation will look differently depending on the output format, and the program used for viewing it. For example, in this PDF files, the animation will work when viewed with Adobe Viewer or Adobe Acrobat but in Sumatra PDF viewer.

<<gganimate-3a, fig.show='animate'>>=
gganimate(p, title_frame = FALSE)
@

\begin{playground}
  Playing with animated plots is fun, and can even be addictive. Do build different animated plots using data from two-way or more experimental designs.
\end{playground}

\begin{advplayground}
  Make an animation in which all frames contain the whole data set as a scatter plot, but with a curve for a different model fit displayed overlaid on the points in each frame.

  Make an animation all which frames contain the whole data set as a scatter plot, but with different groups of observations highlighted in each frame---hints: \code{alpha}, \code{color}, \code{shape} are your friends.
\end{advplayground}

\section[`ggstance']{\pkgname{ggstance}}\label{sec:plot:ggstance}
\index{plots!horizontal geometries}
\index{plots!horizontal statistics}
\index{plots!horizontal positions}
\index{plots!geometries!barh}
\index{plots!geometries!histogramh}
\index{plots!geometries!linerangeh}
\index{plots!geometries!pointrangeh}
\index{plots!geometries!errorbarh}
\index{plots!geometries!crossbarh}
\index{plots!geometries!boxploth}
\index{plots!geometries!violinh}
\index{plots!statistics!binh}
\index{plots!statistics!boxploth}
\index{plots!statistics!counth}
\index{plots!statistics!xdensity}
\index{plots!positions!dodgev}
\index{plots!positions!nudgev}
\index{plots!positions!fillv}
\index{plots!positions!stackv}
\index{plots!positions!jitterdodgev}
<<>>=
citation(package = "ggstance")
@

Package \pkgname{ggstance} defines horizontal versions of common ggplot \emph{geometries}, \emph{statistics} and \emph{positions}. Although \ggplot defines \ggcoordinate{coord\_flip}, \pkgname{ggstance} provides a more intuitive user interface and more consistent plot formatting.

\sloppy
Currently the package defines \textbf{horizontal} \emph{geoms} \gggeom{geom\_barh()}, \gggeom{geom\_histogramh()}, \gggeom{geom\_linerangeh()}, \gggeom{geom\_pointrangeh()}, \gggeom{geom\_errorbarh()}, \gggeom{geom\_crossbarh()}, \gggeom{geom\_boxploth()}, and \gggeom{geom\_violinh()}. It also defines
\textbf{horizontal} \emph{stats} \ggstat{stat\_binh()}, \ggstat{stat\_boxploth()}, \ggstat{stat\_counth()}, and \ggstat{stat\_xdensity()} and \textbf{vertical} \emph{positions} \code{position\_dodgev}, \code{position\_nudgev}, \code{position\_fillv}, \code{position\_stackv}, and \code{position\_jitterdodgev}.

We will give give only a couple of examples, as their use has no surprises. First we make horizontal versions of the histogram plots shown in section \ref{sec:histogram} on page \pageref{sec:histogram}.

<<ggstance-01>>=
set.seed(12345)
my.data <- tibble(x = rnorm(200),
             y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
             group = factor(rep(c("A", "B"), c(100, 100))) )
@

\index{plots!histogram!horizontal}
<<ggstance-02>>=
ggplot(my.data, aes(y = x)) +
  geom_histogramh(bins = 15)
@

<<ggstance-03>>=
ggplot(my.data, aes(y = y, fill = group)) +
  geom_histogramh(bins = 15, position = "dodgev")
@

<<ggstance-04>>=
ggplot(my.data, aes(y = y, fill = group)) +
  geom_histogramh(bins = 15, position = "stackv")
@

<<ggstance-05>>=
ggplot(my.data, aes(y = y, fill = group)) +
  geom_histogramh(bins = 15, position = "identity", alpha = 0.5) +
  theme_bw(16)
@

Now we make an horizontal version of the boxplot shown in section \ref{sec:boxplot} on page \pageref{sec:boxplot}.
\index{plots!box and whiskers plot!horizontal}

<<ggstance-06>>=
ggplot(my.data, aes(y, group)) +
  geom_boxploth()
@

\section[`ggbiplot']{\pkgname{ggbiplot}}\label{sec:plot:ggbiplot}
\index{plots!principal components}
<<>>=
citation(package = "ggbiplot")
@

Package \pkgname{ggbiplot}\index{plots!principal components} defines two functions, \Rfunction{ggscreeplot()} and \Rfunction{ggbiplot()}. These functions make it easy to nicely print the results from principal components analysis done with \Rfunction{prcomp()}.

For the time being we reproduce an example from the package README.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<ggbiplot-1>>=
data(wine)
wine.pca <- prcomp(wine, scale. = TRUE)
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
  groups = wine.class, ellipse = TRUE, circle = TRUE) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', legend.position = 'top')
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`ggalt']{\pkgname{ggalt}}\label{sec:plot:ggalt}
\index{plots!lollipop plot}
\index{plots!dumbell plot}
\index{plots!step ribbon plot}
\index{plots!scales!fill}
\index{plots!formatters!byte}
\index{plots!geometries!lollipop}
\index{plots!geometries!dumbbell}
\index{plots!geometries!step ribbon}
\index{plots!geometries!stateface}
\index{plots!geometries!encircle}
\index{plots!geometries!step ribbon}
<<>>=
citation(package = "ggalt")
@

Package \pkgname{ggalt} defines \emph{geoms} \gggeom{geom\_xspline()}, \gggeom{geom\_bkde()}, \gggeom{geom\_bkde2d()}, \gggeom{geom\_stateface()}, \gggeom{geom\_encircle()}, \gggeom{geom\_lollipop()}, \gggeom{geom\_dumbbell()}, and \gggeom{geom\_stepribbon()}; \emph{stats} \ggstat{stat\_xspline()}, \ggstat{stat\_bkde()}, \ggstat{stat\_bkde2d()}, and \ggstat{stat\_ash()}; \emph{scale} \ggscale{scale\_fill\_pokemon()}; \emph{formatter} \Rfunction{byte\_format()}.

The highlights are use of functions from package 'KernSmooth' for density estimation, the provision of \emph{X-splines} and for formatting ``bytes'' in the usual way used when describing computer memory.

First\index{plots!statistics!x-spline}\index{plots!geometries!x-spline}\index{plots!smooth curves}
 example is the use of \emph{x-splines} which are very flexible splines that are smooth (have a continuous first derivative). They can be tuned from interpolation (passing through every observation) to being rather ``stiff'' smoothers.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggalt-1>>=
set.seed(1816)
dat <- tibble(x=1:10,
                  y=c(sample(15:30, 10)))
@

<<ggalt-2>>=
ggplot(dat, aes(x, y)) +
  geom_point() +
  geom_xspline()
@

The "flexibility" of the spline can be adjusted by passing an \code{numeric} argument to parameter \code{spline\_shape}.

<<ggalt-3>>=
ggplot(dat, aes(x, y)) +
  geom_point() +
  geom_xspline(spline_shape=0.4)
@

We also redo some of the density\index{plots!density plot!1 dimension}
\index{plots!density plot!2 dimensions}
 plot examples from \ref{sec:plot:density} on page \pageref{sec:plot:density}.

<<ggalt-4>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_bkde(alpha = 0.5)
@

<<ggalt-5>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  geom_bkde2d()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggalt-6>>=
ggplot(my.data, aes(x, y)) +
    geom_bkde2d() +
    facet_wrap(~group)
@

We here use a scale from package \pkgname{viridis} described in section \ref{sec:plot:viridis} on page \pageref{sec:plot:viridis}.

<<ggalt-7>>=
ggplot(my.data, aes(x, y)) +
    stat_bkde2d(aes(fill = ..level..), geom = "polygon") +
    facet_wrap(~group) +
    scale_fill_viridis()
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`ggbeeswarm']{\pkgname{ggbeeswarm}}\label{sec:plot:ggbeeswarm}
\index{plots!density per category(}
\index{plots!categorical scatter(}
\index{scatter plot!categorical(}

<<ggpmisc-01>>=
citation(package = "ggbeeswarm")
@

Package \pkgname{ggbeeswarm} defines two geometries for `plotting categorical scatter plots such that the arrangement of points within a category reflects the density of data at that region, and avoids over-plotting'. See also the related \emph{sina plot} described in section \ref{sec:plot:sina} on page \pageref{par:plot:sina}. These geometries follow the usual grammar of graphics, with one exception: one parameter allows the production of horizontal point clouds (with the grouping factor on the $y$-axis).

The geometry \gggeom{geom\_quasirandom()}\index{plots!density!quasirandom} supports the creation of three different styles of plots controlled by the argument passed to parameter \code{method}. The methods differ in how the points are spread and how the density is represented as a scatter plot. Each method accepts additional arguments that allow the adjustment of the appearance.

Two different approaches to the plotting of \emph{density summaries} for categorical data are implemented in package \pkgname{ggplot2}: box and whisker plots (see section \ref{sec:boxplot} on page \pageref{sec:boxplot}) and violin plots (see section \ref{sec:plot:violin} on page \pageref{sec:plot:violin}). We will use here a similar data set as that used in the violin plot examples.

We generate an artificial data set by drawing pseudo-random data from Normal distributions with different means and standard deviations.

<<ggbeeswarm-02>>=
set.seed(12345)
my.data <-
  data.frame(y = c(rnorm(n = 100, mean = -1, sd = 1),
                   rnorm(n = 50, mean = 1, sd = 1),
                   rnorm(n = 50, mean = 1, sd = 0.3)),
             group = factor(x = rep(c("A", "B", "C"), times = c(100, 50, 50))) )
@

Method \code{"quasirandom"}, used by default.

<<ggbeeswarm-03>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom()
@

By default the widths of the clouds for each group (i.e.\ each level of the factor mapped onto $x$) is the same. However, passing \code{varwidth = TRUE} makes it reflect the number of observations in each group.

<<ggbeeswarm-03a>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(varwidth = TRUE)
@

\begin{playground}
  Create a new data set replacing \code{rnorm()} by functions drawing (pseudo)-random numbers according to distribution different to the Normal.
\end{playground}

We can adjust the transparency and size of the symbols representing points. We do not show it here, but additional \emph{aesthetics} can be set to constants or mapped to variables.

<<ggbeeswarm-03b>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(alpha = 0.33, size = 3)
@

\begin{playground}
  Modify the example by adding other mapped or constant \emph{aesthetics} such as \code{color}, \code{shape}, etc.
\end{playground}

\begin{playground}
  Try different combinations of transparency and size, try to find a few different combinations that are good at displaying the properties of the distributions.
\end{playground}

The argument passed to parameter \code{bandwidth} controls how much smoothing is applied when fitting the kernel density used as the boundary of the cloud of points.

<<ggbeeswarm-04>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(bandwidth = 0.75)
@

<<ggbeeswarm-05>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(bandwidth = 0.25)
@

Method \code{"pseudorandom"}\index{plots!density!pseudorandom}
 differs in how the points are distributed laterally within the boundaries of the fitted kernel density. The argument passed to \code{bandwidth} has a strong effect on the shape of the cloud in the case of methods \code{"pseudorandom"} and \code{"quasirandom"}.

<<ggbeeswarm-06>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(method = "pseudorandom")
@

Methods \code{"smiley"} and \code{"frowney"}\index{plots!density!smiley}\index{plots!density!frowney} the points are distributed within each bin on alternating sides, without overlap. The argument passed to \code{nbins} has a strong effect on the shape of the cloud in the case of methods \code{"frowney"} and \code{"smiley"}.

<<ggbeeswarm-07>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(method = "smiley")
@

<<ggbeeswarm-07a>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(method = "smiley", nbins = 30)
@

<<ggbeeswarm-08>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(method = "frowney")
@

In the case of method \code{"tukey"}\index{plots!density!Tukey}, the cloud is rectangular, and points do overlap (in contrast to the other methods) and consequently setting a suitable value for \code{alpha} is very important. This value depends on the degree of overlap, which in turn depends on the number of observations and the width of the clouds relative to the size and shape of the symbols.

<<ggbeeswarm-09>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(method = "tukey", alpha = 0.25)
@

<<ggbeeswarm-09a>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom(method = "tukey", alpha = 0.25, width = 0.1, nbins = 10)
@

Finally a \emph{bee swarm}\index{plots!density!beeswarm} plot differs from those above in that it is not based on the calculation of a kernel density, but instead on systematically shifting the points within a bin so that they do not overlap. Even though no density is estimated, the width of the cloud still reflects the local density.

<<ggbeeswarm-10>>=
ggplot(my.data, aes(group, y)) +
  geom_beeswarm(alpha = 0.25)
@

If the factor is mapped onto the $y$-axis, then passing \code{groupOnX = FALSE} produces the correct plot by vertically, instead of horizontally, shifting the position of the points in the cloud.

<<ggbeeswarm-11>>=
ggplot(my.data, aes(y, group)) +
  geom_beeswarm(alpha = 0.25, groupOnX = FALSE)
@

\begin{playground}
The best way of being aware of how it is possible to ``cheat'' with graphical displays when reading other people's works, is to try one's own hand at it. In the case of densities represented by clouds of points, using symbol shapes, sizes or colors with different perceived ``darkness'' is a good start. Using data generated below, first create a plot using the \code{"quasirandom"} method and default settings. Then manipulate the settings for aesthetics until the plot communicates at first sight something quite different. With this data set with 1200 observations, you will be also able to study how the number of observations affects the choice of \code{method}, \code{size} and \code{transparency}.

<<ggbeeswarm-12, eval=eval_playground>>=
set.seed(12345)
playg.data <-
  data.frame(y = c(rnorm(n = 200, mean = -1, sd = 1),
                   rnorm(n = 500, mean = 1, sd = 1),
                   rnorm(n = 500, mean = 1, sd = 0.3)),
             group = factor(x = rep(c("A", "B", "c"), times = c(200, 500, 500))) )
@
\end{playground}

\index{scatter plot!categorical)}
\index{plots!categorical scatter)}
\index{plots!density per category)}

\section[`ggExtra']{\pkgname{ggExtra}}\label{sec:plot:ggExtra}
\index{plots!density}

Sometimes it is useful to add marginal plots\index{plots!marginal}\index{marginal plots}\index{marginal histograms}\index{marginal density plots} to a \Rclass{ggplot}. Package \pkgname{ggExtra} provides this functionality through an easy to use interface.

<<>>=
citation(package = "ggExtra")
@

<<ggextra-00>>=
set.seed(12345)
    my.data <-
    data.frame(x = rnorm(200),
               y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
    group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<ggextra-01>>=
p01 <- ggplot(my.data, aes(x, y)) +
         geom_point()
@

<<ggextra-02>>=
ggMarginal(p01)
@

<<ggextra-03>>=
ggMarginal(p01, type = "histogram", margins = "x", size = 3)
@

\begin{playground}
Read the documentation for \Rfunction{ggMarginal()} and play by changing the aesthetics used for the lines and bars on the margins.
\end{playground}

\begin{infobox}
At the time of writing, \Rfunction{ggMarginal()} does not support grouping or facets. Both of these features would be very useful quite frequently, but this needs to be done manually, using the facilities of package \pkgname{gridExtra} to combine and align ggplots created individually. Grouping is ignored. Facets in the plot passed as argument trigger fatal errors when \Rfunction{ggMargins()} is exectuted.

<<ggextra-11>>=
p02 <- ggplot(my.data, aes(x, y, color = group)) +
            geom_point()
@

<<ggextra-12>>=
ggMarginal(p02, margins = "x")
@

\end{infobox}

\section[`ggfortify']{\pkgname{ggfortify}}\label{sec:plot:ggfortify}

<<>>=
# interferes with 'ggbiplot'
library(ggfortify)
@

<<>>=
citation(package = "ggfortify")
@

Package \pkgname{fortify}\index{plots!fitted models} re-organizes the output from different model fitting functions into an easier to handle and more consistent format that is especially useful when collecting the results from different fits. Package \pkgname{ggfortify} extends this idea to encompass the creation of diagnostic and other plots from model fits using \pkgname{ggplot2}. The most important method to remember is \Rfunction{autoplot()} for which many different specializations are provided. As the returned objects are of class \code{"ggplot"}, it is easy to add additional layers and graphical elements to them.

We start with a linear model as example. We return to the regression example used in Chapter \ref{chap:R:functions}, page \pageref{xmpl:fun:lm:fm1}.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<ggfortify-01>>=
fm1 <- lm(dist ~ speed, data=cars)
@

<<ggfortify-02>>=
autoplot(fm1)
@

And here the example used for ANOVA on page \pageref{xmpl:fun:lm:fm4}.

<<ggfortify-03>>=
fm4 <- lm(count ~ spray, data = InsectSprays)
@

<<ggfortify-04>>=
autoplot(fm4)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

There is also an \Rfunction{autoplot()} especialization for time series data.

<<ggfortify-11>>=
autoplot(lynx)
@

Please, see section \ref{sec:plot:ggpmisc} for an alternative approach, slightly less automatic, but based on a specialization of the \Rfunction{ggplot()} method.

\section[`ggnetwork']{\pkgname{ggnetwork}}\label{sec:plot:ggnetwork}

\begin{infobox}
This is not the only package supporting the plotting of network graphs with package \ggplot. Packages \pkgname{GGally} and \pkgname{geomnet} also support network graphs. Package \pkgname{ggCompNet} compares the three methods, both for performance and by giving examples of the visual design.
\end{infobox}

<<>>=
citation(package = "ggnetwork")
@

Package \pkgname{ggnetwork}\index{plots!network graphs}\index{network graphs} provides methods and functions to plot network graphs with \ggplot, which are a rather specialized type of plots. This package contains a very nice vignette with many nice examples, so in this section I will only provide some examples to motivate the readers to explore the package documentation and use the package. This package allows very flexible control of the graphical design.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
@

<<ggnetwork-01>>=
data(blood, package = "geomnet")
@

Using mostly defaults, the plot is not visually attractive. For the layout to be deterministic, we need to set the seed used by the pseudorandom number generator. To assemble the plot we add three layers of data with \gggeom{geom\_edges()}, \gggeom{geom\_nodes()} and \gggeom{geom\_nodetext()}. We use \ggtheme{theme\_blank()} as axes and their labels play no function in a plot like this.

\Attention{Bug} The code in the chunks below stopped working with recent package updates. The problem is triggered by columns in the data frame returned by `ggnetwork()` being of class \code{"matrix"} instead of a \code{"numeric"} vector as expected by \code{ggplot()}. As a temporary work around I have added code that does the required class conversion.

<<ggnetwork-02>>=
set.seed(12345)
ggnetwork(network(blood$edges[, 1:2]), layout = "circle") %>%
# work around bug that results in these columns being of class "matrix"
   mutate(x = as.numeric(x),
          y = as.numeric(y),
          xend = as.numeric(xend),
          yend = as.numeric(yend)) -> my.net.df

ggplot(my.net.df,
       aes(as.numeric(x), as.numeric(y), xend = as.numeric(xend), yend = as.numeric(yend))) +
    geom_edges() +
    geom_nodes() +
    geom_nodetext(aes(label = vertex.names)) +
    theme_blank()
@

Some tweaking of the \emph{aesthetics} leads to a nicer plot.

<<ggnetwork-03>>=
set.seed(12345)
ggnetwork(network(blood$edges[, 1:2]),
          layout = "circle", arrow.gap = 0.06) %>%
# work around bug that results in these columns being of class "matrix"
   mutate(x = as.numeric(x),
          y = as.numeric(y),
          xend = as.numeric(xend),
          yend = as.numeric(yend)) -> my.net.df

ggplot(my.net.df,
       aes(x, y, xend = xend, yend = yend)) +
    geom_edges(color = "grey30",
               arrow = arrow(length = unit(6, "pt"), type = "open")) +
    geom_nodes(size = 16, color = "darkred") +
    geom_nodetext(aes(label = vertex.names), color = "white") +
    theme_blank()
@

\begin{playground}
How does the layout change if you change the argument passed to \Rfunction{set.seed()}? And what happens with the layout if you run the plotting statement more than once, without calling \Rfunction{set.seed()}?
\end{playground}

\begin{playground}
What happens if you change the order of the \code{geom}s in the code above? Experiment by editing and running the code to find the answer, or if you think you know the answer, to check whether you guess was right or wrong.
\end{playground}

\begin{playground}
Change the graphic design of the plot in steps, by changing: 1) the shape of the nodes, 2) the color of the nodes, 3) the size of the nodes and the size of the text, 4) the type of arrows and their size, 5) the font used in nodes to italic.
\end{playground}

\section[`geomnet']{\pkgname{geomnet}}\label{sec:plot:geomnet}

<<>>=
citation(package = "geomnet")
@

Package \pkgname{geomnet}\index{plots!network graphs}\index{network graphs} provides methods and functions to plot network graphs with \ggplot, which are a rather specialized type of plots.

<<geomnet-01>>=
data(blood, package = "geomnet")
@

Using mostly defaults, the plot is very simple, and lacks labels. As above, for the layout to be deterministic, we need to set the seed. In the case of \pkgname{geomnet}, new \emph{aesthetics} \code{from\_id} and \code{to\_id} are defined, only one layer is needed, added with \gggeom{geom\_net()}. We use here \ggtheme{theme\_net()}, also exported by this package.

<<geomnet-02>>=
set.seed(12345)
ggplot(data = blood$edges, aes(from_id = from, to_id = to)) +
  geom_net() +
  theme_net()
@

Some tweaking of the \emph{aesthetics} leads to a nicer plot, equivalent to the second example in the previous section.

<<geomnet-03>>=
set.seed(12345)
ggplot(data = blood$edges, aes(from_id = from, to_id = to)) +
  geom_net(colour = "darkred", layout.alg = "circle", labelon = TRUE, size = 16,
           directed = TRUE, vjust = 0.5, labelcolour = "white",
           arrow = arrow(length = unit(6, "pt"), type = "open"),
           linewidth = 0.5, arrowgap = 0.06,
           selfloops = FALSE, ecolour = "grey30") +
  theme_net()
@

\begin{playground}
Change the graphic design of the plot in steps, by changing: 1) the shape of the nodes, 2) the color of the nodes, 3) the size of the nodes and the size of the text, 4) the type of arrows and their size, 5) the font used in nodes to italic.
\end{playground}

\section[`ggforce']{\pkgname{ggforce}}\label{sec:plot:ggforce}

<<ggforce-01>>=
citation(package = "ggforce")
@

Package \pkgname{ggforce} includes an assortment of useful extensions to \pkgname{ggplot2}.

\subsection{Geoms and stats}\label{sec:plot:sina}
\index{plots!sina plot}\index{plots!geometries!sina}
Sina plots are a new type of plots resembling violin plots (described in section \ref{sec:plot:violin} on page \pageref{sec:plot:violin}), where actual observations are plotted as a cloud spreading widely as the density increases. Both a \emph{geometry} and a \emph{statistics} are defined.

<<ggforce-11>>=
set.seed(12345)
my.data <-
  data.frame(x = rnorm(200),
             y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
             group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<ggforce-12,echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

Sina plots can obtained with \gggeom{geom\_sina()}.\label{par:plot:sina}

<<ggforce-13>>=
ggplot(my.data, aes(group, y)) +
  geom_sina()
@

<<ggforce-14>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_sina()
@

The \emph{geometries} \gggeom{geom\_sina()} and \gggeom{geom\_violin()} can be combined to create attractive and informative plots. As with any \Rclass{ggplot} varying the order of the layers and their transparency (\code{alpha}) can be used to obtain plots where one or the other \emph{geometry} is highlighted.

<<ggforce-15>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_violin(alpha = 0.16) +
  geom_sina(alpha = 0.33)
@

\index{plots!arcs, curves and circles}\index{plots!Bezier curves}\index{plots!b-splines}%
\index{plots!geometries!circle}\index{plots!geometries!arc}\index{plots!geometries!arcbar}%
\index{plots!geometries!bezier}\index{plots!geometries!bspline}

Several \emph{geometries} for plotting arcs, curves and circles also provided: \gggeom{geom\_circle()}, \gggeom{geom\_arc()}, \gggeom{geom\_arcbar()}, \gggeom{geom\_bezier()}, \gggeom{geom\_bspline()}.

coming soon.

\index{plots!geometries!link}\index{plots!geometries!link2}\index{plots!interpolation}
\emph{Geometries} similar to \gggeom{geom\_path()} and \gggeom{geom\_segment()}, called \gggeom{geom\_link()} and \gggeom{geom\_link2()} add interpolation of \emph{aesthetics} along the segment or path between each pair of observations/points.

coming soon.

\subsection{Transformations}
\index{plots!transformations!reverser}
\code{trans\_reverser} can be used to reverse any monotonic transformation.
\index{plots!transformations!power}\index{plots!transformations!radial}
New transformations \Rfunction{power\_trans()} and \Rfunction{radial\_trans()}

coming soon.

\subsection{Theme}
\index{plots!themes!no axes}

\ggtheme{theme\_no\_axes()} is not that useful for a sina plot, but could be used to advantage for raster images or maps. It differs from \ggtheme{theme\_blank()} and \ggtheme{theme\_null()} in the plot being framed and having a white plotting area.

<<ggforce-31>>=
ggplot(my.data, aes(group, y)) +
  geom_sina() +
  theme_no_axes()
@

\subsection{Paginated facetting}
\index{plots!facets!pagination}
\index{plots!facets!zooming}
\Rfunction{facet\_grid\_paginate()}, \Rfunction{facet\_wrap\_paginate()} and \Rfunction{facet\_zoom()} add pagination to usual faceting, allowing one to split large faceted plots into pages, and zooming into individual panel in a facetted plot.

coming soon.

\section[`ggpmisc']{\ggpmisc}\label{sec:plot:ggpmisc}

<<ggbeeswarm-01>>=
citation(package = "ggpmisc")
@

<<ggpmisc-02,echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\sloppy
Package \ggpmisc is a package developed by myself as a result of questions from work mates and in Stackoverflow, or functionality that I have needed in my own research or for teaching. It provides new stats for everyday use: \ggstat{stat\_peaks()}, \ggstat{stat\_valleys()}, \ggstat{stat\_poly\_eq()}, \ggstat{stat\_fit\_glance()}, \ggstat{stat\_fit\_deviations()}, and \ggstat{stat\_fit\_augment()}. A function for converting time-series data to a data frame that can be easily plotted with `ggplot2'. It also provides some debugging tools that echo the data received as input: \ggstat{stat\_debug\_group()}, \ggstat{stat\_debug\_panel()}, and \gggeom{geom\_debug()}, and \gggeom{geom\_null()} that does not plot its input.

\subsection{Plotting time-series}
\index{plots!time series}
\index{time series!conversion into data frame}
\index{time series!conversion into tibble}
Instead of creating a new statistics or geometry for plotting time series we provide a function that can be used to convert time series objects into data frames suitable for plotting with \ggplot. A single function \Rfunction{try\_tibble()} (also available as \\Rfunction{try\_data\_frame()}) accepts time series objects saved with different packages as well as R's native \code{ts} objects. The \textit{magic} is done mainly by package \xts to which we add a wrapper to obtain a data frame. By default the time variable is given name \code{time} and that with observations, the ``name'' of the data argument passed. In the usual case of passing a time series object, its name is used for the variable.

We exemplify this with some of the time series data included in R. In the first example we use the default format for time.

<<ggpmisc-11>>=
ggplot(try_tibble(austres), aes(time, austres)) +
  geom_line()
@

In the second example we use ``decimal years'' in numeric format for expressing `time'.

<<ggpmisc-012>>=
ggplot(try_tibble(lynx, as.numeric = TRUE),
       aes(x = time, y = lynx)) +
  geom_line()
@

Here we use dates rounded to the month.

<<ggpmisc-13>>=
ggplot(try_tibble(AirPassengers, "month"),
       aes(time, AirPassengers)) +
  geom_line()
@

Multivariate time series are also supported.

Plotting can be automated even further for \code{"ts"} and \code{"xts"} with the specialized \Rclass{ggplot} methods defined by package \pkgname{ggpmisc}. The same parameters as in \

<<ggpmisc-14>>=
ggplot(AirPassengers) +
  geom_line()
@

These methods default to using ``decimal time'' for \code{time} as not all \emph{statistics} (i.e.\ from package \pkgname{ggseas}) work correctly with \code{POSIXct}. Passing \code{FALSE} as argument \code{as.numeric} results in \code{time} being returned as a datetime variable. This allows use of \ggplot's time scales.

<<ggpmisc-15>>=
ggplot(AirPassengers, as.numeric = FALSE) +
  scale_x_datetime(date_breaks = "1 year", date_labels = "%Y") +
  geom_line()
@

\subsection{Peaks and valleys}
\index{plots!statistics!peaks@peaks}
\index{plots!statistics!valleys@valleys}
Peaks and valleys are local (or global) maxima and minima. These stats return the $x$ and $y$ values at the peaks or valleys plus suitable labels, and default aesthetics that make easy their use with several different geoms, including \gggeom{geom\_point()}, \gggeom{geom\_text()}, \gggeom{geom\_label()}, \gggeom{geom\_vline()}, \gggeom{geom\_hline()} and \gggeom{geom\_rug()}, and also with \emph{geometries} defined by package \ggrepel. Some examples follow.

There are many cases, for example in physics and chemistry, but also when plotting time-series data when we need to automatically locate and label local maxima (peaks) or local minima (valleys) in curves. The statistics presented here are useful only for dense data as they do not fit a peak function but instead simply search for the local maxima or minima in the observed data. However, they allow flexible generation of labels on both $x$ and $y$ peak or valley coordinates.

We use as example the same time series as above. In the next several examples we demonstrate some of this flexibility.

<<ggpmisc-21>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             vjust = -0.5, x.label.fmt = "%4.0f") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "text", colour = "blue",
               vjust = 1.5, x.label.fmt = "%4.0f") +
  ylim(-100, 7300)
@

<<ggpmisc-22>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             vjust = -0.5, x.label.fmt = "%4.0f") +
  ylim(NA, 7300)

@

<<ggpmisc-23>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue")
@

<<ggpmisc-24>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             hjust = -0.1, label.fmt = "%4.0f",
             angle = 90, size = 2.5,
             aes(label = paste(..y.label..,
                               "skins in year", ..x.label..))) +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue") +
  stat_valleys(geom = "text", colour = "blue",
             hjust = -0.1, label.fmt = "%4.0f",
             angle = 90, size = 2.5,
             aes(label = paste(..y.label..,
                               "skins in year", ..x.label..))) +
  ylim(NA, 10000)
@

Using POSIXct for `time` but supplying a format string, to show only the month corresponding to each peak or valley. Any format string accepted by \Rfunction{strftime()} can be used.

<<ggpmisc-25>>=
ggplot(AirPassengers, as.numeric = FALSE) + geom_line() +
  stat_peaks(colour = "red", span = 9) +
  stat_peaks(geom = "text", span = 9, colour = "red", hjust = -0.5,
             angle = 90, x.label.fmt = "%b") +
  stat_valleys(colour = "blue", span = 9) +
  stat_valleys(geom = "text", span = 9, colour = "blue", hjust = 1.5,
               angle = 90, x.label.fmt = "%b") +
  scale_x_datetime(date_breaks = "1 year", date_labels = "%Y") +
  ylim(-50, 700)
@

Rotating the labels.

<<ggpmisc-26>>=
ggplot(lynx, as.numeric = FALSE) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", angle = 66,
             hjust = -0.1, x.label.fmt = "%Y") +
  ylim(NA, 7800)
@

Of course, if one finds use for it, the peaks and/or valleys can be plotted on their own. Here we plot an "envelope" using \gggeom{geom\_line()}.

<<ggpmisc-27>>=
ggplot(AirPassengers) +
  geom_line() +
  stat_peaks(geom = "line", span = 9, linetype = "dashed") +
  stat_valleys(geom = "line", span = 9, linetype = "dashed")
@

\subsection{Adding a table to a plot}\label{sec:plot:geom:table}
\index{plots!adding tables}
\index{plots!geometries!table@table}

The \gggeom{geom\_table()} plots a data frame or tibble, nested in a tibble passed as data
argument. The \emph{aesthetics} \code{x} and \code{y} are used for positioning,
and the \code{label} aesthetic for the data frame containing the table's content.
The table is created as a 'grid' \code{grob} and added as usual to the \code{ggplot} object. Justification, as in a text label, controls where within the table the $x$ and $y$
coordinates used for positioning are to be referenced. The \code{angle} aesthetic
can be used to rotate the whole table (not shown in the example).

We first generate some artificial data.

<<ggpmisc-00>>=
set.seed(4321)
# generate artificial data
x <- 1:100
y <- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data <- data.frame(x,
                      y,
                      group = c("A", "B"),
                      y2 = y * c(0.5,2),
                      block = c("a", "a", "b", "b"))
@

The \code{data} for the table is included as a one row tibble, containing the coordinates for the location of the table, and an embedded tibble with the data for the table itself. To embed a tibble within a tibble we wrap it in a list. We use justification so that the x and y coordinates correspond to the lower left corner of the table---instead of the default which at
the centre. This behaviour is the same as for justification in \gggeom{geom\_text()} and
\gggeom{geom\_label()}.

<<ggpmisc-A1>>=
tb <- tibble(date = ymd(c("2017-05-21", "2007-05-21"), tz = "UCT"),
             value = 1:2 * 10)
data.tb <- tibble(x = 0, y = 2e5, tb = list(tb))
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_table(data = data.tb, aes(label = tb), hjust = 0, vjust = 0) +
  theme_bw()
@

The \code{color} and \code{size} aesthetics control the text within the table.

<<ggpmisc-A2>>=
tb <- tibble(date = ymd(c("2017-05-21", "2007-05-21"), tz = "UCT"),
             value = 1:2 * 10)
data.tb <- tibble(x = 25, y = 8e5, tb = list(tb))
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_table(data = data.tb, aes(label = tb), colour = "blue", size = 4) +
  theme_bw()
@

It is also possible to rotate the table using \code{angle}. As with text labels, justification is interpreted in relation to table-text orientation. We set the \code{x = 0} in \code{data.tb} and then use \code{vjust = 1} to position the top of the
table at this coordinate value.

<<ggpmisc-A3>>=
tb <- tibble(date = ymd(c("2017-05-21", "2007-05-21"), tz = "UCT"),
             value = 1:2 * 10)
data.tb <- tibble(x = 0, y = 8e5, tb = list(tb))
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_table(data = data.tb, aes(label = tb), angle = 90, vjust = 1) +
  theme_bw()
@

Parsed text, using plotmath syntax is supported in the table, with fallback to
plain text in case of parsing errors, on a cell by cell basis.

<<ggpmisc-A4>>=
tb.pm <- tibble(parameter = c("frac(beta[1], a^2)", "frac(beta[2], a^3)"),
             value = c("10^2.4", "10^3.532"))
data.tb <- tibble(x = 12.5, y = 8e5, tb = list(tb.pm))
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_table(data = data.tb, aes(label = tb), parse = TRUE) +
  theme_bw()
@

We end this section with a simple example, which even if not very useful demonstrates that
\gggeom{geom\_table()} behaves like a ``normal'' ggplot geometry and that a table can be the only
data layer in a ggplot object if desired.

<<ggpmisc-A5>>=
tb.pm <- tibble('x^0' = 1,
                'x^1' = 1:5,
                'x^2' = (1:5)^2,
                'x^3' = (1:5)^3)
data.tb <- tibble(x = 1, y = 1, tb = list(tb.pm))
ggplot(data.tb, aes(x, y, label = tb)) +
  geom_table(size = 7, parse = TRUE) +
  theme_void()
@

\begin{explainbox}
  This \emph{geometry} uses internally functions from package \pkgname{gridExtra}. The use of
  table themes is not yet supported by this geometry. Neither is the addition of multiple tables with a single call to \gggeom{geom\_table()} by passing a \code{tibble} with multiple rows as argument. These features will be added in a future version.
\end{explainbox}

\subsection{Equations as text or labels from model fits}
\index{plots!fitted curves!equation annotation}
\index{plots!annotations!fitted model labels}
<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

How to add a label with a polynomial equation including coefficient estimates from a model fit seems to be a frequently asked question in Stackoverflow. The parameter estimates are extracted automatically from a fit object corresponding to each \textit{group} or panel in a plot and other aesthetics for the group respected. An aesthetic is provided for this, and only this. Such a statistics needs to be used together with another geom or stat like geom smooth to add the fitted line. A different approach, discussed in Stackoverflow, is to write a statistics that does both the plotting of the polynomial and adds the equation label. Package \ggpmisc defines \ggstat{stat\_poly\_eq()} using the first approach which follows the `rule' of using one function in the code for a single action. In this case there is a drawback that the users is responsible for ensuring that the model used for the label and the label are the same, and in addition that the same model is fitted twice to the data.

\subsubsection{Linear models}

This section shows examples of linear models with one independent variables, including different polynomials.
We first give an example using default arguments.

<<ggpmisc-31>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(formula = formula, parse = TRUE)
@

The default \emph{geometry} used by the \emph{statistic} is \gggeom{geom\_text()} but it is possible to use \gggeom{geom\_label()} instead when the intention is to have a color background for the label. The default background \code{fill} is white but this can also changed in the usual way by mapping the \code{fill} \emph{aesthetic}.

<<ggpmisc-32>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(geom = "label", formula = formula, parse = TRUE)
@

It is also possible to create a semi-transparent text background by use of the \code{alpha} \emph{aesthetic}.

<<ggpmisc-33>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(geom = "label", alpha = 0.3, formula = formula, parse = TRUE)
@

The \gggeom{geom\_label\_repel()} accepts the same arguments as \gggeom{geom\_label()} for controlling the format of the box and border. We give a simple example here. For other examples see page \pageref{par:plot:label}.

<<ggpmisc-34>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(geom = "label",
               label.size = 0,
               label.r = unit(0, "lines"),
               color = "white",
               fill = "grey10",
               formula = formula, parse = TRUE) +
  theme_bw()
@

The remaining examples in this section use the default \gggeom{geom\_text()} but can be modified to use \gggeom{geom\_label()} as shown above.

\ggstat{stat\_poly\_eq()} makes available five different labels in the returned data frame. $R^2$, $R_{\mathrm{adj}}^2$, AIC, BIC and the polynomial equation. $R^2$ is used by default, but \Rfunction{aes()} can be used to select a different one.

<<ggpmisc-35>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..adj.rr.label..),
               formula = formula, parse = TRUE)
@

<<ggpmisc-36>>=
formula <- y ~ poly(x, 3, raw = TRUE)
  ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..AIC.label..),
               formula = formula, parse = TRUE)
@

<<ggpmisc-37>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

Within \Rfunction{aes()} it is possible to \textit{compute} new labels based on those returned plus ``arbitrary'' text. The supplied labels are meant to be \textit{parsed} into R expressions, so any text added should be valid for a string that will be parsed. Here we need to \emph{scape} the quotation marks. See section \ref{sec:plot:plotmath} starting on page \pageref{sec:plot:plotmath} for details on parsing character strings into expressions.

<<ggpmisc-38>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste(..eq.label..,
                                 ..adj.rr.label..,
                                 sep = "*\",\"~~")),
               formula = formula, parse = TRUE)
@

<<ggpmisc-39>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste("atop(", ..AIC.label.., ",",
                                       ..BIC.label.., ")",

                                       sep = "")),
               formula = formula, parse = TRUE)
@

Two examples of removing or changing the \textit{lhs} and/or the \textit{rhs} of the equation. (Be aware that the equals sign must be always enclosed in backticks in a string that will be parsed.)

<<ggpmisc-3A>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(hat(y))~`=`~",
formula = formula, parse = TRUE)
@

<<ggpmisc-3B>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  labs(x = expression(italic(z)), y = expression(italic(h)) ) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(h)~`=`~",
               eq.x.rhs = "~italic(z)",
               formula = formula, parse = TRUE)
@

As any valid R expression can be used, Greek letters are also supported, as well as the inclusion in the label of variable transformations used in the model formula.

<<ggpmisc-3C>>=
formula <- y ~ poly(x, 2, raw = TRUE)
ggplot(my.data, aes(x, log10(y + 1e6))) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "plain(log)[10](italic(y)+10^6)~`=`~",
               formula = formula, parse = TRUE)
@

Example of a polynomial of fifth order.

<<ggpmisc-3D>>=
opts_chunk$set(opts_fig_wide)
@

<<ggpmisc-3E>>=
formula <- y ~ poly(x, 5, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@


<<ggpmisc-3F>>=
opts_chunk$set(opts_fig_narrow)
@

Intercept forced to zero---line through the origin.

<<ggpmisc-3G>>=
formula <- y ~ x + I(x^2) + I(x^3) - 1
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

We give some additional examples to demonstrate how other components of the \Rclass{ggplot}
object affect the behaviour of this statistic.

Facets work as expected either with fixed or free scales. Although below we
had to adjust the size of the font used for the equation.

<<ggpmisc-3H,echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggpmisc-3I>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), # size = 2.8,
               formula = formula, parse = TRUE) +
  facet_wrap(~group)
@

Grouping, in this example using colour aesthetic also works as expected.

<<ggpmisc-3J,echo=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<ggpmisc-3K>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE) +
  theme_bw() +
  theme(legend.position = "top")
@

\subsubsection{Other types of models}

Another statistic, \ggstat{stat\_fit\_glance()} allows lots of flexibility. The current version \pkgname{ggplot2} implements \ggstat{stat\_smooth()} in a way that also allows ample flexibility.

We give a first example with a linear model, showing a P-value (a frequent request for which I do not find much use).

We use \gggeom{geom\_debug()} to find out what values \ggstat{stat\_glance()} returns for our linear model, and add labels with P-values for the fits.

<<ggpmisc-41>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_glance(method.args = list(formula = formula),
                  geom = "debug",
                  summary.fun = print,
                  summary.fun.args = list()) +
  theme_bw() +
  theme(legend.position = "top")
@

Using the information now at hand we create some labels.
<<ggpmisc-42>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_glance(aes(label = paste('italic(P)~`=`~', signif(..p.value.., 3), sep = "")),
                  parse = TRUE,
                  method.args = list(formula = formula),
                  geom = "text") +
  theme_bw() +
  theme(legend.position = "top")
@

We use \gggeom{geom\_debug()} to find out what values \ggstat{stat\_fit\_glance()} returns for our resistant linear model fitted with \Rfunction{rlm()} from package \pkgname{MASS}.

<<ggpmisc-43>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "rlm", formula = formula) +
  stat_fit_glance(method.args = list(formula = formula),
                  geom = "debug",
                  method = "rlm",
                  summary.fun = print,
                  summary.fun.args = list()) +
  theme_bw() +
  theme(legend.position = "top")
@

Using the information now at hand we create some labels.
<<ggpmisc-44>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "rlm", formula = formula) +
  stat_fit_glance(aes(label = paste('AIC~`=`~', signif(..AIC.., 3),
                      "~~", 'BIC~`=`~', signif(..BIC.., 3), sep = "")),
                  parse = TRUE,
                  method = "rlm",
                  method.args = list(formula = formula),
                  geom = "text") +
  theme_bw() +
  theme(legend.position = "top")
@

In a similar way one can generate labels for any fit supported by package \pkgname{broom}, such as a Michaelis-Menten equation.

<<ggpmisc-45>>=
micmen.formula <- y ~ SSmicmen(x, Vm, K)
ggplot(Puromycin, aes(conc, rate, colour = state)) +
  geom_point() +
  geom_smooth(method = "nls",
              formula = micmen.formula,
              se = FALSE) +
  stat_fit_glance(method = "nls",
                  method.args = list(formula = micmen.formula),
                  geom = "text",
                  aes(label = paste("AIC = ", signif(..AIC.., digits = 3),
                                    ", BIC = ", signif(..BIC.., digits = 3),
                                    sep = ""))) +
  theme_bw() +
  theme(legend.position = "top")
@

To add an equation, or the values of the fitted parameters we use the statistic \ggstat{stat\_fit\_tidy()}. We show an example of adding an equation using paste to build a character string that is later parsed into a
suitable expression.  We skip here the use of \gggeom{geom\_debug()} as the names of the parameters
can be found in the help page for \Rfunction{SSmicmen()}.

<<ggpmisc-46>>=
micmen.formula <- y ~ SSmicmen(x, Vm, K)
ggplot(Puromycin, aes(conc, rate, colour = state)) +
  geom_point() +
  geom_smooth(method = "nls",
              formula = micmen.formula,
              se = FALSE) +
  stat_fit_tidy(method = "nls",
                method.args = list(formula = micmen.formula),
                geom = "text",
                label.x.npc = 0.9,
                label.y.npc = 0.3,
                aes(label = paste("V~`=`~frac(", signif(..Vm_estimate.., digits = 2), "~C,",
                                  signif(..K_estimate.., digits = 2), "+C)",
                                  sep = "")),
                parse = TRUE) +
  labs(x = "C", y = "V") +
  theme_bw() +
  theme(legend.position = "top")
@

\subsection{ANOVA and summary tables from model fits}
\index{plots!fitted model!ANOVA table}
\index{plots!fitted model!summary table}
\index{plots!annotations!fitted model tables}

The statistics \code{stat\_fit\_tb} makes it possible to add summary or ANOVA tables for any fitted model for which \code{broom::tidy()} is implemented. The output from \code{tidy()} is embedded as a single list value within the returned \code{data}, an object of class \code{"tibble"}. This statistic \textbf{ignores grouping} based on aesthetics. This allows fitting models when \code{x} or \code{y} are mapped to a factor---as in such cases \pkgname{ggplot2} splits the data into groups, one for each level of the factor, which is needed for example for \code{stat\_summary()} to work as expected. By default, the \code{"table"} geometry is used. The use of \gggeom{geom\_table()} is described in section \ref{sec:plot:geom:table} on page \pageref{sec:plot:geom:table}.

The default return value of \code{stat\_fit\_tb} is the default output from \code{tidy(mf)} where \code{mf} is the fitted model. In the first three examples we fit linear models.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggpmisc-B1>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_tb(method = "lm",
              method.args = list(formula = formula),
              label.y.npc = "top", label.x.npc = "left") +
  theme_bw()
@

When \code{tb.type = "fit.anova"} the output returned is that from \code{tidy(anova(mf))} where \code{mf} is the fitted model.

<<ggpmisc-B2>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_tb(method = "lm",
              method.args = list(formula = formula),
              tb.type = "fit.anova",
              label.y.npc = "top", label.x.npc = "left") +
  theme_bw()
@

When \code{tb.type = "fit.coefs"} the output returned is that of \code{tidy(mf)} after selecting the \code{term} and \code{estimate} columns.

<<ggpmisc-B3>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_tb(method = "lm",
              method.args = list(formula = formula),
              tb.type = "fit.coefs",
              label.y.npc = "center", label.x.npc = "left") +
  theme_bw()
@

Faceting works as expected, but grouping is ignored as mentioned above. In this case, the colour aesthetic is not applied to the text of the tables. Furthermore,
if \code{label.x.npc} or \code{label.y.npc} are passed numeric vectors of length > 1, the
values are obeyed by the different panels. In addition, we use this example to show how
tables of coefficient estimates for the fit of a function non-linear in its parameters,
in this case the Michaelis-Menten fucntion can be obtained.

<<ggpmisc-B4>>=
micmen.formula <- y ~ SSmicmen(x, Vm, K)
ggplot(Puromycin, aes(conc, rate, colour = state)) +
  facet_wrap(~state) +
  geom_point() +
  geom_smooth(method = "nls",
              formula = micmen.formula,
              se = FALSE) +
  stat_fit_tb(method = "nls",
              method.args = list(formula = micmen.formula),
              tb.type = "fit.coefs",
              label.x.npc = 0.67,
              label.y.npc = c(0.6, 0.3)) +
  theme(legend.position = "none") +
  labs(x = "C", y = "V") +
  theme_bw()
@

The data in the example below are split by \code{ggplot} into six groups based on the levels of the \code{feed} factor. However, as \code{stat\_fit\_tb()} ignores groupings, we can still fit a linear model to all the data in the panel. Using defaults for formula, we fit a linear model with a factor as explanatory variable, and add to the plot the ANOVA table.

<<ggpmisc-B5>>=
ggplot(chickwts, aes(factor(feed), weight)) +
  stat_summary(fun.data = "mean_se") +
  stat_fit_tb(tb.type = "fit.anova",
              label.x.npc = 1.07, hjust = 1,
              label.y.npc = "bottom") +
  expand_limits(y = 0) +
  theme_bw()
@

We can flip the system of coordinates of the plot, if desired. Be aware that in this case
the specification of the position of the table refers to the aesthetics, which are now flipped.

<<ggpmisc-B6>>=
ggplot(chickwts, aes(factor(feed), weight)) +
  stat_summary(fun.data = "mean_se") +
  stat_fit_tb(tb.type = "fit.anova",
              label.x.npc = 1.1, hjust = 0,
              label.y.npc = 0, vjust = 1) +
  expand_limits(y = 0) +
  coord_flip() +
  theme_bw()
@

It is also possible to rotate the table using \code{angle}. The justification arguments are interpreted, as usual, with respect to the orientation of the table.

<<ggpmisc-B7>>=
ggplot(chickwts, aes(factor(feed), weight)) +
  stat_summary(fun.data = "mean_se") +
  stat_fit_tb(tb.type = "fit.anova",
              angle = 90,
              size = 2,
              label.x.npc = 0.5, hjust = 0.5,
              label.y.npc = 0, vjust = 1) +
  expand_limits(y = 0) +
  coord_flip() +
  theme_bw()
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\subsection{Highlighting deviations from fitted line}
\index{plots!fitted curves!deviations}
\index{plots!fitted curves!residuals}
First an example using default arguments for \ggstat{stat\_fit\_deviations()}.

<<ggpmisc-51>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula)
@

And setting some to the \emph{aesthetics} to non-default values.

<<ggpmisc-52>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula, color = "red",
                      arrow = arrow(length = unit(0.015, "npc"),
                                   ends = "both")) +
  geom_point()
@

Grouping is respected. Here \code{colour} is mapped to the variable \code{group}.

<<ggpmisc-53>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y, colour = group)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula) +
  geom_point()
@

\subsection{Plotting residuals from linear fit}
\index{plots!fitted curves!residuals}

We can plot the residuals by themselves with \ggstat{stat\_fit\_residuals()}.

<<ggpmisc-61>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y, colour = group)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = formula)
@

\subsection{Filtering observations based on local density}\label{sec:dens:filter}
\index{plots!filter observations by density}
Statistics \ggstat{stat\_dens2d\_filter()} works best with clouds of observations, so we generate some random data.

<<ggpmisc-71>>=
set.seed(1234)
nrow <- 200
my.2d.data <- tibble(
    x = rnorm(nrow),
    y = rnorm(nrow) + rep(c(-1, +1), rep(nrow / 2, 2)),
    group = rep(c("A", "B"), rep(nrow / 2, 2))
   )
@

In most recipes in the section we use \ggstat{stat\_dens2d\_filter()} to highlight observations with the \code{color} aesthetic. Other aesthetics can also be used.

By default 1/10 of the observations are kept from regions of lowest density.

<<ggpmisc-72>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red")
@

Here we change the fraction to 1/3.

<<ggpmisc-73>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.fraction = 1/3)
@

We can also set a maximum number of observations to keep.

<<ggpmisc-74>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.number = 3)
@

We can also keep the observations from the densest areas instead of the from the sparsest.

<<ggpmisc-75>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.sparse = FALSE)
@

<<ggpmisc-76>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.sparse = FALSE) +
  facet_grid(~group)
@

In addition to \ggstat{stat\_dens2d\_filter()} there is \ggstat{stat\_dens2d\_filter\_g()}. The difference is in that the first one computes the density on a plot-panel basis while the second one does it on a group basis. This makes a difference only when observations are grouped based on another aesthetic within each panel.

<<ggpmisc-77>>=
ggplot(my.2d.data, aes(x, y, color = group)) +
  geom_point() +
  stat_dens2d_filter(shape = 1, size = 3)
@

<<ggpmisc-78>>=
ggplot(my.2d.data, aes(x, y, color = group)) +
  geom_point() +
  stat_dens2d_filter_g(shape = 1, size = 3)
@

A related stat \ggstat{stat\_dens2d\_label()}, also defined in package \ggpmisc is described in section \ref{sec:repel:dens} on page \pageref{sec:repel:dens}.

\subsection{Layer arcana}
\index{plots!layers!manipulation}
\index{plots!grammar of graphics!exceptional operations}
Layers in \code{ggplot} objects (\pkgname{ggplot2} (>= 2.0.0)) are stored as lists of \code{ggproto} objects. They are self contained, and their position in the internal list in the object determines the plotting order. This means that \emph{breaking the rules} of the Grammar of Graphics is possible. In most circumstances this is a very bad idea, but in some cases ``breaking the rules'' can simplify the coding of higher level functions, or allow the tweaking of the output from such functions. In other words, the functions briefly described here should be used with caution, and only when no good solution to a problem is available within the grammar.

We first create and save a plot to be used in the examples. We map colour to constants so as to show that these mappings are preserved, and also to make it easier to recognise the different layers. We also print it to have a reference to compare to the manipulated plots created in the rest of this section.

<<ggpmisc-80>>=
formula <- y ~ poly(x, 3, raw = TRUE)
p <-
    ggplot(my.data, aes(x, y)) +
          geom_point(colour = "darkgreen") +
          geom_smooth(method = "lm", formula = formula, alpha = 0.5) +
          stat_fit_deviations(formula = formula, colour = "darkorange") +
          theme_bw()
p
@

As an example we will \emph{delete} the layer with the individual observations.

<<ggpmisc-81>>=
delete_layers(p, "GeomPoint")
@

In the example above, the layers to operate on are selected by matching the class of the layer objects---both \emph{geometries} and \emph{statistics} can be matched to. Had the plot contained two separate \code{"GeomPoint"} layers, both would have been deleted. It is also possible to select layers using integers as indexes.

<<ggpmisc-81a>>=
delete_layers(p, idx = 1)
@

We can also \emph{move} the same layer to the top of the list so as to be plotted last, ``covering'' the remaining layers.

<<ggpmisc-82>>=
move_layers(p, "GeomPoint", position = "top")
@

We can \emph{append} a new layer at any position in the stack of layers.

<<ggpmisc-83>>=
append_layers(p,
              geom_hline(yintercept = 0,
                         size = 1.2,
                         colour = "purple"),
              position = "bottom")
@

When passed a numeric index as argument for \code{position}, \code{append\_layers()} behaves as base R's \code{append()} function does, the new layer(s) are ``inserted'' after the given position (\code{position = 0L} is a valid argument).

<<ggpmisc-83a>>=
append_layers(p,
              geom_hline(yintercept = 0,
                         size = 1.2,
                         colour = "purple"),
              position = 2L)
@

With function \code{move\_layers()} we can move a layer to a specific position in the list, while with \code{shift\_layers()} we can shift the position of a layer up or down in the list relative to its current position. Look carefully at the next plot, and you will see that the segments marking the deviations from the fit are now behind the observations and the smooth line.

<<ggpmisc-84>>=
shift_layers(p, "StatFitDeviations", shift = -2L)
@

When using indexes to select which layer to operate on, we will frequently want to programmatically locate the position of layers in the layer list.

<<ggpmisc-85>>=
num_layers(p)
top_layer(p)
bottom_layer(p) # always 1L, unless the list is empty
which_layers(p, "GeomPoint")
@

Function \code{extract\_layers()} returns a list containing the matching layers. This final example copies one layer from an existing plot into a newly defined one. This function is included for completeness, and is used internally, but probably rarely of much use in user code.

<<ggpmisc-86>>=
ggplot(my.data, aes(x, y)) +
  extract_layers(p, "GeomPoint")
@

\subsection{Learning and/or debugging}
\index{plots!debugging}
\index{plots!statistics!debug}
\index{plots!geometries!debug}
A very simple stat named \ggstat{stat\_debug()} can save the work of adding print statements to the code of stats to get information about what data is being passed to the \Rfunction{compute\_group()} function. Because the code of this function is stored in a \code{ggproto} object, at the moment it is impossible to directly set breakpoints in it. This \ggstat{stat\_debug()} may also help users diagnose problems with the mapping of aesthetics in their code or just get a better idea of how the internals of \ggplot work.\label{ggpmisc:plotex:lynx:century}

<<ggpmisc-91>>=
ggplot(lynx) + geom_line() +
  stat_debug_group()
@

<<ggpmisc-92>>=
ggplot(lynx,
       aes(time, lynx,
           color = ifelse(time >= 1900, "XX", "XIX"))) +
  geom_line() +
  stat_debug_group() +
  labs(color = "century")
@

By means of \gggeom{geom\_debug()} it is possible to "print" to the console the data returned by a ggplot \emph{statistic}.

<<ggpmisc-93>>=
ggplot(mpg, aes(class, hwy, color = class)) +
  geom_point(alpha = 0.2) +
  stat_summary(fun.data = mean_se, size = 0.6)
@

<<ggpmisc-94>>=
ggplot(mpg, aes(class, hwy, color = class)) +
  geom_debug() +
  stat_summary(fun.data = mean_se,
               geom = "debug", summary.fun = as_tibble, summary.fun.args = list())
@

\section[`ggsignif']{\ggsignif}\label{sec:plot:ggsignif}
\index{plots!geometries!significance labels}
<<ggsignif-0>>=
citation(package = "ggsignif")
@

Package \ggsignif does a single thing, facilitates labelling of significant differences among groups. This is achieved through
one geometry and one statistic, \gggeom{geom\_signif} and \ggstat{stat\_signif}. They can be used both as a dumb geometry and passed the results of tests done outwith the plot, or as a statistic which carries out the tests of significance based on the plotted data. We reproduce the example from section \ref{sec:plot:stat:summaries} on page \pageref{sec:plot:stat:summaries}, and add annotations for tests of significance.

<<ggsignif-01>>=
set.seed(567879)
fake.data <- data.frame(
               y = c(rnorm(20, mean = 2, sd = 0.5),
                     rnorm(20, mean = 4, sd = 0.7)),
               group = gl(2, 20, labels = LETTERS),
               subgroup = gl(4, 10, labels = letters)
)
@

In the first example we directly print the $p$-value.

<<ggsignif-02>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
    geom_point(shape = 21) +
    stat_summary(fun.data = "mean_cl_boot", colour="red", size=1, alpha=0.7) +
    geom_signif(comparisons = list(c("A", "B")),
                test = "t.test",
                colour = "blue")
@

In the second example we map it to asterisks.

<<ggsignif-03>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
    geom_point(shape = 21) +
    stat_summary(fun.data = "mean_cl_boot", colour="red", size=1, alpha=0.7) +
    geom_signif(comparisons = list(c("A", "B")),
                test = "t.test",
                map_signif_level = TRUE,
                colour = "blue")
@

In the third example, we manually enter the label and the positions for the bar.

<<ggsignif-04>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
    geom_boxplot(width = 0.2) +
    geom_signif(annotations = "A-B",
                y_position = 6, xmin = 1, xmax = 2,
                colour = "blue")
@

A slightly more complicated example, taking advantage of some of the flexibility that can be obtained by means of additional arguments.

<<ggsignif-05>>=
ggplot(data = fake.data, aes(y = y, x = subgroup)) +
    geom_boxplot(width = 0.4) +
    geom_signif(comparisons = list(c("a", "b"), c("a", "c"), c("a", "d")),
                test = "t.test",
                map_signif_level = TRUE,
                step_increase = 0.15)
@

All the previous examples are for tests that are run on-the-fly. In the case of the first plots in this section, with a single contrast, the uncorrected $p$-values from the t-test are suitable. In the example immediately above, we have set three pair-wise comparisons. The $p$-values from these are not adjusted for multiple comparisons, and the tests done are based on the data for the two treatments compared. In most cases this in not a satisfactory/valid approach to multiple testing. See section \ref{sec:plotex:pairwise:contrasts} on page \pageref{sec:plotex:pairwise:contrasts} for examples of the use of \code{fit.contrast()} and \code{p.adjust} together with \code{geom\_signif()} in its ``manual'' mode in the case of a split-plot experiment with two factors in a randomized complete blocks design.

The manual mode of \code{geom\_signif()} can be used to highlight ranges of $x$, labelling them with any character string. We revisit the example from page \pageref{ggpmisc:plotex:lynx:century}, but now we use bars to highlight the centuries instead of colours.

<<ggsignif-06>>=
ggplot(data = lynx, aes(time, lynx)) +
       geom_line() +
       geom_signif(data = data.frame(start = c(1800, 1900),
                                     end = c(1899, 1999),
                                     label = c("XIX", "XX"),
                                     y_pos = rep(7.2e3, 2)),
                   aes(xmin = start, xmax = end, annotations = label, y_position = y_pos),
                   manual = TRUE)
@

\section[`ggrepel']{\ggrepel}\label{sec:plot:ggrepel}
\index{plots!text in}
\index{plots!geometries!repulsive text}
\index{plots!geometries!repulsive label}
<<ggrepel-0>>=
citation(package = "ggrepel")
@

Package \ggrepel was developed and is maintained by Kamil Slowikowski. It does a single
thing, relocates text labels so that they do not overlap. This is achieved through
two geometries that work similarly to those provided by \ggplot except for the
relocation. This is incredibly useful both when labeling peaks and valleys and when
labeling points in scatter-plots. This is a significant problem in bioinformatics
plots and in maps.

\subsection{New geoms}

Package \ggrepel provides two new geoms: \gggeom{geom\_text\_repel()} and \gggeom{geom\_label\_repel()}. They are used similarly to \gggeom{geom\_text()} and \gggeom{geom\_label()} but the text or labels ``repel'' each other so that they rarely overlap unless the plot is very crowded. The vignette \emph{ggrepel Usage Examples} provides very nice examples of the power and flexibility of these geoms. The algorithm used for avoiding overlaps through repulsion is iterative, and can be slow when the number of labels or observations are in the thousands.

I reproduce here some simple examples from the \ggrepel vignette.

<<>>=
opts_chunk$set(opts_fig_wide_square)
@

Just using defaults, we avoid overlaps among text items on the plot. \gggeom{geom\_text\_repel()} has some parameters matching those in \gggeom{geom\_text()}, but those related to manual positioning are missing except for \code{angle}. Several new parameters control both the appearance of text and the function of the repulsion algorithm.

<<ggrepel-01>>=
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(color = 'red') +
  geom_text_repel(aes(label = rownames(mtcars)))
@

The chunk below shows how to change the appearance of labels. \gggeom{geom\_label\_repel()} is comparable to \gggeom{geom\_label()}, but with repulsion.

<<ggrepel-02>>=
set.seed(42)
ggplot(mtcars) +
  geom_point(aes(wt, mpg), size = 5, color = 'grey') +
  geom_label_repel(
  aes(wt, mpg, fill = factor(cyl), label = rownames(mtcars)),
      fontface = 'bold', color = 'white',
      box.padding = unit(0.25, "lines"),
      point.padding = unit(0.5, "lines")) +
  theme(legend.position = "top")
@

As with \gggeom{geom\_label()} we can change the width of the border line, or remove it completely as in the example below, by means of an argument passed through parameter \code{label.size} which defaults to 0.25, and 0 as argument removes the border line altogether.

<<ggrepel-03>>=
set.seed(42)
ggplot(mtcars) +
  geom_point(aes(wt, mpg), size = 5, color = 'grey') +
  geom_label_repel(
  aes(wt, mpg, fill = factor(cyl), label = rownames(mtcars)),
      fontface = 'bold', color = 'white',
      box.padding = unit(0.25, "lines"),
      point.padding = unit(0.5, "lines"),
      label.size = 0) +
  theme(legend.position = "top")
@

The parameters \code{nudge\_x} and \code{nudge\_y} allow strengthening or weakening the repulsion force, or favouring a certain direction. We also need to expand the x-axis high limit to make space for the labels.

<<>>=
opts_chunk$set(opts_fig_wide)
@

<<ggrepel-04>>=
set.seed(42)
ggplot(Orange, aes(age, circumference, color = Tree)) +
  geom_line() +
  expand_limits(x = max(Orange$age) * 1.1) +
  geom_text_repel(data = subset(Orange, age == max(age)),
                  aes(label = paste("Tree", Tree)),
                  size = 5,
                  nudge_x = 65,
                  segment.color = NA) +
  theme(legend.position = "none") +
  labs(x = "Age (days)", y = "Circumference (mm)")
@

We can combine \ggstat{stat\_peaks()} from package \ggpmisc with the use of repulsive text to avoid overlaps between text items. We use \code{nudge\_y = 500} to push the text upwards.

<<ggrepel-05>>=
ggplot(lynx) +
  geom_line() +
  stat_peaks(geom = "text_repel", nudge_y = 500)
@

\subsection{Selectively plotting repulsive labels}\label{sec:repel:dens}
\index{plots!advanced examples!selected repulsive text}
To repel text or labels so that they do not overlap unlabelled observations, one can set the labels to an empty character string \code{""}. Setting labels to \code{NA} skips the observation completely, as is the usual behavior in \ggplot2 geoms, and can result in text or labels overlapping those observations. Labels can be set manually to \code{""}, but in those cases where all observations have labels in the data, but we would like to plot only those in low density regions, this can be automated. Geoms \gggeom{geom\_text\_repel()} and \gggeom{geom\_label\_repel()} from package \ggrepel can be used together with \ggstat{stat\_dens2d\_label()} from package \ggpmisc.

To demonstrate this we first generate suitable data and labels.

<<ggrepel-10>>=
# Make random labels
random_string <- function(len = 6) {
paste(sample(letters, len, replace = TRUE), collapse = "")
}
@

<<ggrepel-11>>=
# Make random data.
set.seed(1001)
myl.data <- tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)
head(myl.data)
@

The first example uses defaults.

<<ggrepel-12>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_repel")
@

The fraction of observations can be plotted, as well as the maximum number can be both set through parameters, as shown in section \ref{sec:dens:filter} on page \pageref{sec:dens:filter}.

Something to be aware of when rotating labels is that repulsion is always based on bounding box that does not rotate, which for long labels and angles that are not multiples of 90 degrees, reserves too much space and leaves gaps between segments and text. Compare the next two figures.

<<ggrepel-13>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_repel", angle = 90)
@

<<ggrepel-14>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_repel", angle = 45)
@

Labels cannot be rotated.

<<ggrepel-15>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "label_repel")
@

\section['tidyquant']{\pkgname{tidyquant}}\label{sec:plot:tidyquant}
\index{plots!time series!moving average}
\index{plots!time series!tibble}
<<tidyquant-01>>=
citation(package = "tidyquant")
@

<<tidyquant-02,echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

The focus of this extension to \pkgname{ggplot2} is the conversion of time series data into tidy tibbles. It also defines additional \emph{geometries} for plotting moving averages with \ggplot. Package \pkgname{tidyquant} defines six \emph{geometries}, several mutators for time series stored as tibbles are also exported. Furthermore it integrates with packages used for the analysis of financial time series: \pkgname{xts}, \pkgname{zoo}, \pkgname{quantmod}, and \pkgname{TTR}. Financial analysis falls outside the scope of this book, so we give no examples of the use of this package.

\section['ggseas']{\pkgname{ggseas}}\label{sec:plot:ggseas}
\index{plots!time series!seasonal decomposition}
<<ggseas-01>>=
citation(package = "ggseas")
@

<<ggseas-02,echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

The focus of this extension to \pkgname{ggplot2} is the seasonal decomposition of time series done on the fly while creating a ggplot. Package \pkgname{ggseas} defines five \emph{statistics}, \ggstat{stat\_index()}, \ggstat{stat\_decomp()}, \ggstat{stat\_rollapplyr()}, \ggstat{stat\_stl()}, and \ggstat{stat\_seas()}. By default they all use \gggeom{geom\_line()}. This package also defines function
\Rfunction{tsdf()} that needs to be used to convert time series to data frames to pass as \code{data} argument to \Rfunction{ggplot()}.

Index referenced to the first two observations in the series. Here we use \Rfunction{ggplot()} method for class \code{"ts"} from our package \pkgname{ggpmisc}. Functions \\Rfunction{try\_tibble()} from \pkgname{ggpmisc} and \Rfunction{tsdf()} from \pkgname{ggseas} can be also used.

<<ggseas-03>>=
ggplot(lynx) +
       stat_index(index.ref = 1:2) +
       expand_limits(y = 0)
@

<<ggseas-04>>=
ggplot(AirPassengers) +
       stat_index(index.ref = 1:10) +
       expand_limits(y = 0)
@

Rolling average.

We use a with of 9, which seems to be approximately the length of the cycle.

<<ggseas-05>>=
ggplot(lynx) +
       geom_line() +
       stat_rollapplyr(width = 9, align = "center", color = "blue") +
       expand_limits(y = 0)
@

For monthly data on air travel, it is clear that a width of 12 observations (months) is best.

<<ggseas-06>>=
ggplot(AirPassengers) +
       geom_line() +
       stat_rollapplyr(width = 12, align = "center", color = "blue") +
       expand_limits(y = 0)
@

Seasonal decomposition.

<<ggseas-07>>=
ggplot(AirPassengers) +
       geom_line() +
       stat_seas(colour = "blue") +
       stat_stl(s.window = 7, color = "red") +
       expand_limits(y = 0)
@

Using function \Rfunction{tsdf()} from package \pkgname{ggseas}.

<<ggseas-08>>=
ggplot(tsdf(AirPassengers),
       aes(x, y)) +
       geom_line() +
       stat_seas(colour = "blue") +
       stat_stl(s.window = 7, color = "red") +
       expand_limits(y = 0)
@

<<ggseas-09,echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section['ggsci']{\pkgname{ggsci}}\label{sec:plot:ggsci}

\index{plots!additional colour palettes}
<<>>=
citation(package = "ggsci")
@

I list here package \pkgname{ggsci} as it provides several \emph{color palettes} (and color maps) that some users may like or find useful. They attempt to reproduce the those used by several publications, films, etc. Although visually attractive, several of them are not safe, in the sense discussed in section \ref{sec:plot:pals} on page \pageref{sec:plot:pals}. For each palette, the package exports a corresponding \emph{statistic} for use with package \ggplot.

Here is one example, using package \pkgname{pals}, to test if it is ``safe''.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggsci-01>>=
pal.safe(pal_uchicago(), n = 9)
@

A few of the discrete palettes as bands, setting \code{n} to 8, which the largest value supported by the smallest of these palettes.

<<ggsci-02>>=
pal.bands(pal_npg(),
          pal_aaas(),
          pal_nejm(),
          pal_lancet(),
          pal_igv(),
          pal_simpsons(),
          n = 8)
@

And a plot using a palette mimicking the one used by Nature Publishing Group (NPG).

<<ggsci-03>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  scale_color_npg() +
  theme_classic()
@

\section['ggthemes']{\pkgname{ggthemes}}\label{sec:plot:ggthemes}
\index{plots!themes}

<<>>=
citation(package = "ggthemes")
@

Package \pkgname{ggthemes} as one can infer from its name, provides definitions of several \emph{themes} for use with package \ggplot. They vary from formal to informal graphic designs, mostly attempting to follow the recommendations and examples of designers like Tufte \autocite{Tufte1983}, or reproduce design used by well known publications or the default output of some frequently used computer programs.

We first save one of the plots earlier used as example, and later print it using different themes.

<<ggthemes-01>>=
p05 <- ggplot(data = Orange,
              aes(x = age, y = circumference, color = Tree)) +
           geom_line()
@

A \ggtheme{theme\_tufte()} obeying Tufte's recommendation of maximizing the information to ink ratio.

<<ggthemes-02>>=
p05 + theme_tufte()
@

A \ggtheme{theme\_economist()} like The Economist.

<<ggthemes-03>>=
p05 + theme_economist()
@

A \ggtheme{theme\_gdocs()} like Google docs.

<<ggthemes-04>>=
p05 + theme_gdocs()
@

\section['ggtern']{\pkgname{ggtern}}\label{sec:plot:ggtern}
\index{plots!ternary plots}
\index{plots!coordinates!ternary}
<<ggtern-01>>=
citation(package = "ggtern")
@

Package \pkgname{ggtern} provides facilities for making ternary plots, frequently used in soil science and in geology, and in sensory physiology and color science for representing trichromic vision (red-green-blue for humans). They are based on a special system of coordinates with three axes on a single plane.

\begin{warningbox}
  Package \pkgname{ggtern} redefines some functions exported by \ggplot and currently easily conflicts with other extensions to \ggplot. One rarely would like to use functions from this and other packages extending \ggplot in the same figure, but using them in the same document could be necessary. In such cases one may need to call the original definitions explicitly, for example \code{ggplot2::ggplot()} instead of simply \Rfunction{ggplot()} which after loading \pkgname{ggtern} no longer refers to the original definition. Because of this problems we load this package here, near the end of the chapter.
\end{warningbox}

<<ggtern-02>>=
library(ggtern)
@

In this example of the use of \Rfunction{ggtern()}, we use colors pre-defined in R and make a ternary plot of the red, green and blue components of these colors.

<<ggtern-03,echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

\begin{warningbox}
\textbf{Known bug.} Function \ggcoordinate{coord\_tern()} and consequently also \Rfunction{ggtern()} trigger fatal error under `ggplot2' $\leq$ 2.2.1.9000. We temporarily disable evaluation of the code chunck below.
\end{warningbox}

<<ggtern-04, eval=FALSE>>=
colours <- c("red", "green", "yellow", "white",
             "orange", "purple", "seagreen", "pink")
rgb.values <- col2rgb(colours)
color.data <- data.frame(colour=colours,
                        R=rgb.values[1, ],
                        G=rgb.values[2, ],
                        B=rgb.values[3, ])
ggtern(data=color.data,
       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
       geom_point(shape=23, size=3) +
  geom_text(hjust=-0.2) +
  labs(x = "R", y="G", z="B") + scale_fill_identity() +
  theme_nomask()
@

In the example above we need to use \ggtheme{theme\_nomask()} to avoid clipping of symbols drawn on the edges of the triangular plotting area.

\begin{playground}
Test how the plot changes if you remove  `\code{+ theme\_nomask()}' from the code chunk above.
\end{playground}

\section[Other extensions to `ggplot2']{Other extensions to \pkgname{ggplot2}}

In this section I list some specialized or very recently released extensions to \pkgname{ggplot2} (Table \ref{tab:ggplot:extensions}). The table below will hopefully temp you to explore those suitable for the data analysis tasks you deal with. There is a package under development, already released through CRAN, called \code{ggvis}. This package is not and extension to \pkgname{ggplot2}, but instead a new implementation of the grammar of graphics, with a focus on the creation of interactive plots.

\begin{table}
  \caption[Additional packages extending `ggplot2']{Additional packages extending \pkgname{ggplot2} whose use is not described in this book. All these packages are available at CRAN.}\label{tab:ggplot:extensions}
  \centering
\begin{tabular}{ll}
  \toprule
  Package & Title \\
  \midrule
  \pkgname{ggspectra} & Extensions \ldots\ for Radiation Spectra \\
  \pkgname{ggspatial} & Spatial data framework \ldots \\
  \pkgname{ggsignif} & Significance Bars \ldots \\
  \pkgname{ggsn} & North Symbols and Scale Bars for Maps \ldots \\
  \pkgname{ggmosaic} & Mosaic Plots \ldots\\
  \pkgname{ggimage} & Use image [map image to shape \emph{aesthetic}] \\
  \pkgname{cowplot} & Streamlined Plot Theme and Plot Annotations \ldots \\
  \pkgname{hrbrthemes} & Additional Themes, Theme Components and Utilities \ldots \\
  \pkgname{ggedit} & Interactive \ldots Layer and Theme Aesthetic Editor \\
  \pkgname{ggparallel} & \ldots\ Parallel Coordinate Plots for Categorical Data\\
  \pkgname{ggraph} & \ldots\ Grammar of Graphics for Graphs and Networks\\
  \pkgname{gglogo} & Geom for Logo Sequence Plots \\
  \pkgname{ggiraph} & Make \ldots Graphics Interactive \\
  \pkgname{ggiraphExtra} & Make Interactive \ldots \\
  \bottomrule
\end{tabular}
\end{table}

\section{Extended examples}

\subsection{Anscombe's example revisited}\label{sec:plotex:anscombe}
\index{plots!advanced examples!Anscombe's linear regression plots|(}
<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

To make the example self contained we repeat the code from chapter \ref{chap:R:plotting}, page \pageref{sec:plot:anscombe}.

<<more-anscombe-01>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- tibble(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

<<more-anscombe-02>>=
ggplot(my.anscombe, aes(x = x, y = y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  stat_poly_eq(formula = y ~ x, parse = TRUE,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@
\index{plots!advanced examples!Anscombe's linear regression plots|)}

\subsection{Heatmaps}\label{sec:plotex:heatmaps}
\index{plots!advanced examples!heatmap plot}


\subsection{Volcano plots}\label{sec:plotex:volcano}
\index{plots!advanced examples!volcano plot}


\subsection{Quadrat plots}\label{sec:plotex:quadrat}
\index{plots!advanced examples!quadrat plot}

\subsection{Significance bars for pairwise contrasts}\label{sec:plotex:pairwise:contrasts}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

The best flexibility in tests of significance can be achieved by fitting specific contrasts of interest after a broader analysis. It is in general recommended that $p$-value estimates from such multiple contrasts should be adjusted. Many variations are possible, so no packaged \emph{statistics} layer can do this automatically. Package \pkgname{ggsignif} currently supports pairwise contrasts computed one by one, which in most cases is not a good approach. In this worked-out example we use \code{geom\_signif()} in its manual mode to highlight the results from fitted contrasts, compute with function \code{fit.contrast()} from package \pkgname{gmodels}. Once computed, we adjust the $p$-values with R's function \code{p.adjust()}, build suitable character labels from these values and then use them to label the plot with the labels. We will use the \code{oats} data set from package \pkgname{MASS} in the examples.

<<signif-fit-contrast-00>>=
library(nlme)
library(gmodels)
data(oats, package = "MASS")
num.V <- length(levels(oats$V))
num.N <- length(levels(oats$N))
@

The data set describes an experiment using split plots, with varieties (\code{V}) in main plots and nitrogen treatments (\code{N}) in the subplots. Replication was in six complete blocks (\code{B}). The response variable is the harvest yield (\code{Y}). We start by plotting the data.

<<signif-fit-contrast-01>>=
ggplot(oats, aes(N, Y)) +
  stat_summary(fun.data = "mean_se", size = 0.4) +
  expand_limits(y = 0) +
  facet_wrap(~V, ncol = num.V)
@

We next fit a linear mixed effects model (LME) and test the main effects and interaction.

<<signif-fit-contrast-02>>=
oats.lme <- lme(Y ~ V * N, random = ~ 1 | B / V, data = oats)
anova(oats.lme)
@

Most interesting treatment factor is \code{N}. We plot again, but with all treatments in the same panel.

<<signif-fit-contrast-02a>>=
ggplot(oats, aes(N, Y, colour = V)) +
  stat_summary(fun.data = "mean_se", size = 0.4) +
  expand_limits(y = 0)
@

We update the model by removing the interaction term.

<<signif-fit-contrast-02b>>=
oats1.lme <- update(oats.lme, fixed = Y ~ V + N)
anova(oats1.lme)
@

We will compare each of the non-zero N application levels, to the zero control. For this we first create a matrix.

<<signif-fit-contrast-03>>=
contrast.matrix <- rbind("0 vs. 0.2" = c(-1, 1, 0, 0),
                         "0 vs. 0.4" = c(-1, 0, 1, 0),
                         "0 vs. 0.6" = c(-1, 0, 0, 1))
num.contrasts <- nrow(contrast.matrix)
@

Next we fit the contrasts, and adjust the resulting $p$-values.

<<signif-fit-contrast-03a>>=
contrasts.p.values <-
  p.adjust(fit.contrast(oats1.lme, "N", contrast.matrix)[ , 4])
@

Using numerical $p$-values we create suitable labels for plotting. The values in the vector, are named according to the row names we set above, when defining the matrix of contrasts.

<<signif-fit-contrast-04>>=
contrast.labels <- gsub("N", "", names(contrasts.p.values))
p.labels <-
  gsub("^0$", "<0.001", sprintf("%.2g", round(contrasts.p.values, 3)))
@

To make it easier to adjust the positions of the bars we set the position of the lowest bar and a vertical distance between bars in units of \code{Y}.

<<signif-fit-contrast-05>>=
y_pos_first <- 125
y_step <- 10
@

We assemble a data frame with three rows (\code{num.contrasts}). In this case, we have fitted contrasts pooling over varieties (\code{V} levels), so we do not need to include a variable \code{V} in this data frame.

<<signif-fit-contrast-06>>=
p.values.df <-
  data.frame(start = rep(levels(oats$N)[1], num.contrasts),
             end = levels(oats$N)[-1],
             label.p.val = p.labels,
             label.contrast = contrast.labels,
             y_pos = y_pos_first + 0:2 * y_step)
print(p.values.df)
@

We add the contrast annotations to the plot.

<<signif-fit-contrast-07>>=
ggplot(data = oats, aes(N, Y, colour = V)) +
  stat_summary(fun.data = "mean_se", position = position_dodge(0.2))+
  expand_limits(y = 0) +
  geom_signif(data = p.values.df,
              colour = "black",
              aes(xmin = start, xmax = end,
                  annotations = label.p.val,
                  y_position = y_pos),
              textsize = 2.8,
              tip_length = 0.01,
              manual= TRUE)
@

<<signif-fit-contrast-08>>=
ggplot(data = oats, aes(N, Y, colour = V)) +
  stat_summary(fun.data = "mean_se", position = position_dodge(0.2))+
  expand_limits(y = 0)+
  geom_signif(data = p.values.df,
              colour = "black",
              aes(xmin = start, xmax = end,
                  annotations = paste(label.contrast, label.p.val, sep = ": "),
                  y_position = y_pos),
              textsize = 2.8,
              tip_length = 0.01,
              manual= TRUE)
@

Had we observed an interaction, we would have really needed to use one panel per variety and separate pairwise contrasts for each of them. Below, we pretend that this approach is needed and valid for this data set and draw the corresponding plot.

We start by fitting separately a model describing the response of \code{Y} to \code{N} to data for each variety (level of \code{V}).

<<signif-fit-contrast-10>>=
oatsV1.lme <- lme(Y ~ N, random = ~ 1 | B, data = oats, subset = V == levels(V)[1])
anova(oatsV1.lme)
oatsV2.lme <- lme(Y ~ N, random = ~ 1 | B, data = oats, subset = V == levels(V)[2])
anova(oatsV2.lme)
oatsV3.lme <- lme(Y ~ N, random = ~ 1 | B, data = oats, subset = V == levels(V)[3])
anova(oatsV3.lme)
@

We here do the adjustment of $p$-values globally for the experiment after fitting the same set of contrasts to each of three models, each fitted separately to subset of the data corresponding to one variety.

<<signif-fit-contrast-11>>=
contrasts.V.p.values <-
  p.adjust(c(fit.contrast(oatsV1.lme, "N", contrast.matrix)[ , 4],
             fit.contrast(oatsV2.lme, "N", contrast.matrix)[ , 4],
             fit.contrast(oatsV3.lme, "N", contrast.matrix)[ , 4]))
@

As above, we create suitable character labels.

<<signif-fit-contrast-12>>=
contrast.V.labels <- gsub("N", "", names(contrasts.V.p.values))
p.V.labels <-
  gsub("^0$", "<0.001", sprintf("%.2g", round(contrasts.V.p.values, 3)))
@

We assemble a data frame, now with nine rows, each row corresponding to a pairwise contrast.  In this case, we have fitted contrasts separately for each variety (\code{V} level), which need to be plotted on different panels. In contrast with the examples above, we need to include a variable \code{V} in this data frame, so that the correct $p$-values are plotted in each panel.

<<signif-fit-contrast-13>>=
p.values.V.df <-
  data.frame(V = rep(levels(oats$V), rep(num.contrasts, num.V)),
             end = rep(levels(oats$N)[-1], num.V),
             start = rep(rep(levels(oats$N)[1], num.contrasts), num.V),
             label.p.val = p.V.labels,
             label.contrast = contrast.V.labels,
             y_pos= rep(y_pos_first + 0:2 * y_step, num.V))
print(p.values.V.df)
@

Finally we create a three panel plot with different annotations in each panel.

<<signif-fit-contrast-14>>=
ggplot(oats, aes(N, Y)) +
  stat_summary(fun.data = "mean_se")+
  expand_limits(y = 0) +
  geom_signif(data = p.values.V.df,
              aes(xmin = start, xmax = end,
                  annotations = label.p.val,
                  y_position = y_pos),
              textsize = 2.8,
              tip_length = 0.01,
              manual= TRUE) +
  facet_wrap(~ V, ncol = num.V)
@

\newpage

<<more-plotting-cleanup>>=
try(detach(package:gginnards))
try(detach(package:gmodels))
try(detach(package:nlme))
try(detach(package:ggtern))
try(detach(package:ggfortify))
try(detach(package:MASS))
try(detach(package:xts))
try(detach(package:ggthemes))
try(detach(package:ggsci))
try(detach(package:geomnet))
try(detach(package:ggnetwork))
try(detach(package:ggExtra))
try(detach(package:ggalt))
try(detach(package:ggbiplot))
try(detach(package:ggstance))
try(detach(package:gganimate))
try(detach(package:ggseas))
try(detach(package:ggpmisc))
try(detach(package:ggforce))
try(detach(package:ggrepel))
try(detach(package:pals))
try(detach(package:viridis))
try(detach(package:showtext))
try(detach(package:ggplot2))
try(detach(package:magrittr))
try(detach(package:tibble))
try(detach(package:learnrbook))
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
knitter_diag()
R_diag()
other_diag()
@
